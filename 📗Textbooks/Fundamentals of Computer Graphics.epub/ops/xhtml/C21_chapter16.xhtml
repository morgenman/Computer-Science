<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xmlns:m="http://www.w3.org/1998/Math/MathML" xmlns:svg="http://www.w3.org/2000/svg" dir="ltr" lang="en" xml:lang="en">
<head>
<meta charset="UTF-8"/>
<title>16 Computer Animation</title>
<link href="../styles/9781000426359.css" rel="stylesheet" type="text/css"/>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
jax: ["input/TeX","input/MathML","output/SVG"],
extensions: ["tex2jax.js","mml2jax.js","MathEvents.js"],
TeX: {
extensions: ["noErrors.js","noUndefined.js","autoload-all.js"]
},
MathMenu: {
showRenderer: false
},
menuSettings: {
zoom: "Click"
},
messageStyle: "none"
});
</script>
<script src="../mathjax/MathJax.js" type="text/javascript"/>
<meta content="urn:uuid:e0000000-0000-0000-0000-000006665500" name="Adept.expected.resource"/>
</head>
<body epub:type="bodymatter">
<section epub:type="chapter" role="doc-chapter">
<header>
<p class="chap-auz"><span class="green">Michael Ashikhmin</span></p>
<h1 class="chapz1" id="c16"><a id="index_term200"/><span aria-label="429" epub:type="pagebreak" id="pg_429" role="doc-pagebreak"/><a epub:type="backlink" href="C02a_toc.xhtml#rc16" role="doc-backlink"><span class="green"><span class="big1">16</span><br/>Computer Animation</span></a></h1>
</header>
<p class="noindent1"><em>Animation</em> is derived from the Latin <em>anima</em> and means the act, process, or result of imparting life, interest, spirit, motion, or activity. Motion is a defining property of life and much of the true art of animation is about how to tell a story, show emotion, or even express subtle details of human character through motion. A computer is a secondary tool for achieving these goals–it is a tool which a skillful animator can use to help get the result he wants faster and without concentrating on technicalities in which he is not interested. Animation without computers, which is now often called “traditional” animation, has a long and rich history of its own which is continuously being written by hundreds of people still active in this art. As in any established field, some time-tested rules have been crystallized which give general high-level guidance to how certain things should be done and what should be avoided. These principles of traditional animation apply equally to computer animation, and we will discuss some of them in this chapter.</p>
<p>The computer, however, is more than just a tool. In addition to making the animator’s main task less tedious, computers also add some truly unique abilities that were simply not available or were extremely difficult to obtain before. Modern modeling tools allow the relatively easy creation of detailed three-dimensional models, rendering algorithms can produce an impressive range of appearances, from fully photorealistic to highly stylized, powerful numerical simulation algorithms can help to produce desired physics-based motion for particularly hard to animate objects, and motion capture systems give the ability to <a id="term-177"/><span aria-label="430" epub:type="pagebreak" id="pg_430" role="doc-pagebreak"/>record and use real-life motion. These developments led to an exploding use of computer animation techniques in motion pictures and commercials, automotive design and architecture, medicine and scientific research, among many other areas. Completely new domains and applications have also appeared including fully computer-animated feature films, virtual/augmented reality systems, and, of course, computer games.</p>
<p>Other chapters of this book cover many of the developments mentioned above (for example, geometric modeling and rendering) more directly. Here, we will provide an overview only of techniques and algorithms directly used to create and manipulate motion. In particular, we will loosely distinguish and briefly describe four main computer animation approaches:</p>
<ul class="list-bullet">
<li>
<p class="list"><strong><span class="green"><a id="index_term647"/>Keyframing</span></strong> gives the most direct control to the animator who provides necessary data at some moments in time and the computer fills in the rest.</p>
</li>
<li>
<p class="list"><strong><span class="green">Procedural</span></strong> animation involves specially designed, often empirical, mathematical functions and procedures whose output resembles some particular motion.</p>
</li>
<li>
<p class="list"><strong><span class="green">Physics-based</span></strong> techniques solve differential equation of motion.</p>
</li>
<li>
<p class="list"><strong><span class="green"><a id="index_term761"/>Motion capture</span></strong> uses special equipment or techniques to record real-world motion and then transfers this motion into that of computer models.</p>
</li>
</ul>
<p>We do not touch upon the artistic side of the field at all here. In general, we cannot possibly do more here than just scratch the surface of the fascinating subject of creating motion with a computer. We hope that readers truly interested in the subject will continue their journey well beyond the material of this chapter.</p>
<section>
<h2 id="sec16_1"><a id="index_term218"/><a epub:type="backlink" href="C02a_toc.xhtml#rsec16_1" role="doc-backlink"><span class="green">16.1 Principles of Animation</span></a></h2>
<p>In his seminal 1987 SIGGRAPH paper (Lasseter, 1987), John Lasseter brought key principles developed as early as the 1930’s by traditional animators of Walt Disney studios to the attention of the then-fledgling computer animation community. Twelve principles were mentioned: <em>squash and stretch</em>, <em>timing</em>, <em>anticipation</em>, <em>follow through and overlapping action</em>, <em>slow-in and slow-out</em>, <em>staging</em>, <em>arcs</em>, <em>secondary action</em>, <em>straight-ahead and pose-to-pose action</em>, <em>exaggeration</em>, <em>solid drawing skill</em>,and <em>appeal</em>. Almost two decades later, these time-tested rules, which can make a difference between a natural and entertaining animation and a mechanistic-looking and boring one, are as important as ever. For computer animation, in addition, it is very important to <em>balance</em> control and flexibility given to <a id="term-20"/><a id="term-21"/><a id="term-155"/><a id="term-182"/><a id="term-183"/><span aria-label="431" epub:type="pagebreak" id="pg_431" role="doc-pagebreak"/>the animator with the full advantage of the computer’s abilities. Although these principles are widely known, many factors affect how much attention is being paid to these rules in practice. While a character animator working on a feature film might spend many hours trying to follow some of these suggestions (for example, tweaking his timing to be just right), many game designers tend to believe that their time is better spent elsewhere.</p>
<section>
<h3 id="sec16_1_1"><span class="green">16.1.1 Timing</span></h3>
<p><em>Timing</em>, or the speed of action, is at the heart of any animation. How fast things happen affects the meaning of action, emotional state, and even perceived weight of objects involved. Depending on its speed, the same action, a turn of a character’s head from left to right, can mean anything from a reaction to being hit by a heavy object to slowly seeking a book on a bookshelf or stretching a neck muscle. It is very important to set timing appropriate for the specific action at hand. Action should occupy enough time to be noticed while avoiding too slow and potentially boring motions. For computer animation projects involving recorded sound, the sound provides a natural timing anchor to be followed. In fact, in most productions, the actor’s voice is recorded first and the complete animation is then synchronized to this recording. Since large and heavy objects tend to move slower than small and light ones (with less acceleration, to be more precise), <a id="index_term222"/>timing can be used to provide significant information about the weight of an object.</p>
</section>
<section>
<h3 id="sec16_1_2"><a id="index_term201"/><span class="green">16.1.2 Action Layout</span></h3>
<p>At any moment during an animation, it should be clear to the viewer what idea (action, mood, expression) is being presented. Good <em>staging</em>, or high-level planning of the action, should lead a viewer’s eye to where the important action is currently concentrated, effectively telling him “look at this, and now, look at this” without using any words. Some familiarity with human perception can help us with this difficult task. Since human visual systems react mostly to relative changes rather than absolute values of stimuli, a sudden motion in a still environment or lack of motion in some part of a busy scene naturally draws attention. The same action presented so that the silhouette of the object is changing can often be much more noticeable compared with a frontal arrangement (see <a href="C21_chapter16.xhtml#f16_1">Figure 16.1</a> (bottom left)).</p>
<figure id="f16_1" tabindex="0">
<img alt="" src="../images/fig16_1.jpg"/>
<figcaption><p><span class="blue">Figure 16.1.</span> Action layout. Left: Staging action properly is crucial for bringing attention to currently important motion. The act of raising a hand would be prominent on the top but harder to notice on the bottom. A change in nose length, on the contrary, might be completely invisible in the first case. Note that this might be intentionally hidden, for example, to be suddenly revealed later. Neither arrangement is particularly good if both motions should be attended to. Middle: The amount of anticipation can tell much about the following action. The action which is about to follow (throwing a ball) is very short, but it is clear what is about to happen. The more wound up the character is, the faster the following action is perceived to be. Right: The follow-through phase is especially important for secondary appendages (hair) whose motion follows the leading part (head). The motion of the head is very simple, but leads to nontrivial follow-through behavior of the hair itself. It is impossible to create a natural animation without a follow-through phase and overlapping action in this case. <em>Figure courtesy Peter Shirley and Christina Villarruel.</em></p></figcaption>
</figure>
<p>On a slightly lower level, each action can be split into three parts: <em>anticipation</em> (preparation for the action), the action itself, and <em>follow-through</em> (termination of the action). In many cases, the action itself is the shortest part and, in some sense, <a id="term-10"/><a id="term-156"/><span aria-label="432" epub:type="pagebreak" id="pg_432" role="doc-pagebreak"/>the least interesting. For example, kicking a football might involve extensive preparation on the part of the kicker and long “visual tracking” of the departing ball with ample opportunities to show the stress of the moment, emotional state of the kicker, and even the reaction to the expected result of the action. The action itself (motion of the leg to kick the ball) is rather plain and takes just a fraction of a second in this case.</p>
<p>The goal of anticipation is to prepare the viewer for what is about to happen. This becomes especially important if the action itself is very fast, greatly <a id="term-11"/><a id="term-157"/><a id="term-158"/><a id="term-172"/><span aria-label="433" epub:type="pagebreak" id="pg_433" role="doc-pagebreak"/>important, or extremely difficult. Creating a more extensive anticipation for such actions serves to underscore these properties and, in case of fast events, makes sure the action will not be missed (see <a href="C21_chapter16.xhtml#f16_1">Figure 16.1</a> (bottom center)).</p>
<p>In real life, the main action often causes one or more other <em><a id="index_term215"/>overlapping actions</em>. Different appendages or loose parts of the object typically drag behind the main leading section and keep moving for a while in the follow-through part of the main action as shown in <a href="C21_chapter16.xhtml#f16_1">Figure 16.1</a> (bottom right). Moreover, the next action often starts before the previous one is completely over. A player might start running while he is still tracking the ball he just kicked. Ignoring such natural flow is generally perceived as if there are pauses between actions and can result in robot-like mechanical motion. While overlapping is necessary to keep the motion natural, <em>secondary action</em> is often added by the animator to make motion more interesting and achieve realistic complexity of the animation. It is important not to allow <a id="index_term220"/>secondary action to dominate the main action.</p>
</section>
<section>
<h3 id="sec16_1_3"><a id="index_term202"/><span class="green">16.1.3 Animation Techniques</span></h3>
<p>Several specific techniques can be used to make motion look more natural. The most important one is probably <em>squash and stretch</em> which suggests to change the shape of a moving object in a particular way as it moves. One would generally stretch an object in the direction of motion and squash it when a force is applied to it, as demonstrated in <a href="C21_chapter16.xhtml#f16_2">Figure 16.2</a> for a classic animation of a bouncing ball. It is important to preserve the total volume as this happens to avoid the illusion of growing or shrinking of the object. The greater the speed of motion (or the force), the more stretching (or squashing) is applied. Such deformations are used for several reasons. For very fast motion, an object can move between two sequential frames so quickly that there is no overlap between the object at the time of the current frame and at the time of the previous frame which can lead to strobing (a variant of aliasing). Having the object elongated in the direction of motion can ensure better overlap and helps the eye to fight this unpleasant effect. Stretching/squashing can also be used to show flexibility of the object with more deformation applied for more pliable materials. If the object is intended to appear as rigid, its shape is purposefully left the same when it moves.</p>
<figure id="f16_2" tabindex="0">
<img alt="" src="../images/fig16_2.jpg"/>
<figcaption><p><span class="blue">Figure 16.2.</span> Classic example of applying the squash and stretch principle. Note that the volume of the bouncing ball should remain roughly the same throughout the animation.</p></figcaption>
</figure>
<p>Natural motion rarely happens along straight lines, so this should generally be avoided in animation and <em>arcs</em> should be used instead. Similarly, no real-world motion can instantly change its speed–this would require an infinite amount of force to be applied to an object. It is desirable to avoid such situations in animation as well. In particular, the motion should start and end gradually (<em>slow in and out</em>). While hand-drawn animation is sometimes done via <em>straight-ahead action</em> <a id="term-159"/><a id="term-160"/><a id="term-162"/><a id="term-484"/><span aria-label="434" epub:type="pagebreak" id="pg_434" role="doc-pagebreak"/>with an animator starting at the first frame and drawing one frame after another in sequence until the end, <em>pose-to-pose action</em>, also known as <em><a id="index_term648"/>keyframing</em>,is much more suitable for computer animation. In this technique, animation is carefully planned through a series of relatively sparsely spaced key frames with the rest of the animation (in-between frames) filled in only after the keys are set (<a href="C21_chapter16.xhtml#f16_3">Figure 16.3</a>). This allows more precise timing and allows the computer to take over the most tedious part of the process–the creation of the in-between frames–using algorithms presented in the next section.</p>
<figure id="f16_3" tabindex="0">
<img alt="" src="../images/fig16_3.jpg"/>
<figcaption><p><span class="blue">Figure 16.3.</span> Keyframing (top) encourages detailed action planning while straight-ahead action (bottom) leads to a more spontaneous result.</p></figcaption>
</figure>
<p>Almost any of the techniques outlined above can be used with some reasonable amount of <em>exaggeration</em> to achieve greater artistic effect or underscore some specific property of an action or a character. The ultimate goal is to achieve something the audience will want to see, something which is <em>appealing</em>. Extreme complexity or too much symmetry in a character or action tends to be less appealing. To create good results, a traditional animator needs <em>solid drawing skills</em>.Analogously, a computer animator should certainly understand computer graphics and have a solid knowledge of the tools he uses.</p>
</section>
<section>
<h3 id="sec16_1_4"><a id="index_term203"/><a id="index_term204"/><span class="green">16.1.4 Animator Control vs. Automatic Methods</span></h3>
<p>In traditional animation, the animator has complete control over all aspects of the production process and nothing prevents the final product to be as it was planned in every detail. The price paid for this flexibility is that every frame is created by hand, leading to an extremely time- and labor-consuming enterprise. In computer animation, there is a clear tradeoff between, on the one hand, giving an animator more direct control over the result, but asking him to contribute more work and, on the other hand, relying on more automatic techniques which might require setting just a few input parameters but offer little or no control over some of the properties of the result. A good algorithm should provide sufficient flexibility while asking an animator only the information which is intuitive, easy to provide, and which he himself feels is necessary for achieving the desired effect. While perfect compliance with this requirement is unlikely in practice since it would probably take something close to a mind-reading machine, we do encourage the reader to evaluate any computer-animation technique from the point of view of providing such <em>balance</em>.</p>
</section>
</section>
<section>
<h2 id="sec16_2"><a epub:type="backlink" href="C02a_toc.xhtml#rsec16_2" role="doc-backlink"><span class="green">16.2 Keyframing</span></a></h2>
<p>The term keyframing can be misleading when applied to 3D computer animation since no actual completed frames (i.e., images) are typically involved. At any Key frames (created first) <a id="term-485"/><span aria-label="435" epub:type="pagebreak" id="pg_435" role="doc-pagebreak"/>given moment, a 3D scene being animated is specified by a set of numbers: the positions of centers of all objects, their RGB colors, the amount of scaling applied to each object in each axis, modeling transformations between different parts of a complex object, camera position and orientation, light sources intensity, etc. To animate a scene, some subset of these values have to change with time. One can, of course, directly set these values at every frame, but this will not be particularly efficient. Short of that, some number of important moments in time (key frames <em>t<sub>k</sub></em>) can be chosen along the timeline of animation for each of the parameters and values of this parameter (key values <em>f<sub>k</sub></em>) are set only for these selected frames. We will call a combination (<em>t<sub>k</sub></em>, <em>f<sub>k</sub></em>) of keyframe andkey valuesimplya key. Key frames do not have to be the same for different parameters, but it is often logical to set keys at least for some of them simultaneously. For example, key frames chosen for <em>x</em>-, <em>y</em>-and <em>z</em>-coordinates of a specific object might be set at exactly the same frames forming a single position vector key (<em>t<sub>k</sub></em>, <strong>p<sub>k</sub></strong>).These key frames, however, might be completely different from those chosen for the object’s orientation or color. The closer key frames are to each other, the more control the animator has over the result; however the cost of doing more work of setting the keys has to be assessed. It is, therefore, typical to have large spacing between keys in parts of the animation which are relatively simple, concentrating them in intervals where complex action occurs, as shown in <a href="C21_chapter16.xhtml#f16_4">Figure 16.4</a>.</p>
<figure id="f16_4" tabindex="0">
<img alt="" src="../images/fig16_4.jpg"/>
<figcaption><p><span class="blue">Figure 16.4.</span> Different patterns of setting keys (black circles above) can be used simultaneously for the same scene. It is assumed that there are more frames before, as well as after, this portion.</p></figcaption>
</figure>
<p>Once the animator sets the key (<em>t<sub>k</sub></em>, <em>f<sub>k</sub></em>), the system has to compute values of <em>f</em> for all other frames. Although we are ultimately interested only in a discrete set of values, it is convenient to treat this as a classical interpolation problem which fits a continuous <em>animation curve f</em>(<em>t</em>) through a provided set of data points (<a href="C21_chapter16.xhtml#f16_5">Figure 16.5</a>). Extensive discussion of curve-fitting algorithms can be found in <a href="C20_chapter15.xhtml#c15">Chapter 15</a><span aria-label="436" epub:type="pagebreak" id="pg_436" role="doc-pagebreak"/>, and we will not repeat it here. Since the animator initially provides only the keys and not the derivative (tangent), methods which compute all necessary information directly from keys are preferable for animation. The speed of parameter change along the curve is given by the derivative of the curve with respect to time <em>df /dt</em>. Therefore, to avoid sudden jumps in velocity, <em>C</em><sup>1</sup> continuity is typically necessary. A higher degree of continuity is typically not required from animation curves, since the second derivative, which corresponds to acceleration or applied force, can experience very sudden changes in real-world situations (ball hitting a solid wall), and higher derivatives do not directly correspond to any parameters of physical motion. These consideration make Catmull-Rom splines one of the best choices for initial animation curve creation.</p>
<figure id="f16_5" tabindex="0">
<img alt="" src="../images/fig16_5.jpg"/>
<figcaption><p><span class="blue">Figure 16.5.</span> A continuous curve <em>f(t)</em> is fit through the keys provided by the animator even though only values at frame positions are of interest. The derivative of this function gives the speed of parameter change and is at first determined automatically by the fitting procedure.</p></figcaption>
</figure>
<p>Most animation systems give the animator the ability to perform interactive fine editing of this initial curve, including inserting more keys, adjusting existing keys, or modifying automatically computed tangents. Another useful technique which can help to tweak the shape of the curve is called TCB control (TCB stands for tension, continuity, and bias). The idea is to introduce three new parameters which can be used to modify the shape of the curve near a key through coordinated adjustment of incoming and outgoing tangents at this point. For keys uniformly spaced in time with distance Δ<em>t</em> between them, the standard Catmull-Rom expression for incoming <span class="inline-formula"><m:math display="inline"><m:mrow><m:msubsup><m:mrow><m:mi>T</m:mi></m:mrow><m:mrow><m:mi>i</m:mi></m:mrow><m:mrow><m:mi>i</m:mi><m:mi>n</m:mi></m:mrow></m:msubsup></m:mrow></m:math></span> and outgoing <span class="inline-formula"><m:math display="inline"><m:mrow><m:msubsup><m:mrow><m:mi>T</m:mi></m:mrow><m:mrow><m:mi>i</m:mi></m:mrow><m:mrow><m:mi>o</m:mi><m:mi>u</m:mi><m:mi>t</m:mi></m:mrow></m:msubsup></m:mrow></m:math></span> tangents at an internal key (<em>t<sub>k</sub></em>, <em>f<sub>k</sub></em>) can be rewritten as</p>
<div class="disp-formula">
<m:math display="block"><m:mrow><m:msubsup><m:mrow><m:mi mathvariant="italic">T</m:mi></m:mrow><m:mrow><m:mi mathvariant="italic">k</m:mi></m:mrow><m:mrow><m:mi mathvariant="italic">i</m:mi><m:mi mathvariant="italic">n</m:mi></m:mrow></m:msubsup><m:mo>=</m:mo><m:msubsup><m:mrow><m:mi mathvariant="italic">T</m:mi></m:mrow><m:mrow><m:mi mathvariant="italic">k</m:mi></m:mrow><m:mrow><m:mi mathvariant="italic">o</m:mi><m:mi mathvariant="italic">u</m:mi><m:mi mathvariant="italic">t</m:mi></m:mrow></m:msubsup><m:mo>=</m:mo><m:mfrac><m:mrow><m:mi mathvariant="normal">1</m:mi></m:mrow><m:mrow><m:mi mathvariant="normal">2</m:mi><m:mi mathvariant="normal">Δ</m:mi><m:mi mathvariant="italic">t</m:mi></m:mrow></m:mfrac><m:mi mathvariant="normal">(</m:mi><m:msub><m:mrow><m:mi mathvariant="italic">f</m:mi></m:mrow><m:mrow><m:mi mathvariant="italic">k</m:mi><m:mo>+</m:mo><m:mi mathvariant="normal">1</m:mi></m:mrow></m:msub><m:mo>−</m:mo><m:msub><m:mrow><m:mi mathvariant="italic">f</m:mi></m:mrow><m:mrow><m:mi mathvariant="italic">k</m:mi></m:mrow></m:msub><m:mi mathvariant="normal">)</m:mi><m:mo>+</m:mo><m:mfrac><m:mrow><m:mi mathvariant="normal">1</m:mi></m:mrow><m:mrow><m:mi mathvariant="normal">2</m:mi><m:mi mathvariant="normal">Δ</m:mi><m:mi mathvariant="italic">t</m:mi></m:mrow></m:mfrac><m:mi mathvariant="normal">(</m:mi><m:msub><m:mrow><m:mi mathvariant="italic">f</m:mi></m:mrow><m:mrow><m:mi mathvariant="italic">k</m:mi></m:mrow></m:msub><m:mo>−</m:mo><m:msub><m:mrow><m:mi mathvariant="italic">f</m:mi></m:mrow><m:mrow><m:mi mathvariant="italic">k</m:mi><m:mo>−</m:mo><m:mi mathvariant="normal">1</m:mi></m:mrow></m:msub><m:mi mathvariant="normal">)</m:mi><m:mn>.</m:mn></m:mrow></m:math>
</div>
<p>Modified tangents of a TCB spline are</p>
<div class="disp-formula">
<m:math display="block"><m:mrow><m:mtable><m:mtr><m:mtd><m:msubsup><m:mrow><m:mi mathvariant="italic">T</m:mi></m:mrow><m:mrow><m:mi mathvariant="italic">k</m:mi></m:mrow><m:mrow><m:mi mathvariant="italic">i</m:mi><m:mi mathvariant="italic">n</m:mi></m:mrow></m:msubsup><m:mo>=</m:mo><m:mfrac><m:mrow><m:mi mathvariant="normal">(</m:mi><m:mi mathvariant="normal">1</m:mi><m:mo>−</m:mo><m:mi mathvariant="italic">t</m:mi><m:mi mathvariant="normal">)</m:mi><m:mi mathvariant="normal">(</m:mi><m:mi mathvariant="normal">1</m:mi><m:mo>−</m:mo><m:mi mathvariant="italic">c</m:mi><m:mi mathvariant="normal">)</m:mi><m:mi mathvariant="normal">(</m:mi><m:mi mathvariant="normal">1</m:mi><m:mo>+</m:mo><m:mi mathvariant="italic">b</m:mi><m:mi mathvariant="normal">)</m:mi></m:mrow><m:mrow><m:mi mathvariant="normal">2</m:mi><m:mi mathvariant="normal">Δ</m:mi><m:mi mathvariant="italic">t</m:mi></m:mrow></m:mfrac><m:mi mathvariant="normal">(</m:mi><m:msub><m:mrow><m:mi mathvariant="italic">f</m:mi></m:mrow><m:mrow><m:mi mathvariant="italic">k</m:mi><m:mo>+</m:mo><m:mi mathvariant="normal">1</m:mi></m:mrow></m:msub><m:mo>−</m:mo><m:msub><m:mrow><m:mi mathvariant="italic">f</m:mi></m:mrow><m:mrow><m:mi mathvariant="italic">k</m:mi></m:mrow></m:msub><m:mi mathvariant="normal">)</m:mi><m:mo>+</m:mo><m:mfrac><m:mrow><m:mi mathvariant="normal">(</m:mi><m:mi mathvariant="normal">1</m:mi><m:mo>−</m:mo><m:mi mathvariant="italic">t</m:mi><m:mi mathvariant="normal">)</m:mi><m:mi mathvariant="normal">(</m:mi><m:mi mathvariant="normal">1</m:mi><m:mo>+</m:mo><m:mi mathvariant="italic">c</m:mi><m:mi mathvariant="normal">)</m:mi><m:mi mathvariant="normal">(</m:mi><m:mi mathvariant="normal">1</m:mi><m:mo>−</m:mo><m:mi mathvariant="italic">b</m:mi><m:mi mathvariant="normal">)</m:mi></m:mrow><m:mrow><m:mi mathvariant="normal">2</m:mi><m:mi mathvariant="normal">Δ</m:mi><m:mi mathvariant="italic">t</m:mi></m:mrow></m:mfrac><m:mi mathvariant="normal">(</m:mi><m:msub><m:mrow><m:mi mathvariant="italic">f</m:mi></m:mrow><m:mrow><m:mi mathvariant="italic">k</m:mi></m:mrow></m:msub><m:mo>−</m:mo><m:msub><m:mrow><m:mi mathvariant="italic">f</m:mi></m:mrow><m:mrow><m:mi mathvariant="italic">k</m:mi><m:mo>−</m:mo><m:mi mathvariant="normal">1</m:mi></m:mrow></m:msub><m:mi mathvariant="normal">)</m:mi><m:mo>,</m:mo></m:mtd></m:mtr><m:mtr><m:mtd><m:msubsup><m:mrow><m:mi mathvariant="italic">T</m:mi></m:mrow><m:mrow><m:mi mathvariant="italic">k</m:mi></m:mrow><m:mrow><m:mi mathvariant="italic">o</m:mi><m:mi mathvariant="italic">u</m:mi><m:mi mathvariant="italic">t</m:mi></m:mrow></m:msubsup><m:mo>=</m:mo><m:mfrac><m:mrow><m:mi mathvariant="normal">(</m:mi><m:mi mathvariant="normal">1</m:mi><m:mo>−</m:mo><m:mi mathvariant="italic">t</m:mi><m:mi mathvariant="normal">)</m:mi><m:mi mathvariant="normal">(</m:mi><m:mi mathvariant="normal">1</m:mi><m:mo>+</m:mo><m:mi mathvariant="italic">c</m:mi><m:mi mathvariant="normal">)</m:mi><m:mi mathvariant="normal">(</m:mi><m:mi mathvariant="normal">1</m:mi><m:mo>+</m:mo><m:mi mathvariant="italic">b</m:mi><m:mi mathvariant="normal">)</m:mi></m:mrow><m:mrow><m:mi mathvariant="normal">2</m:mi><m:mi mathvariant="normal">Δ</m:mi><m:mi mathvariant="italic">t</m:mi></m:mrow></m:mfrac><m:mi mathvariant="normal">(</m:mi><m:msub><m:mrow><m:mi mathvariant="italic">f</m:mi></m:mrow><m:mrow><m:mi mathvariant="italic">k</m:mi><m:mo>+</m:mo><m:mi mathvariant="normal">1</m:mi></m:mrow></m:msub><m:mo>−</m:mo><m:msub><m:mrow><m:mi mathvariant="italic">f</m:mi></m:mrow><m:mrow><m:mi mathvariant="italic">k</m:mi></m:mrow></m:msub><m:mi mathvariant="normal">)</m:mi><m:mo>+</m:mo><m:mfrac><m:mrow><m:mi mathvariant="normal">(</m:mi><m:mi mathvariant="normal">1</m:mi><m:mo>−</m:mo><m:mi mathvariant="italic">t</m:mi><m:mi mathvariant="normal">)</m:mi><m:mi mathvariant="normal">(</m:mi><m:mi mathvariant="normal">1</m:mi><m:mo>−</m:mo><m:mi mathvariant="italic">c</m:mi><m:mi mathvariant="normal">)</m:mi><m:mi mathvariant="normal">(</m:mi><m:mi mathvariant="normal">1</m:mi><m:mo>−</m:mo><m:mi mathvariant="italic">b</m:mi><m:mi mathvariant="normal">)</m:mi></m:mrow><m:mrow><m:mi mathvariant="normal">2</m:mi><m:mi mathvariant="normal">Δ</m:mi><m:mi mathvariant="italic">t</m:mi></m:mrow></m:mfrac><m:mi mathvariant="normal">(</m:mi><m:msub><m:mrow><m:mi mathvariant="italic">f</m:mi></m:mrow><m:mrow><m:mi mathvariant="italic">k</m:mi></m:mrow></m:msub><m:mo>−</m:mo><m:msub><m:mrow><m:mi mathvariant="italic">f</m:mi></m:mrow><m:mrow><m:mi mathvariant="italic">k</m:mi><m:mo>−</m:mo><m:mi mathvariant="normal">1</m:mi></m:mrow></m:msub><m:mi mathvariant="normal">)</m:mi><m:mn>.</m:mn></m:mtd></m:mtr></m:mtable></m:mrow></m:math>
</div>
<p>The tension parameter <em>t</em> controls the sharpness of the curve near the key by scaling both incoming and outgoing tangents. Larger tangents (lower tension) lead to a flatter curve shape near the key. Bias <em>b</em> allows the animator to selectively increase the weight of a key’s neighbors locally pulling the curve closer to a straight line connecting the key with its left (<em>b</em> near 1, “overshooting” the action) or right (<em>b</em>near −1, “undershooting” the action) neighbors. A nonzero value of continuity <em>c</em>makes incoming and outgoing tangents different allowing the animator to create kinks in the curve at the key value. Practically useful values of TCB parameters are typically confinedtothe interval [−1; 1] with defaults <em>t</em> = <em>c</em> = <em>b</em> = 0 corresponding to the original Catmull-Rom spline. Examples of possible curve shape adjustments are shown in <a href="C21_chapter16.xhtml#f16_6">Figure 16.6</a>.</p>
<figure id="f16_6" tabindex="0">
<img alt="" src="../images/fig16_6.jpg"/>
<figcaption><p><span class="blue">Figure 16.6.</span> <a id="term-486"/><a id="term-544"/><span aria-label="437" epub:type="pagebreak" id="pg_437" role="doc-pagebreak"/>Editing the default interpolating spline (middle column) using TCB controls. Note that all keys remain at the same positions.</p></figcaption>
</figure>
<section>
<h3 id="sec16_2_1"><a id="index_term763"/><span class="green">16.2.1 Motion Controls</span></h3>
<p>So far, we have described how to control the shape of the animation curve through key positioning and fine tweaking of tangent values at the keys. This, however, is generally not sufficient when one would like to have control both over where the object is moving, i.e., its path, and how fast it moves along this path. Given a set of positions in space as keys, automatic curve-fitting techniques can fitacurve through them, but resulting motion is only constrained by forcing the object to arrive at a specified key position <strong>p<sub>k</sub></strong> at the corresponding key frame <em>t<sub>k</sub></em>, and nothing is directly said about the speed of motion between the keys. This can create problems. For example, if an object moves along the <em>x</em>-axis with velocity 11 meters per second for 1 second and then with 1 meter per second for 9 seconds, it will arrive at position <em>x</em> = 20 after 10 seconds thus satisfying animator’s keys (0,0) and (10, 20). It is rather unlikely that this jerky motion was actually desired, and uniform motion with speed 2 meters/second is probably closer to what the animator wanted when setting these keys. Although typically not displaying <a id="term-170"/><a id="term-487"/><span aria-label="438" epub:type="pagebreak" id="pg_438" role="doc-pagebreak"/>such extreme behavior, polynomial curves resulting from standard fitting procedures do exhibit nonuniform speed of motion between keys as demonstrated in <a href="C21_chapter16.xhtml#f16_7">Figure 16.7</a>. While this can be tolerable (within limits) for some parameters for which the human visual system is not very good at determining nonuniformities in the rate of change (such as color or even rate of rotation), we have to do better for position <strong>p</strong> of the object where velocity directly corresponds to everyday experience.</p>
<figure id="f16_7" tabindex="0">
<img alt="" src="../images/fig16_7.jpg"/>
<figcaption><p><span class="blue">Figure 16.7.</span> All three motions are along the same 2D path and satisfy the set of keys at the tips of the black triangles. The tips of the white triangles show object position at Δ<em>t</em> = 1 intervals. Uniform speed of motion between the keys (top) might be closer to what the animator wanted, but automatic fitting procedures could result in either of the other two motions.</p></figcaption>
</figure>
<p>We will first distinguish curve parameterization used during the fitting procedure from that used for animation. When a curve is fit through position keys, we will write the result as a function <strong>p</strong>(<em>u</em>) of some parameter <em>u</em>. This will describe the geometry of the curve in space. The arc length <em>s</em> is the physical length of the curve. A natural way for the animator to control the motion along the now-existing curve is to specify an extra function <em>s</em>(<em>t</em>) which corresponds to how far along the curve the object should be at any given time. To get an actual position in space, we need one more auxiliary function <em>u</em>(<em>s</em>) which computes a parameter value <em>u</em> for given arc length <em>s</em>. The complete process of computing an object position for a given time <em>t</em> is then given by composing these functions (see <a href="C21_chapter16.xhtml#f16_8">Figure 16.8</a>):</p>
<div class="disp-formula">
<m:math display="block"><m:mrow><m:mi mathvariant="bold">p</m:mi><m:mi mathvariant="normal">(</m:mi><m:mi mathvariant="italic">t</m:mi><m:mi mathvariant="normal">)</m:mi><m:mo>=</m:mo><m:mi mathvariant="bold">p</m:mi><m:mi mathvariant="normal">(</m:mi><m:mi mathvariant="italic">u</m:mi><m:mi mathvariant="normal">(</m:mi><m:mi mathvariant="italic">s</m:mi><m:mi mathvariant="normal">(</m:mi><m:mi mathvariant="italic">t</m:mi><m:mi mathvariant="normal">)</m:mi><m:mi mathvariant="normal">)</m:mi><m:mi mathvariant="normal">)</m:mi><m:mn>.</m:mn></m:mrow></m:math>
</div>
<figure id="f16_8" tabindex="0">
<img alt="" src="../images/fig16_8.jpg"/>
<figcaption><p><span class="blue">Figure 16.8.</span> To get position in space at a given time <em>t</em>, one first utilizes user-specified motion control to obtain the distance along the curve <em>s</em>(<em>t</em>) and then computes the corresponding curve parameter value <em>u</em>(<em>s</em>(<em>t</em>)). Previously fitted curve <strong>P</strong>(<em>u</em>) can now be used to find the position <strong>P</strong>(<em>u</em>(<em>s</em>(<em>t</em>))).</p></figcaption>
</figure>
<p>Several standard functions can be used as the distance-time function <em>s</em>(<em>t</em>). One of the simplest is the linear function corresponding to constant velocity: <em>s</em>(<em>t</em>) = <em>vt</em> with <em>v</em> = const. Another common example is the motion with constant acceleration <em>a</em> (and initial speed <em>v</em><sub>0</sub>) which is described by the parabolic <em>s</em>(<em>t</em>) = <em>v</em><sub>0</sub><em>t</em> + <em>at</em><sup>2</sup>/2. Since velocity is changing gradually here, this function can help to model desirable ease-in and ease-out behavior. More generally, the slope of <em>s</em>(<em>t</em>) gives the velocity of motion with negative slope corresponding to the motion backwards along the curve. To achieve most flexibility, the ability to <span aria-label="439" epub:type="pagebreak" id="pg_439" role="doc-pagebreak"/>interactively edit <em>s</em>(<em>t</em>) is typically provided to the animator by the animation system. The distance-time function is not the only way to control motion. In some cases it might be more convenient for the user to specify a velocity-time function <em>v</em>(<em>t</em>) or even an acceleration-time function <em>a</em>(<em>t</em>). Since these are correspondingly first and second derivatives of <em>s</em>(<em>t</em>), to use these type of controls, the system first recovers the distance-time function by integrating the user input (twice in the case of <em>a</em>(<em>t</em>)).</p>
<p>The relationship between the curve parameter <em>u</em> and arc length <em>s</em> is established automatically by the system. In practice, the system first determines arc length dependance on parameter <em>u</em> (i.e., the inverse function <em>s</em>(<em>u</em>)). Using this function, for any given <em>S</em> it is possible to solve the equation <em>s</em>(<em>u</em>) − <em>S</em> = 0 with unknown <em>u</em>obtaining <em>u</em>(<em>S</em>). For most curves, the function <em>s</em>(<em>u</em>) cannot be expressed in closed analytic form and numerical integration is necessary (see <a href="C19_chapter14.xhtml#c14">Chapter 14</a>). Standard numerical root-finding procedures (such as the Newton-Raphson method, for example) can then be directly used to solve the equation <em>s</em>(<em>u</em>) − <em>S</em> = 0 for <em>u</em>.</p>
<p>An alternative technique is to approximate the curve itself as a set of linear segments between points <strong>p</strong><em><sub>i</sub></em> computed at some set of sufficiently densely spaced parameter values <em>u<sub>i</sub></em>. One then creates a table of approximate arc lengths</p>
<div class="disp-formula">
<m:math display="block"><m:mrow><m:mi mathvariant="italic">s</m:mi><m:mi mathvariant="normal">(</m:mi><m:msub><m:mrow><m:mi mathvariant="italic">u</m:mi></m:mrow><m:mrow><m:mi mathvariant="italic">i</m:mi></m:mrow></m:msub><m:mi mathvariant="normal">)</m:mi><m:mo>≈</m:mo><m:munderover><m:mrow><m:mstyle displaystyle="true" mathvariant="normal"><m:mo>∑</m:mo></m:mstyle></m:mrow><m:mrow><m:mi mathvariant="italic">j</m:mi><m:mo>=</m:mo><m:mi mathvariant="normal">1</m:mi></m:mrow><m:mrow><m:mi mathvariant="italic">i</m:mi></m:mrow></m:munderover><m:mi mathvariant="normal">|</m:mi><m:mi mathvariant="normal">|</m:mi><m:msub><m:mrow><m:mi mathvariant="bold">p</m:mi></m:mrow><m:mrow><m:mi mathvariant="normal">j</m:mi></m:mrow></m:msub><m:mo>−</m:mo><m:msub><m:mrow><m:mi mathvariant="bold">p</m:mi></m:mrow><m:mrow><m:mi mathvariant="normal">j</m:mi><m:mo>−</m:mo><m:mi mathvariant="normal">1</m:mi></m:mrow></m:msub><m:mi mathvariant="normal">|</m:mi><m:mi mathvariant="normal">|</m:mi><m:mo>=</m:mo><m:mi mathvariant="italic">s</m:mi><m:mi mathvariant="normal">(</m:mi><m:msub><m:mrow><m:mi mathvariant="italic">u</m:mi></m:mrow><m:mrow><m:mi mathvariant="italic">i</m:mi><m:mo>−</m:mo><m:mi mathvariant="normal">1</m:mi></m:mrow></m:msub><m:mi mathvariant="normal">)</m:mi><m:mo>+</m:mo><m:mi mathvariant="normal">|</m:mi><m:mi mathvariant="normal">|</m:mi><m:msub><m:mrow><m:mi mathvariant="bold">p</m:mi></m:mrow><m:mrow><m:mi mathvariant="bold">i</m:mi></m:mrow></m:msub><m:mo>−</m:mo><m:msub><m:mrow><m:mi mathvariant="bold">p</m:mi></m:mrow><m:mrow><m:mi mathvariant="bold">i</m:mi><m:mo mathvariant="bold">−</m:mo><m:mi mathvariant="bold">1</m:mi></m:mrow></m:msub><m:mi mathvariant="normal">|</m:mi><m:mi mathvariant="normal">|</m:mi><m:mi mathvariant="normal">.</m:mi></m:mrow></m:math>
</div>
<p>Since <em>s</em>(<em>u</em>) is a non-decreasing function of <em>u</em>, one can then find the interval containing the value <em>S</em> by simple searching through the table (see <a href="C21_chapter16.xhtml#f16_9">Figure 16.9</a>). Linear interpolation of the interval’s <em>u</em> end values is then performed to finally find u(S). If greater precision is necessary, a few steps of the Newton-Raphson algorithm with this value as the starting point can be applied.</p>
<figure id="f16_9" tabindex="0">
<img alt="" src="../images/fig16_9.jpg"/>
<figcaption><p><span class="blue">Figure 16.9.</span> To create a tabular version of <em>s</em>(<em>u</em>), the curve can be approximated by a number of line segments connecting points on the curve positioned at equal parameter increments. The table is searched to find the <em>u</em>-interval for a given <em>S</em>. For the curve above, for example, the value of <em>u</em> corresponding to the position of <em>S</em> = 6.5 lies between <em>u</em> = 0.6 and <em>u</em> = 0.8.</p></figcaption>
</figure>
</section>
<section>
<h3 id="sec16_2_2"><a id="index_term211"/><span class="green">16.2.2 Interpolating Rotation</span></h3>
<p>The techniques presented above can be used to interpolate the keys set for most of the parameters describing the scene. Three-dimensional rotation is one important motion for which more specialized interpolation methods and representations are common. The reason for this is that applying standard techniques to 3D rotations often leads to serious practical problems. Rotation (a change in orientation of an object) is the only motion other than translation which leaves the shape of the object intact. It therefore plays a special role in animating rigid objects.</p>
<p>There are several ways to specify the orientation of an object. First, transformation matrices as described in <a href="C11_chapter6.xhtml#c6">Chapter 6</a> can be used. Unfortunately, naive <a id="term-168"/><a id="term-341"/><a id="term-488"/><span aria-label="440" epub:type="pagebreak" id="pg_440" role="doc-pagebreak"/>(element-by-element) interpolation of rotation matrices does not produce a correct result. For example, the matrix “halfway” between 2D clock- and counterclockwise 90 degree rotation is the null matrix:</p>
<div class="disp-formula">
<m:math display="block"><m:mrow><m:mfrac><m:mrow><m:mi mathvariant="normal">1</m:mi></m:mrow><m:mrow><m:mi mathvariant="normal">2</m:mi></m:mrow></m:mfrac><m:mo>[</m:mo><m:mtable><m:mtr><m:mtd><m:mi mathvariant="normal">0</m:mi></m:mtd><m:mtd><m:mi mathvariant="normal">1</m:mi></m:mtd></m:mtr><m:mtr><m:mtd><m:mo>−</m:mo><m:mi mathvariant="normal">1</m:mi></m:mtd><m:mtd><m:mi mathvariant="normal">0</m:mi></m:mtd></m:mtr></m:mtable><m:mo>]</m:mo><m:mo>+</m:mo><m:mfrac><m:mrow><m:mi mathvariant="normal">1</m:mi></m:mrow><m:mrow><m:mi mathvariant="normal">2</m:mi></m:mrow></m:mfrac><m:mrow><m:mo>[</m:mo><m:mtable><m:mtr><m:mtd><m:mi mathvariant="normal">0</m:mi></m:mtd><m:mtd><m:mo>−</m:mo><m:mi mathvariant="normal">1</m:mi></m:mtd></m:mtr><m:mtr><m:mtd><m:mi mathvariant="normal">1</m:mi></m:mtd><m:mtd><m:mi mathvariant="normal">0</m:mi></m:mtd></m:mtr></m:mtable><m:mo>]</m:mo></m:mrow><m:mo>=</m:mo><m:mrow><m:mo>[</m:mo><m:mtable><m:mtr><m:mtd><m:mi mathvariant="normal">0</m:mi></m:mtd><m:mtd><m:mi mathvariant="normal">0</m:mi></m:mtd></m:mtr><m:mtr><m:mtd><m:mi mathvariant="normal">0</m:mi></m:mtd><m:mtd><m:mi mathvariant="normal">0</m:mi></m:mtd></m:mtr></m:mtable><m:mo>]</m:mo></m:mrow><m:mn>.</m:mn></m:mrow></m:math>
</div>
<p>The correct result is, of course, the unit matrix corresponding to no rotation. Second, one can specify arbitrary orientation as a sequence of exactly three rotations around coordinate axes chosen in some specific order. These axes can be fixed in space (<em>fixed-angle</em> representation) or embedded into the object therefore changing after each rotation (<em>Euler-angle</em> representation as shown in <a href="C21_chapter16.xhtml#f16_10">Figure 16.10</a>). These three angles of rotation can be animated directly through standard keyframing, but a subtle problem known as gimbal lock arises. Gimbal lock occurs if during rotation one of the three rotation axes is by accident aligned with another, thereby reducing by one the number of available degrees of freedom as shown in <a href="C21_chapter16.xhtml#f16_11">Figure 16.11</a> for a physical device. This effect is more common than one might think–a single 90 degree turn to the right (or left) can potentially put an object into a gimbal lock. Finally, any orientation can be specified by choosing an appropriate axis in space and angle of rotation around this axis. While animating in this representation is relatively straightforward, combining two rotations, i.e., finding the axis and angle corresponding to a sequence of two rotations both represented by axis and angle, is nontrivial. A special mathematical apparatus, <em><a id="index_term921"/>quaternions</em>has been developed to make this representation suitable both for combining several rotations into a single one and for animation.</p>
<figure id="f16_10" tabindex="0">
<img alt="" src="../images/fig16_10.jpg"/>
<figcaption><p><span class="blue">Figure 16.10.</span> Three Euler angles can be used to specify arbitrary object orientation through a sequence of three rotations around coordinate axes embedded into the object (axis Y always points to the tip of the cone). Note that each rotation is given in a new coordinate system. Fixed angle representation is very similar, but the coordinate axes it uses are fixed in space and do not rotate with the object.</p></figcaption>
</figure>
<figure id="f16_11" tabindex="0">
<img alt="" src="../images/fig16_11.jpg"/>
<figcaption><p><span class="blue">Figure 16.11.</span> In this example, <a id="index_term439"/>gimbal lock occurs when a 90 degree turn around axis Z is made. Both X and Y rotations are now performed around the same axis leading to the loss of one degree of freedom.</p></figcaption>
</figure>
<p>Given a 3D vector <strong>v</strong> = (<em>x, y, z</em>) and a scalar <em>s</em>, a quaternion <em>q</em> is formed by combining the two into a four-component object: <em>q</em> = [<em>s x y z</em>] = [<em>s</em>; <strong>v</strong>]. Several <a id="term-658"/><span aria-label="441" epub:type="pagebreak" id="pg_441" role="doc-pagebreak"/>new operations are then defined for quaternions. Quaternion addition simply sums scalar and vector parts separately:</p>
<div class="disp-formula">
<m:math display="block"><m:mrow><m:msub><m:mrow><m:mi mathvariant="italic">q</m:mi></m:mrow><m:mrow><m:mi mathvariant="normal">1</m:mi></m:mrow></m:msub><m:mo>+</m:mo><m:msub><m:mrow><m:mi mathvariant="italic">q</m:mi></m:mrow><m:mrow><m:mi mathvariant="normal">2</m:mi></m:mrow></m:msub><m:mo>≡</m:mo><m:mi mathvariant="normal">[</m:mi><m:msub><m:mrow><m:mi mathvariant="italic">s</m:mi></m:mrow><m:mrow><m:mi mathvariant="normal">1</m:mi></m:mrow></m:msub><m:mo>+</m:mo><m:msub><m:mrow><m:mi mathvariant="italic">s</m:mi></m:mrow><m:mrow><m:mi mathvariant="normal">2</m:mi></m:mrow></m:msub><m:mo>;</m:mo><m:msub><m:mrow><m:mi mathvariant="bold">v</m:mi></m:mrow><m:mrow><m:mi mathvariant="bold">1</m:mi></m:mrow></m:msub><m:mo>+</m:mo><m:msub><m:mrow><m:mi mathvariant="bold">v</m:mi></m:mrow><m:mrow><m:mi mathvariant="bold">2</m:mi></m:mrow></m:msub><m:mi mathvariant="normal">]</m:mi><m:mi mathvariant="normal">.</m:mi></m:mrow></m:math>
</div>
<p>Multiplication by a scalar <em>a</em> gives a new quaternion</p>
<div class="disp-formula">
<m:math display="block"><m:mrow><m:mi>a</m:mi><m:mi>q</m:mi><m:mo>≡</m:mo><m:mrow><m:mo>[</m:mo><m:mi>a</m:mi><m:mi>s</m:mi><m:mo>;</m:mo><m:mi>a</m:mi><m:mi mathvariant="bold">v</m:mi><m:mo>]</m:mo></m:mrow><m:mn>.</m:mn></m:mrow></m:math>
</div>
<p>More complex quaternion multiplication is defined as</p>
<div class="disp-formula">
<m:math display="block"><m:mrow><m:msub><m:mrow><m:mi mathvariant="italic">q</m:mi></m:mrow><m:mrow><m:mn>1</m:mn></m:mrow></m:msub><m:mo>⋅</m:mo><m:msub><m:mrow><m:mi mathvariant="italic">q</m:mi></m:mrow><m:mrow><m:mi mathvariant="normal">2</m:mi></m:mrow></m:msub><m:mo>≡</m:mo><m:mi mathvariant="normal">[</m:mi><m:msub><m:mrow><m:mi mathvariant="italic">s</m:mi></m:mrow><m:mrow><m:mi mathvariant="normal">1</m:mi></m:mrow></m:msub><m:msub><m:mrow><m:mi mathvariant="italic">s</m:mi></m:mrow><m:mrow><m:mi mathvariant="normal">2</m:mi></m:mrow></m:msub><m:mo>−</m:mo><m:msub><m:mrow><m:mi mathvariant="bold">v</m:mi></m:mrow><m:mrow><m:mi mathvariant="bold">1</m:mi></m:mrow></m:msub><m:msub><m:mrow><m:mi mathvariant="bold">v</m:mi></m:mrow><m:mrow><m:mi mathvariant="bold">2</m:mi></m:mrow></m:msub><m:mo>;</m:mo><m:msub><m:mrow><m:mi mathvariant="italic">s</m:mi></m:mrow><m:mrow><m:mi mathvariant="normal">1</m:mi></m:mrow></m:msub><m:msub><m:mrow><m:mi mathvariant="bold">v</m:mi></m:mrow><m:mrow><m:mi mathvariant="bold">2</m:mi></m:mrow></m:msub><m:mo>+</m:mo><m:msub><m:mrow><m:mi mathvariant="italic">s</m:mi></m:mrow><m:mrow><m:mi mathvariant="normal">2</m:mi></m:mrow></m:msub><m:msub><m:mrow><m:mi mathvariant="bold">v</m:mi></m:mrow><m:mrow><m:mi mathvariant="bold">1</m:mi></m:mrow></m:msub><m:mo>+</m:mo><m:msub><m:mrow><m:mi mathvariant="bold">v</m:mi></m:mrow><m:mrow><m:mi mathvariant="bold">1</m:mi></m:mrow></m:msub><m:mo>×</m:mo><m:msub><m:mrow><m:mi mathvariant="bold">v</m:mi></m:mrow><m:mrow><m:mi mathvariant="bold">2</m:mi></m:mrow></m:msub><m:mi mathvariant="normal">]</m:mi><m:mo>,</m:mo></m:mrow></m:math>
</div>
<p>where × denotes a vector cross product. It is easy to see that, similar to matrices, quaternion multiplication is associative, but not commutative. We will be interested mostly in normalized quaternions–those for which the quaternion norm <span class="inline-formula"><m:math display="inline"><m:mrow><m:mrow><m:mo>|</m:mo><m:mi>q</m:mi><m:mo>|</m:mo></m:mrow><m:mo>=</m:mo><m:msqrt><m:mrow><m:msup><m:mrow><m:mi>s</m:mi></m:mrow><m:mrow><m:mn>2</m:mn></m:mrow></m:msup><m:mo>+</m:mo><m:msup><m:mrow><m:mi mathvariant="bold">v</m:mi></m:mrow><m:mrow><m:mn>2</m:mn></m:mrow></m:msup></m:mrow></m:msqrt></m:mrow></m:math></span> is equal to one. One final definition we need is that of an inverse quaternion:</p>
<div class="disp-formula">
<m:math display="block"><m:mrow><m:msup><m:mrow><m:mi mathvariant="italic">q</m:mi></m:mrow><m:mrow><m:mo>−</m:mo><m:mi mathvariant="normal">1</m:mi></m:mrow></m:msup><m:mo>=</m:mo><m:mi mathvariant="normal">(</m:mi><m:mi mathvariant="normal">1</m:mi><m:mi mathvariant="normal">/</m:mi><m:mi mathvariant="normal">|</m:mi><m:mi mathvariant="italic">q</m:mi><m:mi mathvariant="normal">|</m:mi><m:mi mathvariant="normal">)</m:mi><m:mi mathvariant="normal">[</m:mi><m:mi mathvariant="italic">s</m:mi><m:mi mathvariant="normal">;</m:mi><m:mo>−</m:mo><m:mi mathvariant="bold">v</m:mi><m:mi mathvariant="normal">]</m:mi><m:mi mathvariant="normal">.</m:mi></m:mrow></m:math>
</div>
<p class="indent">To represent a rotation by angle <em>ϕ</em> around an axis passing through the origin whose direction is given by the normalized vector <strong>n</strong>, a normalized quaternion</p>
<div class="disp-formula">
<m:math display="block"><m:mrow><m:mi mathvariant="italic">q</m:mi><m:mo>=</m:mo><m:mi mathvariant="normal">[</m:mi><m:mi mathvariant="normal">cos</m:mi><m:mi mathvariant="normal">(</m:mi><m:mi>φ</m:mi><m:mi mathvariant="normal">/</m:mi><m:mi mathvariant="normal">2</m:mi><m:mi mathvariant="normal">)</m:mi><m:mi mathvariant="normal">;</m:mi><m:mi mathvariant="normal">sin</m:mi><m:mi mathvariant="normal">(</m:mi><m:mi>φ</m:mi><m:mi mathvariant="normal">/</m:mi><m:mi mathvariant="normal">2</m:mi><m:mi mathvariant="normal">)</m:mi><m:mi mathvariant="bold">n</m:mi><m:mi mathvariant="normal">]</m:mi></m:mrow></m:math>
</div>
<p>is formed. To rotate point <strong>p</strong>, one turns it into the quaternion <em>q<sub>p</sub></em> = [0; <strong>p</strong>] and computes the quaternion product</p>
<div class="disp-formula">
<m:math display="block"><m:mrow><m:msub><m:mrow><m:mi mathvariant="italic">q</m:mi></m:mrow><m:mrow><m:mi mathvariant="italic">p</m:mi></m:mrow></m:msub><m:mi>′</m:mi><m:mo>=</m:mo><m:mi mathvariant="italic">q</m:mi><m:mo>⋅</m:mo><m:msub><m:mrow><m:mi>q</m:mi></m:mrow><m:mrow><m:mi>p</m:mi></m:mrow></m:msub><m:mo>⋅</m:mo><m:msup><m:mrow><m:mi>q</m:mi></m:mrow><m:mrow><m:mo>−</m:mo><m:mn>1</m:mn></m:mrow></m:msup></m:mrow></m:math>
</div>
<p>which is guaranteed to have a zero scalar part and the rotated point as its vector part. Composite rotation is given simply by the product of quaternions representing each of the separate rotation steps. To animate with quaternions, one can treat them as points in a four-dimensional space and set keys directly in this space. To keep quaternions normalized, one should, strictly speaking, restrict interpolation procedures to a unit sphere (a 3D object) in this 4D space. However, a spherical version of even linear interpolation (often called <em><a id="index_term1094"/>slerp</em>) already results in rather unpleasant math. Simple 4D linear interpolation followed by projection onto the unit sphere shown in <a href="C21_chapter16.xhtml#f16_12">Figure 16.12</a> is much simpler and often sufficient in practice. Smoother results can be obtained via repeated application of a linear interpolation procedure using the de Casteljau algorithm.</p>
<figure id="f16_12" tabindex="0">
<img alt="" src="../images/fig16_12.jpg"/>
<figcaption><p><span class="blue">Figure 16.12.</span> Interpolating quaternions should be done on the surface of a 3D unit sphere embedded in 4D space. However, much simpler interpolation along a 4D straight line (open circles) followed by re-projection of the results onto the sphere (black circles) is often sufficient.</p></figcaption>
</figure>
</section>
</section>
<section>
<h2 id="sec16_3"><a id="index_term314"/><a id="term-259"/><span aria-label="442" epub:type="pagebreak" id="pg_442" role="doc-pagebreak"/><a epub:type="backlink" href="C02a_toc.xhtml#rsec16_3" role="doc-backlink"><span class="green">16.3 Deformations</span></a></h2>
<p>Taper Twist Although techniques for object deformation might be more properly treated as modeling tools, they are traditionally discussed together with animation methods. Probably the simplest example of an operation which changes object shape is a nonuniform scaling. More generally, some function can be applied to local coordinates of all points specifying the object (i.e., vertices of a triangular mesh or control polygon of a spline surface), repositioning these points and creating a new shape: <strong>p</strong><sup>'</sup> = <em>f</em> (<strong>p</strong>, γ) where γ is a vector of parameters used by the deformation function. Choosing different <em>f</em> (and combining them by applying one after another) can help to create very interesting deformations. Examples of useful simple functions include bend, twist, and taper which are shown in <a href="C21_chapter16.xhtml#f16_13">Figure 16.13</a>. Animating shape change is very easy in this case by keyframing the parameters of the deformation function. Disadvantages of this technique include difficulty of choosing the mathematical function for some nonstandard deformations and the fact that the resulting deformation is <em>global</em> in the sense that the complete object, and not just some part of it, is reshaped.</p>
<figure id="f16_13" tabindex="0">
<img alt="" src="../images/fig16_13.jpg"/>
<figcaption><p><span class="blue">Figure 16.13.</span> Popular examples of global deformations. Bending and twist angles, as well as the degree of taper, can all be animated to achieve dynamic shape change.</p></figcaption>
</figure>
<p>To deform an object locally while providing more direct control over the result, one can choose a single vertex, move it to a new location and adjust vertices within some neighborhood to follow the seed vertex. The area affected by the deformation and the specific amount of displacement in different parts of the object are controlled by an attenuation function which decreases with distance (typically computed over the object’s surface) to the seed vertex. Seed vertex motion can be keyframed to produce animated shape change.</p>
<p>A more general deformation technique is called free-form deformation (FFD) (Sederberg &amp; Parry, 1986). A local (in most cases rectilinear) coordinate grid is first established to encapsulate the part of the object to be deformed, and coordinates (<em>s, t, u</em>) of all relevant points are computed with respect to this grid. The user then freely reshapes the grid of <a id="index_term662"/>lattice points <strong>P<sub>ijk</sub></strong> into a new distorted lattice <span class="inline-formula"><m:math display="inline"><m:mrow><m:msubsup><m:mrow><m:mtext mathvariant="bold">P</m:mtext></m:mrow><m:mrow><m:mtext mathvariant="bold">ijk</m:mtext></m:mrow><m:mrow><m:mo>′</m:mo></m:mrow></m:msubsup></m:mrow></m:math></span> (<a href="C21_chapter16.xhtml#f16_14">Figure 16.14</a>). The object is reconstructed using coordinates computed in the original undistorted grid in the trivariate analog of Bézier interpolants (see <a href="C20_chapter15.xhtml#c15">Chapter 15</a>) with distorted lattice points <span class="inline-formula"><m:math display="inline"><m:mrow><m:msubsup><m:mrow><m:mtext mathvariant="bold">P</m:mtext></m:mrow><m:mrow><m:mtext mathvariant="bold">ijk</m:mtext></m:mrow><m:mrow><m:mo>′</m:mo></m:mrow></m:msubsup></m:mrow></m:math></span> serving as control points in this expression:</p>
<div class="disp-formula">
<m:math display="block"><m:mrow><m:mi mathvariant="italic">P</m:mi><m:mi mathvariant="normal">(</m:mi><m:mi mathvariant="italic">s</m:mi><m:mo>,</m:mo><m:mi mathvariant="normal"/><m:mi mathvariant="italic">u</m:mi><m:mo>,</m:mo><m:mi mathvariant="normal"/><m:mi mathvariant="italic">t</m:mi><m:mi mathvariant="normal">)</m:mi><m:mo>=</m:mo><m:munderover><m:mrow><m:mstyle displaystyle="true" mathvariant="normal"><m:mrow><m:mo>∑</m:mo></m:mrow></m:mstyle></m:mrow><m:mrow><m:mi mathvariant="italic">i</m:mi><m:mo>=</m:mo><m:mi mathvariant="normal">0</m:mi></m:mrow><m:mrow><m:mi mathvariant="italic">L</m:mi></m:mrow></m:munderover><m:mo>(</m:mo><m:mtable><m:mtr><m:mtd><m:mi mathvariant="italic">i</m:mi></m:mtd></m:mtr><m:mtr><m:mtd><m:mi mathvariant="italic">L</m:mi></m:mtd></m:mtr></m:mtable><m:mo>)</m:mo><m:mi mathvariant="normal">(</m:mi><m:mi mathvariant="normal">1</m:mi><m:mo>−</m:mo><m:mi mathvariant="italic">s</m:mi><m:msup><m:mrow><m:mi mathvariant="normal">)</m:mi></m:mrow><m:mrow><m:mi mathvariant="italic">L</m:mi><m:mo>−</m:mo><m:mi mathvariant="italic">i</m:mi></m:mrow></m:msup><m:msup><m:mrow><m:mi mathvariant="italic">s</m:mi></m:mrow><m:mrow><m:mi mathvariant="italic">i</m:mi></m:mrow></m:msup><m:munderover><m:mrow><m:mstyle displaystyle="true" mathvariant="normal"><m:mrow><m:mo>∑</m:mo></m:mrow></m:mstyle></m:mrow><m:mrow><m:mi mathvariant="italic">j</m:mi><m:mo>=</m:mo><m:mi mathvariant="normal">0</m:mi></m:mrow><m:mrow><m:mi mathvariant="italic">M</m:mi></m:mrow></m:munderover><m:mo>(</m:mo><m:mtable><m:mtr><m:mtd><m:mi mathvariant="italic">j</m:mi></m:mtd></m:mtr><m:mtr><m:mtd><m:mi mathvariant="italic">M</m:mi></m:mtd></m:mtr></m:mtable><m:mo>)</m:mo><m:mi mathvariant="normal">(</m:mi><m:mi mathvariant="normal">1</m:mi><m:mo>−</m:mo><m:mi mathvariant="italic">t</m:mi><m:msup><m:mrow><m:mi mathvariant="normal">)</m:mi></m:mrow><m:mrow><m:mi mathvariant="italic">M</m:mi><m:mo>−</m:mo><m:mi mathvariant="italic">j</m:mi></m:mrow></m:msup><m:msup><m:mrow><m:mi mathvariant="italic">t</m:mi></m:mrow><m:mrow><m:mi mathvariant="italic">j</m:mi></m:mrow></m:msup><m:munderover><m:mrow><m:mstyle displaystyle="true" mathvariant="normal"><m:mrow><m:mo>∑</m:mo></m:mrow></m:mstyle></m:mrow><m:mrow><m:mi mathvariant="italic">k</m:mi><m:mo>=</m:mo><m:mi mathvariant="normal">0</m:mi></m:mrow><m:mrow><m:mi mathvariant="italic">N</m:mi></m:mrow></m:munderover><m:mo>(</m:mo><m:mtable><m:mtr><m:mtd><m:mi mathvariant="italic">k</m:mi></m:mtd></m:mtr><m:mtr><m:mtd><m:mi mathvariant="italic">N</m:mi></m:mtd></m:mtr></m:mtable><m:mo>)</m:mo><m:mi mathvariant="normal">(</m:mi><m:mi mathvariant="normal">1</m:mi><m:mo>−</m:mo><m:mi mathvariant="italic">u</m:mi><m:msup><m:mrow><m:mi mathvariant="normal">)</m:mi></m:mrow><m:mrow><m:mi mathvariant="italic">N</m:mi><m:mo>−</m:mo><m:mi mathvariant="italic">k</m:mi></m:mrow></m:msup><m:msup><m:mrow><m:mi mathvariant="italic">u</m:mi></m:mrow><m:mrow><m:mi mathvariant="italic">k</m:mi></m:mrow></m:msup><m:msubsup><m:mrow><m:mi mathvariant="bold">P</m:mi></m:mrow><m:mrow><m:mi mathvariant="bold">i</m:mi><m:mi mathvariant="bold">j</m:mi><m:mi mathvariant="bold">k</m:mi></m:mrow><m:mrow><m:mo>′</m:mo></m:mrow></m:msubsup><m:mo>,</m:mo></m:mrow></m:math>
</div>
<figure id="f16_14" tabindex="0">
<img alt="" src="../images/fig16_14.jpg"/>
<figcaption><p><span class="blue">Figure 16.14.</span> Adjusting the FFD lattice results in the deformation of the object.</p></figcaption>
</figure>
<p class="noindent1">where <em>L, M, N</em> are maximum indices of lattice points in each dimension. In effect, the lattice serves as a low-resolution version of the object for the purpose of deformation, allowing for a smooth shape change of an arbitrarily complex object <a id="term-88"/><a id="term-89"/><a id="term-260"/><a id="term-493"/><span aria-label="443" epub:type="pagebreak" id="pg_443" role="doc-pagebreak"/>through a relatively small number of intuitive adjustments. FFD lattices can themselves be treated as regular objects by the system and can be transformed, animated, and even further deformed if necessary, leading to corresponding changes in the object to which the lattice is attached. For example, moving a <em>deformation tool</em> consisting of the original lattice and distorted lattice representing a bulge across an object results in a bulge moving across the object.</p>
</section>
<section>
<h2 id="sec16_4"><a id="index_term132"/><a epub:type="backlink" href="C02a_toc.xhtml#rsec16_4" role="doc-backlink"><span class="green">16.4 Character Animation</span></a></h2>
<p>Animation of articulated figures is most often performed through a combination of keyframing and specialized deformation techniques. The character model intended for animation typically consists of at least two main layers as shown in <a href="C21_chapter16.xhtml#f16_15">Figure 16.15</a>. The motion of a highly detailed surface representing the outer shell or <em>skin</em> of the character is what the viewer will eventually see in the final product. The <em>skeleton</em> underneath it is a hierarchical structure (a tree) of joints which provides a kinematic model of the figure and is used exclusively for animation. In some cases, additional intermediate layer(s) roughly corresponding to muscles are inserted between the skeleton and the skin.</p>
<figure id="f16_15" tabindex="0">
<img alt="" src="../images/fig16_15.jpg"/>
<figcaption><p><span class="blue">Figure 16.15.</span> (Left) A hierarchy of joints, a skeleton, serves as a kinematic abstraction of the character; (middle) repositioning the skeleton deforms a separate skin object attached to it; (right) a tree data structure is used to represent the skeleton. For compactness, the internal structure of several nodes is hidden (they are identical to a corresponding sibling).</p></figcaption>
</figure>
<p><a id="term-90"/><a id="term-287"/><a id="term-489"/><span aria-label="444" epub:type="pagebreak" id="pg_444" role="doc-pagebreak"/>Each of the skeleton’s joints acts as a parent for the hierarchy below it. The root represents the whole character and is positioned directly in the world coordinate system. If a local transformation matrix which relates a joint to its parent in the hierarchy is available, one can obtain a transformation which relates local space of any joint to the world system (i.e., the system of the root) by simply concatenating transformations along the path from the root to the joint. To evaluate the whole skeleton (i.e., find position and orientation of all joints), a depth-first traversal of the complete tree of joints is performed. A transformation stack is a natural data structure to help with this task. While traversing down the tree, the current composite matrix is pushed on the stack and a new one is created by multiplying the current matrix with the one stored at the joint. When backtracking to the parent, this extra transformation should be undone before another branch is visited; this is easily done by simply popping the stack. Although this general and simple technique for evaluating hierarchies is used throughout computer graphics, in animation (and robotics) it is given a special name–<em><a id="index_term369"/>forward <a id="index_term649"/>kinematics</em> (FK). While general representations for all transformations can be used, it is common to use specialized sets of parameters, such as link lengths or joint angles, to specify skeletons. To animate with forward kinematics, rotational parameters of all joints are manipulated directly. The technique also allows the animator to change the distance between joints (link lengths), but one should be aware that this corresponds to limb stretching and can often look rather unnatural.</p>
<p>Forward kinematics requires the user to set parameters for all joints involved in the motion (<a href="C21_chapter16.xhtml#f16_16">Figure 16.16</a> (top)). Most of these joints, however, belong to internal <a id="term-91"/><span aria-label="445" epub:type="pagebreak" id="pg_445" role="doc-pagebreak"/>nodes of the hierarchy, and their motion is typically not something the animator wants to worry about. In most situations, the animator just wants them to move naturally “on their own,” and one is much more interested in specifying the behavior of the endpoint of a joint chain, which typically corresponds to something performing a specific action, such as an ankle or a tip of a finger. The animator would rather have parameters of all internal joints be determined from the motion of the end effector automatically by the system. <em><a id="index_term636"/>Inverse kinematics</em>(IK) allows us to do just that (see <a href="C21_chapter16.xhtml#f16_16">Figure 16.16</a> (bottom)).</p>
<figure id="f16_16" tabindex="0">
<img alt="" src="../images/fig16_16.jpg"/>
<figcaption><p><span class="blue">Figure 16.16.</span> Forward kinematics (top) requires the animator to put all joints into correct position. In inverse kinematic (bottom), parameters of some internal joints are computed based on desired end effector motion.</p></figcaption>
</figure>
<p>Let <strong>x</strong> be the position of the end effector and <em>α</em> be the vector of parameters needed to specify all internal joints along the chain from the root to the final joint. Sometimes the orientation of the final joint is also directly set by the animator, in which case we assume that the corresponding variables are included in the vector <strong>x</strong>. For simplicity, however, we will write all specific expressions for the vector:</p>
<div class="disp-formula">
<m:math display="block"><m:mrow><m:mi mathvariant="bold">x</m:mi><m:mo>=</m:mo><m:mi mathvariant="normal">(</m:mi><m:msub><m:mrow><m:mi mathvariant="italic">x</m:mi></m:mrow><m:mrow><m:mi mathvariant="normal">1</m:mi></m:mrow></m:msub><m:mo>,</m:mo><m:mi mathvariant="normal"/><m:msub><m:mrow><m:mi mathvariant="italic">x</m:mi></m:mrow><m:mrow><m:mi mathvariant="normal">2</m:mi></m:mrow></m:msub><m:mo>,</m:mo><m:mi mathvariant="normal"/><m:msub><m:mrow><m:mi mathvariant="italic">x</m:mi></m:mrow><m:mrow><m:mi mathvariant="normal">3</m:mi></m:mrow></m:msub><m:msup><m:mrow><m:mi mathvariant="normal">)</m:mi></m:mrow><m:mrow><m:mi mathvariant="italic">T</m:mi></m:mrow></m:msup><m:mn>.</m:mn></m:mrow></m:math>
</div>
<p>Since each of the variables in <strong>x</strong> is a function of <em>α</em>, it can be written as a vector equation <strong>x</strong> = <strong>F</strong>(<em>α</em>). If we change the internal joint parameters by a small amount <em>δα</em>, a resulting change <em>δ</em><strong>x</strong> in the position of the end effector can be approximately written as</p>
<div class="disp-formula">
<m:math xmlns:mml="http://www.w3.org/1998/Math/MathML" alttext=""><m:mrow><m:mi>δ</m:mi><m:mi mathvariant="bold">x</m:mi><m:mo>=</m:mo><m:mfrac><m:mrow><m:mo>∂</m:mo><m:mi mathvariant="bold">F</m:mi></m:mrow><m:mrow><m:mo>∂</m:mo><m:mi>α</m:mi></m:mrow></m:mfrac><m:mi>δ</m:mi><m:mi>α</m:mi><m:mo>,</m:mo><m:mtext> </m:mtext><m:mtext> </m:mtext><m:mtext> </m:mtext><m:mtext> </m:mtext><m:mtext> </m:mtext><m:mtext> </m:mtext><m:mtext> </m:mtext><m:mtext> </m:mtext><m:mtext> </m:mtext><m:mtext> </m:mtext><m:mtext> </m:mtext><m:mtext> </m:mtext><m:mtext> </m:mtext><m:mtext> </m:mtext><m:mtext> </m:mtext><m:mtext> </m:mtext><m:mtext> </m:mtext><m:mtext> </m:mtext><m:mtext> </m:mtext><m:mtext> </m:mtext><m:mtext> </m:mtext><m:mrow><m:mo>(</m:mo><m:mn>16.1</m:mn><m:mo>)</m:mo></m:mrow></m:mrow></m:math>
</div>
<p>where <span class="inline-formula"><m:math display="inline"><m:mrow><m:mfrac><m:mrow><m:mo>∂</m:mo><m:mi mathvariant="bold">F</m:mi></m:mrow><m:mrow><m:mo>∂</m:mo><m:mi>α</m:mi></m:mrow></m:mfrac></m:mrow></m:math></span> is the matrix of partial derivatives called the Jacobian:</p>
<div class="disp-formula" id="equ16_1">
<m:math xmlns:mml="http://www.w3.org/1998/Math/MathML" alttext=""><m:mrow><m:mfrac><m:mrow><m:mo>∂</m:mo><m:mi mathvariant="bold">F</m:mi></m:mrow><m:mrow><m:mo>∂</m:mo><m:mi>α</m:mi></m:mrow></m:mfrac><m:mo>=</m:mo><m:mrow><m:mo>[</m:mo><m:mtable><m:mtr><m:mtd><m:mfrac><m:mrow><m:mo>∂</m:mo><m:msub><m:mrow><m:mi>f</m:mi></m:mrow><m:mrow><m:mn>1</m:mn></m:mrow></m:msub></m:mrow><m:mrow><m:mo>∂</m:mo><m:msub><m:mrow><m:mi>α</m:mi></m:mrow><m:mrow><m:mn>1</m:mn></m:mrow></m:msub></m:mrow></m:mfrac></m:mtd><m:mtd><m:mfrac><m:mrow><m:mo>∂</m:mo><m:msub><m:mrow><m:mi>f</m:mi></m:mrow><m:mrow><m:mn>1</m:mn></m:mrow></m:msub></m:mrow><m:mrow><m:mo>∂</m:mo><m:msub><m:mrow><m:mi>α</m:mi></m:mrow><m:mrow><m:mn>2</m:mn></m:mrow></m:msub></m:mrow></m:mfrac></m:mtd><m:mtd><m:mi>$</m:mi></m:mtd><m:mtd><m:mfrac><m:mrow><m:mo>∂</m:mo><m:msub><m:mrow><m:mi>f</m:mi></m:mrow><m:mrow><m:mn>1</m:mn></m:mrow></m:msub></m:mrow><m:mrow><m:mo>∂</m:mo><m:msub><m:mrow><m:mi>α</m:mi></m:mrow><m:mrow><m:mi>n</m:mi></m:mrow></m:msub></m:mrow></m:mfrac></m:mtd></m:mtr><m:mtr><m:mtd><m:mfrac><m:mrow><m:mo>∂</m:mo><m:msub><m:mrow><m:mi>f</m:mi></m:mrow><m:mrow><m:mn>2</m:mn></m:mrow></m:msub></m:mrow><m:mrow><m:mo>∂</m:mo><m:msub><m:mrow><m:mi>α</m:mi></m:mrow><m:mrow><m:mn>1</m:mn></m:mrow></m:msub></m:mrow></m:mfrac></m:mtd><m:mtd><m:mfrac><m:mrow><m:mo>∂</m:mo><m:msub><m:mrow><m:mi>f</m:mi></m:mrow><m:mrow><m:mn>2</m:mn></m:mrow></m:msub></m:mrow><m:mrow><m:mo>∂</m:mo><m:msub><m:mrow><m:mi>α</m:mi></m:mrow><m:mrow><m:mn>2</m:mn></m:mrow></m:msub></m:mrow></m:mfrac></m:mtd><m:mtd><m:mi>$</m:mi></m:mtd><m:mtd><m:mfrac><m:mrow><m:mo>∂</m:mo><m:msub><m:mrow><m:mi>f</m:mi></m:mrow><m:mrow><m:mn>2</m:mn></m:mrow></m:msub></m:mrow><m:mrow><m:mo>∂</m:mo><m:msub><m:mrow><m:mi>α</m:mi></m:mrow><m:mrow><m:mi>n</m:mi></m:mrow></m:msub></m:mrow></m:mfrac></m:mtd></m:mtr><m:mtr><m:mtd><m:mfrac><m:mrow><m:mo>∂</m:mo><m:msub><m:mrow><m:mi>f</m:mi></m:mrow><m:mrow><m:mn>3</m:mn></m:mrow></m:msub></m:mrow><m:mrow><m:mo>∂</m:mo><m:msub><m:mrow><m:mi>α</m:mi></m:mrow><m:mrow><m:mn>1</m:mn></m:mrow></m:msub></m:mrow></m:mfrac></m:mtd><m:mtd><m:mfrac><m:mrow><m:mo>∂</m:mo><m:msub><m:mrow><m:mi>f</m:mi></m:mrow><m:mrow><m:mn>3</m:mn></m:mrow></m:msub></m:mrow><m:mrow><m:mo>∂</m:mo><m:msub><m:mrow><m:mi>α</m:mi></m:mrow><m:mrow><m:mn>2</m:mn></m:mrow></m:msub></m:mrow></m:mfrac></m:mtd><m:mtd><m:mi>$</m:mi></m:mtd><m:mtd><m:mfrac><m:mrow><m:mo>∂</m:mo><m:msub><m:mrow><m:mi>f</m:mi></m:mrow><m:mrow><m:mn>3</m:mn></m:mrow></m:msub></m:mrow><m:mrow><m:mo>∂</m:mo><m:msub><m:mrow><m:mi>α</m:mi></m:mrow><m:mrow><m:mi>n</m:mi></m:mrow></m:msub></m:mrow></m:mfrac></m:mtd></m:mtr></m:mtable><m:mo>]</m:mo></m:mrow><m:mn>.</m:mn></m:mrow></m:math>
</div>
<p>At each moment in time, we know the desired position of the end effector (set by the animator) and, of course, the effector’s current position. Subtracting the two, we will get the desired adjustment <em>δ</em><strong>x</strong>. Elements of the Jacobian matrix are related to changes in a coordinate of the end effector when a particular internal parameter is changed while others remain fixed (see <a href="C21_chapter16.xhtml#f16_17">Figure 16.17</a>). These elements can be computed for any given skeleton configuration using geometric relationships. The only remaining unknowns in the system of equations (16.1) are the changes in internal parameters <em>α</em>. Once we solve for them, we update <em>α</em> = <em>α</em>+<em>δα</em> which gives all the necessary information for the FK procedure to reposition the skeleton.</p>
<figure id="f16_17" tabindex="0">
<img alt="" src="../images/fig16_17.jpg"/>
<figcaption><p><span class="blue">Figure 16.17.</span> Partial derivative <em>∂x/∂α</em><sub>knee</sub> is given by the limit of Δ<em>x</em>/Δ<em>α</em><sub>knee</sub>. Effector displacement is computed while all joints, except the knee, are kept fixed.</p></figcaption>
</figure>
<p>Unfortunately, the system (16.1) cannot usually be solved analytically and, moreover, it is in most cases underconstrained, i.e., the number of unknown internal joint parameters <em>α</em> exceeds the number of variables in vector <strong>x</strong>. This means that different motions of the skeleton can result in the same motion of the end <a id="term-92"/><a id="term-477"/><a id="term-490"/><span aria-label="446" epub:type="pagebreak" id="pg_446" role="doc-pagebreak"/>effector. Some examples are shown on <a href="C21_chapter16.xhtml#f16_18">Figure 16.18</a>. Many ways of obtaining specific solution for such systems are available, including those taking into account natural <em>constraints</em> needed for some real-life joints (bending a knee only in one direction, for example). One should also remember that the computed Jacobian matrix is valid only for one specificconfiguration, and it has to be updated as the skeleton moves. The complete IK framework is presented in <a href="C21_chapter16.xhtml#f16_19">Figure 16.19</a>. Of course, the root joint for IK does not have to be the root of the whole hierarchy, and multiple IK solvers can be applied to independent parts of the skeleton. For example, one can use separate solvers for right and left feet and yet another one to help animate grasping with the right hand, each with its own root.</p>
<figure id="f16_18" tabindex="0">
<img alt="" src="../images/fig16_18.jpg"/>
<figcaption><p><span class="blue">Figure 16.18.</span> Multiple configurations of internal joints can result in the same effector position. (Top) disjoint “flipped” solutions; (bottom) a continuum of solutions.</p></figcaption>
</figure>
<figure id="f16_19" tabindex="0">
<img alt="" src="../images/fig16_19.jpg"/>
<figcaption><p><span class="blue">Figure 16.19.</span> A diagram of the inverse kinematic algorithm.</p></figcaption>
</figure>
<p>A combination of FK and IK approaches is typically used to animate the skeleton. Many common motions (walking or running cycles, grasping, reaching, etc.) exhibit well-known patterns of mutual joint motion making it possible to quickly <a id="term-87"/><a id="term-94"/><a id="term-95"/><a id="term-163"/><a id="term-279"/><span aria-label="447" epub:type="pagebreak" id="pg_447" role="doc-pagebreak"/>create naturally looking motion or even use a library of such “clips.” The animator then adjusts this generic result according to the physical parameters of the character and also to give it more individuality.</p>
<p>When a skeleton changes its position, it acts as a special type of deformer applied to the skin of the character. The motion is transferred to this surface by assigning each skin vertex one (<em>rigid skinning</em>)or more(<em>smooth skinning</em>) joints as drivers (see <a href="C21_chapter16.xhtml#f16_20">Figure 16.20</a>). In the first case, a skin vertex is simply frozen into the local space of the corresponding joint, which can be the one nearest in space or one chosen directly by the user. The vertex then repeats whatever motion this joint experiences, and its position in world coordinates is determined by standard FK procedure. Although it is simple, rigid skinning makes it difficult to obtain sufficiently smooth skin deformation in areas near the joints or also for more subtle effects resembling breathing or muscle action. Additional specialized deformers called <em>flexors</em> can be used for this purpose. In smooth skinning, several joints can influence a skin vertex according to some weight assigned by the animator, providing more detailed control over the results. Displacement vectors, <strong>d<sub>i</sub></strong>, suggested by different joints affecting a given skin vertex (each again computed with standard FK) are averaged according to their weights <em>w<sub>i</sub></em> to compute the final displacement of the vertex <strong>d</strong> = Σ <em>w<sub>i</sub></em><strong>d<sub>i</sub></strong>. Normalized weights (Σ <em>w<sub>i</sub></em> = 1) are the most common but not fundamentally necessary. Setting smooth skinning weights to achieve the desired effect is not easy and requires significant skill from the animator.</p>
<figure id="f16_20" tabindex="0">
<img alt="" src="../images/fig16_20.jpg"/>
<figcaption><p><span class="blue">Figure 16.20.</span> Top: Rigid skinning assigns skin vertices to a specific joint. Those belonging to the elbow joint are shown in black; Bottom: Soft skinning can blend the influence of several joints. Weights for the elbow joint are shown (lighter = greater weight). Note smoother skin deformation of the inner part of the skin near the joint.</p></figcaption>
</figure>
<section>
<h3 id="sec16_4_1"><a id="index_term355"/><span class="green">16.4.1 Facial Animation</span></h3>
<p>Skeletons are well suited for creating most motions of a character’s body, but they are not very convenient for realistic facial animation. The reason is that the skin of a human face is moved by muscles directly attached to it, contrary to other parts of the body where the primary objective of the muscles is to move the bones of the skeleton and any skin deformation is a secondary outcome. The result of this facial anatomical arrangement is a very rich set of dynamic facial expressions humans use as one of the main instruments of communication. We are all very well trained to recognize such facial variations and can easily notice any unnatural appearance. This not only puts special demands on the animator but also requires a high-resolution geometric model of the face and, if photorealism is desired, accurate skin reflection properties and textures.</p>
<p>While it is possible to set key poses of the face vertex-by-vertex and interpolate between them or directly simulate the behavior of the underlying muscle structure using physics-based techniques (see <a href="C21_chapter16.xhtml#sec16_5">Section 16.5</a>), more specialized <a id="term-169"/><a id="term-542"/><span aria-label="448" epub:type="pagebreak" id="pg_448" role="doc-pagebreak"/>high-level approaches also exist. The static shape of a specific face can be characterized by a relatively small set of so-called <em>conformational parameters</em> (overall scale, distance from the eye to the forehead, length of the nose, width of the jaws, etc.) which are used to morph a generic face model into one with individual features. An additional set of <em>expressive parameters</em> can be used to describe the dynamic shape of the face for animation. Examples include rigid rotation of the head, how wide the eyes are open, movement of some feature point from its static position, etc. These are chosen so that most of the interesting expressions can be obtained through some combination of parameter adjustments, therefore, allowing a face to be animated via standard keyframing. To achieve a higher level of control, one can use expressive parameters to create a set of expressions corresponding to common emotions (neutral, sadness, happiness, anger, surprise, etc.) and then blend these key poses to obtain a “slightly sad” or “angrily surprised” face. Similar techniques can be used to perform lip-synch animation, but key poses in this case correspond to different phonemes. Instead of using a sequence of static expressions to describe a dynamic one, the Facial Action Coding System (FACS) (Eckman &amp; Friesen, 1978) decomposes dynamic facial expressions directly into a sum of elementary motions called action units (AUs). The set of AUs is based on extensive psychological research and includes such movements as raising the inner brow, wrinkling the nose, stretching lips, etc. Combining AUs can be used to synthesize a necessary expression.</p>
</section>
<section>
<h3 id="sec16_4_2"><a id="index_term212"/><a id="index_term762"/><span class="green">16.4.2 Motion Capture</span></h3>
<p>Even with the help of the techniques described above, creating realistic-looking character animation from scratch remains a daunting task. It is therefore only natural that much attention is directed toward techniques which record an actor’s motion in the real world and then apply it to computer-generated characters. Two main classes of such <em>motion capture</em> (MC) techniques exist: electromagnetic and optical.</p>
<p>In electromagnetic motion capture, an electromagnetic sensor directly measures its position (and possibly orientation) in 3D, often providing the captured results in real time. Disadvantages of this technique include significant equipment cost, possible interference from nearby metal objects, and noticeable size of sensors and batteries which can be an obstacle in performing high-amplitude motions. In optical MC, small colored markers are used instead of active sensors making it a much less intrusive procedure. <a href="C21_chapter16.xhtml#f16_21">Figure 16.21</a> shows the operation of such a system. In the most basic arrangement, the motion is recorded by two calibrated video cameras, and simple triangulation is used to extract the marker’s 3D position. More advanced computer vision algorithms used for accurate tracking <a id="term-93"/><a id="term-543"/><span aria-label="449" epub:type="pagebreak" id="pg_449" role="doc-pagebreak"/>of multiple markers from video are computationally expensive, so, in most cases, such processing is done offline. Optical tracking is generally less robust than electromagnetic. Occlusion of a given marker in some frames, possible misidentification of markers, and noise in images are just a few of the common problem which have to be addressed. Introducing more cameras observing the motion from different directions improves both accuracy and robustness, but this approach is more expensive and it takes longer to process such data. Optical MC becomes more attractive as available computational power increases and better computer vision algorithms are developed. Because of low impact nature of markers, optical methods are suitable for delicate facial motion capture and can also be used with objects other than humans–for example, animals or even tree branches in the wind.</p>
<figure id="f16_21" tabindex="0">
<img alt="" src="../images/fig16_21.jpg"/>
<figcaption><p><span class="blue">Figure 16.21.</span> Optical motion capture: markers attached to a performer’s body allow skeletal motion to be extracted. <em>Image courtesy of Motion Analysis Corp.</em></p></figcaption>
</figure>
<p>With several sensors or markers attached to a performer’s body, a set of time-dependant 3D positions of some collection of points can be recorded. These tracking locations are commonly chosen near joints, but, of course, they still lie on skin surface and not at points where actual bones meet. Therefore, some additional care and a bit of extra processing is necessary to convert recorded positions into those of the physical skeleton joints. For example, putting two markers on opposite sides of the elbow or ankle allows the system to obtain better joint position by averaging locations of the two markers. Without such extra care, very noticeable artifacts can appear due to offset joint positions as well as inherent noise and insufficient measurement accuracy. Because of physical inaccuracy during motion, for example, character limbs can lose contact with objects they are supposed to touch during walking or grasping, problems like foot-sliding (skating) of the skeleton can occur. Most of these problems can be corrected by using inverse kinematics techniques which can explicitly force the required behavior of the limb’s end.</p>
<p>Recovered joint positions can now be directly applied to the skeleton of a computer-generated character. This procedure assumes that the physical dimensions of the character are identical to those of the performer. Retargeting recorded motion to a different character and, more generally, editing MC data, requires significant care to satisfy necessary constraints (such as maintaining feet on the ground or not allowing an elbow to bend backwards) and preserve an overall natural appearance of the modified motion. Generally, the greater the desired change from the original, the less likely it will be possible to maintain the quality of the result. An interesting approach to the problem is to record a large collection of motions and stitch together short clips from this library to obtain desired movement. Although this topic is currently a very active research area, limited ability to adjust the recorded motion to the animator’s needs remains one of the main disadvantages of motion capture technique.</p>
</section>
</section>
<section>
<h2 id="sec16_5"><a epub:type="backlink" href="C02a_toc.xhtml#rsec16_5" role="doc-backlink"><span class="green">16.5 Physics-Based Animation</span></a></h2>
<p><a id="term-15"/><a id="term-174"/><a id="term-175"/><a id="term-607"/><span aria-label="450" epub:type="pagebreak" id="pg_450" role="doc-pagebreak"/>The world around us is governed by physical laws, many of which can be formalized as sets of partial or, in some simpler cases, ordinary differential equations. One of the original applications of computers was (and remains) solving such equations. It is therefore only natural to attempt to use numerical techniques developed over the several past decades to obtain realistic motion for computer animation.</p>
<p>Because of its relative complexity and significant cost, <a id="index_term852"/>physics-based animation is most commonly used in situations when other techniques are either unavailable or do not produce sufficiently realistic results. Prime examples include animation of fluids (which includes many gaseous phase phenomena described by the same equations–smoke, clouds, fire, etc.), cloth simulation (an example is shown in <a href="C21_chapter16.xhtml#f16_22">Figure 16.22</a>), rigid body motion, and accurate deformation of elastic objects. Governing equations and details of commonly used numerical approaches are different in each of these cases, but many fundamental ideas and difficulties remain applicable across applications. Many methods for numerically solving ODEs and PDEs exist, but discussing them in details is far beyond the scope of this book. To give the reader a flavor of physics-based techniques and some of the issues involved, we will briefly mention here only the finite difference approach–one of the conceptually simplest and most popular families of algorithms which has been applied to most, if not all, differential equations encountered in animation.</p>
<figure id="f16_22" tabindex="0">
<img alt="" src="../images/fig16_22.jpg"/>
<figcaption><p><span class="blue">Figure 16.22.</span> Realistic cloth simulation is often performed with physics-based methods. In this example, forces are due to collisions and gravity.</p></figcaption>
</figure>
<p>The key idea of this approach is to replace a differential equation with its discrete analog–a difference equation. To do this, the continuous domain of interest is represented by a finite set of points at which the solution will be computed. In the simplest case, these are defined on a uniform rectangular grid as shown in <a href="C21_chapter16.xhtml#f16_23">Figure 16.23</a>. Every derivative present in the original ODE or PDE is then replaced by its approximation through function values at grid points. One way of doing this is to subtract the function value at a given point from the function value for its neighboring point on the grid:</p>
<figure id="f16_23" tabindex="0">
<img alt="" src="../images/fig16_23.jpg"/>
<figcaption><p><span class="blue">Figure 16.23.</span> Two possible difference schemes for an equation involving derivatives ∂<em>f</em>/∂<em>x</em> and ∂<em>f</em>/∂<em>t</em>. (Left) An explicit scheme expresses unknown values (open circles) only through known values at the current (orange circles) and possibly past (blue circles) time; (Right) Implicit schemes mix known and unknown values in a single equation making it necessary to solve all such equations as a system. For both schemes, information about values on the right boundary is needed to close the process.</p></figcaption>
</figure>
<div class="disp-formula">
<m:math xmlns:mml="http://www.w3.org/1998/Math/MathML"><m:mrow><m:mfrac><m:mrow><m:mi>d</m:mi><m:mi>f</m:mi><m:mo>(</m:mo><m:mi>t</m:mi><m:mo>)</m:mo></m:mrow><m:mrow><m:mi>d</m:mi><m:mi>t</m:mi></m:mrow></m:mfrac><m:mo>≈</m:mo><m:mfrac><m:mrow><m:mi mathvariant="normal">Δ</m:mi><m:mi>f</m:mi></m:mrow><m:mrow><m:mi mathvariant="normal">Δ</m:mi><m:mi>t</m:mi></m:mrow></m:mfrac><m:mo>=</m:mo><m:mfrac><m:mrow><m:mi>f</m:mi><m:mo>(</m:mo><m:mi>t</m:mi><m:mo>+</m:mo><m:mi mathvariant="normal">Δ</m:mi><m:mi>t</m:mi><m:mo>)</m:mo></m:mrow><m:mrow><m:mi mathvariant="normal">Δ</m:mi><m:mi>t</m:mi></m:mrow></m:mfrac><m:mtext>or</m:mtext><m:mfrac><m:mrow><m:mo>∂</m:mo><m:mi>f</m:mi><m:mo>(</m:mo><m:mi>x</m:mi><m:mo>,</m:mo><m:mi>t</m:mi><m:mo>)</m:mo></m:mrow><m:mrow><m:mo>∂</m:mo><m:mi>x</m:mi></m:mrow></m:mfrac><m:mo>≈</m:mo><m:mfrac><m:mrow><m:mi mathvariant="normal">Δ</m:mi><m:mi>f</m:mi></m:mrow><m:mrow><m:mi mathvariant="normal">Δ</m:mi><m:mi>x</m:mi></m:mrow></m:mfrac><m:mo>=</m:mo><m:mfrac><m:mrow><m:mi>f</m:mi><m:mo>(</m:mo><m:mi>x</m:mi><m:mo>+</m:mo><m:mi mathvariant="normal">Δ</m:mi><m:mi>x</m:mi><m:mo>,</m:mo><m:mi>t</m:mi><m:mo>)</m:mo><m:mo>−</m:mo><m:mi>f</m:mi><m:mo>(</m:mo><m:mi>x</m:mi><m:mo>,</m:mo><m:mi>t</m:mi><m:mo>)</m:mo></m:mrow><m:mrow><m:mi mathvariant="normal">Δ</m:mi><m:mi>x</m:mi></m:mrow></m:mfrac><m:mn>.</m:mn><m:mo>⁢</m:mo><m:mtext> </m:mtext><m:mtext> </m:mtext><m:mtext> </m:mtext><m:mtext> </m:mtext><m:mtext> </m:mtext><m:mtext> </m:mtext><m:mtext> </m:mtext><m:mtext> </m:mtext><m:mtext> </m:mtext><m:mtext> </m:mtext><m:mtext> </m:mtext><m:mtext> </m:mtext><m:mtext> </m:mtext><m:mtext> </m:mtext><m:mtext> </m:mtext><m:mtext> </m:mtext><m:mtext> </m:mtext><m:mtext> </m:mtext><m:mtext> </m:mtext><m:mtext> </m:mtext><m:mtext> </m:mtext><m:mtext> </m:mtext><m:mtext> </m:mtext><m:mo>(</m:mo><m:mn>16.2</m:mn><m:mo>)</m:mo></m:mrow></m:math>
</div>
<p>These expressions are, of course, not the only way. One can, for example, use <em>f</em> (<em>t</em> − Δ<em>t</em>) instead of <em>f</em>(<em>t</em>) above and divide by 2Δ<em>t</em>. For an equation containing a time derivative, it is now possible to propagate values of an unknown function forward in time in a sequence of Δ<em>t</em>-size steps by solving the system of difference equations (one at each spatial location) for unknown <em>f</em>(<em>t</em> + Δ<em>t</em>). Some initial <a id="term-16"/><a id="term-176"/><span aria-label="451" epub:type="pagebreak" id="pg_451" role="doc-pagebreak"/>conditions, i.e., values of the unknown function at <em>t</em> = 0, are necessary to start the process. Other information, such as values on the boundary of the domain, might also be required depending on the specific problem.</p>
<p>The computation of <em>f</em> (<em>t</em>+Δ<em>t</em>) can be done easily for so-called <em>explicit</em> schemes when all other values present are taken at the current time and the only unknown in the corresponding difference equation <em>f</em> (<em>t</em> + Δ<em>t</em>) is expressed through these known values. <em>Implicit</em> schemes mix values at current and future times and might use, for example,</p>
<div class="disp-formula">
<m:math display="block"><m:mrow><m:mfrac><m:mrow><m:mi mathvariant="italic">f</m:mi><m:mi mathvariant="normal">(</m:mi><m:mi mathvariant="italic">x</m:mi><m:mo>+</m:mo><m:mo>Δ</m:mo><m:mi mathvariant="italic">x</m:mi><m:mo>,</m:mo><m:mi mathvariant="italic">t</m:mi><m:mo>+</m:mo><m:mo>Δ</m:mo><m:mi mathvariant="italic">t</m:mi><m:mi mathvariant="normal">)</m:mi><m:mo>−</m:mo><m:mi mathvariant="italic">f</m:mi><m:mi mathvariant="normal">(</m:mi><m:mi mathvariant="italic">x</m:mi><m:mo>,</m:mo><m:mi mathvariant="italic">t</m:mi><m:mo>+</m:mo><m:mo>Δ</m:mo><m:mi mathvariant="italic">t</m:mi><m:mi mathvariant="normal">)</m:mi></m:mrow><m:mrow><m:mo>Δ</m:mo><m:mi mathvariant="italic">x</m:mi></m:mrow></m:mfrac></m:mrow></m:math>
</div>
<p>as an approximation of <span class="inline-formula"><m:math display="inline"><m:mrow><m:mfrac><m:mrow><m:mo>∂</m:mo><m:mi>f</m:mi></m:mrow><m:mrow><m:mo>∂</m:mo><m:mi>x</m:mi></m:mrow></m:mfrac></m:mrow></m:math></span>. In this case one has to solve a system of algebraic equations at each step.</p>
<p>The choice of difference scheme can dramatically affect all aspects of the algorithm. The most obvious among them is <em>accuracy</em>. In the limit Δ<em>t</em> → 0 or Δ<em>x</em> → 0, expressions of the type in Equation (16.2) are exact, but for finite step size some schemes allow better approximation of the derivative than others. <em>Stability</em> of a difference scheme is related to how fast numerical errors, which are always present in practice, can grow with time. For stable schemes this growth is bounded, while for unstable ones it is exponential and can quickly overwhelm the solution one seeks (see <a href="C21_chapter16.xhtml#f16_24">Figure 16.24</a>). It is important to realize that while some inaccuracy in the solution is tolerable (and, in fact, accuracy demanded in physics and engineering is rarely needed for animation), an unstable result is completely <a id="term-178"/><a id="term-642"/><span aria-label="452" epub:type="pagebreak" id="pg_452" role="doc-pagebreak"/>meaningless, and one should avoid using unstable schemes. Generally, explicit schemes are either unstable or can become unstable at larger step sizes while implicit ones are unconditionally stable. Implicit schemes allows greater step size (and, therefore, fewer steps) which is why they are popular despite the need to solve a system of algebraic equations at each step. Explicit schemes are attractive because of their simplicity if their stability conditions can be satisfied. Developing a good difference scheme and corresponding algorithm for a specific problem is not easy, and for most standard situations it is well advised to use an existing method. Ample literature discussing details of these techniques is available.</p>
<figure id="f16_24" tabindex="0">
<img alt="" src="../images/fig16_24.jpg"/>
<figcaption><p><span class="blue">Figure 16.24.</span> An unstable solution might follow the exact one initially, but can deviate arbitrarily far from it with time. Accuracy of a stable solution might still be insufficient for a specific application.</p></figcaption>
</figure>
<p>One should remember that, in many cases, just computing all necessary terms in the equation is a difficult and time-consuming task on its own. In rigid body or cloth simulation, for example, most of the forces acting on the system are due to collisions among objects. At each step during animation, one therefore has to solve a purely geometric, but very nontrivial, problem of collision detection. In such conditions, schemes which require fewer evaluations of such forces might provide significant computational savings.</p>
<p>Although the result of solving appropriate time-dependant equations gives very realistic motion, this approach has its limitations. First of all, it is very hard to control the result of physics-based animation. Fundamental mathematical properties of these equations state that once the initial conditions are set, the solution is uniquely defined. This does not leave much room for animator input and, if the result is not satisfactory for some reason, one has only a few options. They are mostly limited to adjusting initial condition used, changing physical properties of the system, or even modifying the equations themselves by introducing artificial terms intended to “drive” the solution in the direction the animator wants. Making such changes requires significant skill as well as understanding of the underlying physics and, ideally, numerical methods. Without this knowledge, the realism provided by physics-based animation can be destroyed or severe numerical problems might appear.</p>
</section>
<section>
<h2 id="sec16_6"><a id="index_term903"/><a epub:type="backlink" href="C02a_toc.xhtml#rsec16_6" role="doc-backlink"><span class="green">16.6 Procedural Techniques</span></a></h2>
<p>Imagine that one could write (and implement on a computer) a mathematical function which outputs precisely the desired motion given some animator guidance. Physics-based techniques outlined above can be treated as a special case of such an approach when the “function” involved is the procedure to solve a particular differential equation and “guidance” is the set of initial and boundary conditions, extra equation terms, etc.</p>
<p><a id="term-17"/><a id="term-179"/><a id="term-553"/><a id="term-892"/><span aria-label="453" epub:type="pagebreak" id="pg_453" role="doc-pagebreak"/>However, if we are only concerned with the final result, we do not have to follow a physics-based approach. For example, a simple constant amplitude wave on the surface of a lake can be directly created by applying the function <em>f</em> (<strong>x</strong><em>,t</em>) = <em>A</em> cos(<em>ωt</em> − <strong>kx</strong> + <em>ϕ</em>) with constant frequency <em>ω</em>, wave vector <strong>k</strong> and phase <em>ϕ</em> to get displacement at the 2D point <strong>x</strong> at time <em>t</em>. A collection of such waves with random phases and appropriately chosen amplitudes, frequencies, and wave vectors can result in a very realistic animation of the surface of water without explicitly solving any fluid dynamics equations. It turns out that other rather simple mathematical functions can also create very interesting patterns or objects. Several such functions, most based on lattice noises, have been described in <a href="C16_chapter11.xhtml#sec11_5">Section 11.5</a>. Adding time dependance to these functions allows us to animate certain complex phenomena much easier and cheaper than with physics-based techniques while maintaining very high visual quality of the results. If <em>noise</em>(<strong>x</strong>) is the underlying pattern-generating function, one can create a time-dependant variant of it by moving the argument position through the lattice. The simplest case is motion with constant speed: <em>timenoise</em>(<strong>x</strong><em>,t</em>) = <em>noise</em>(<strong>x</strong> + <strong>v</strong><em>t</em>), but more complex motion through the <a id="index_term663"/>lattice is, of course, also possible and, in fact, more common. One such path, a spiral, is shown in <a href="C21_chapter16.xhtml#f16_25">Figure 16.25</a>. Another approach is to animate parameters used to generate the <em>noise</em> function. This is especially appropriate if the appearance changes significantly with time–a cloud becoming more turbulent, for example. In this way one can animate the dynamic process of formation of clouds using the function which generates static ones.</p>
<figure id="f16_25" tabindex="0">
<img alt="" src="../images/fig16_25.jpg"/>
<figcaption><p><span class="blue">Figure 16.25.</span> A path through the cube defining procedural noise is traversed to animate the resulting pattern.</p></figcaption>
</figure>
<p>For some procedural techniques, time dependance is a more integral component. The simplest <em><a id="index_term131"/>cellular automata</em> operate on a 2D rectangular grid where a binary value is stored at each location (cell). To create a time varying pattern, some user-provided rules for modifying these values are repeatedly applied. Rules typically involve some set of conditions on the current value and that of the cell’s neighbors. For example, the rules of the popular 2D <em>Game of Life</em> cellular <a id="index_term62"/>automaton invented in 1970 by British mathematician John Conway are the following:</p>
<ol class="list-order">
<li>
<p class="list">A dead cell (i.e., binary value at a given location is 0) with exactly three live neighbors becomes a live cell (i.e., its value set to 1).</p>
</li>
<li>
<p class="list">A live cell with two or three live neighbors stays alive.</p>
</li>
<li>
<p class="list">In all other cases, a cell dies or remains dead.</p>
</li>
</ol>
<p class="indent">Once the rules are applied to all grid locations, a new pattern is created and a new evolution cycle can be started. Three sample snapshots of the live cell distribution at different times are shown in <a href="C21_chapter16.xhtml#f16_26">Figure 16.26</a>. More sophisticated automata <a id="term-18"/><a id="term-30"/><a id="term-180"/><a id="term-554"/><span aria-label="454" epub:type="pagebreak" id="pg_454" role="doc-pagebreak"/>simultaneously operate on several 3D grids of possibly floating point values and can be used for modeling dynamics of clouds and other gaseous phenomena or biological systems for which this apparatus was originally invented (note the terminology). Surprising pattern complexity can arise from just a few well-chosen rules, but how to write such rules to create the desired behavior is often not obvious. This is a common problem with procedural techniques: there is only limited, if any, guidance on how to create new procedures or even adjust parameters of existing ones. Therefore, a lot of tweaking and learning by trial-and-error (“by experience”) is usually needed to unlock the full potential of procedural methods.</p>
<figure id="f16_26" tabindex="0">
<img alt="" src="../images/fig16_26.jpg"/>
<figcaption><p><span class="blue">Figure 16.26.</span> Several (non-consecutive) stages in the evolution of a <em>Game of Life</em> automaton. Live cells are shown in black. Stable objects, oscillators, traveling patterns, and many other interesting constructions can result from the application of very simple rules. <em>Figure created using a program by Alan Hensel.</em></p></figcaption>
</figure>
<p>Another interesting approach which was also originally developed to describe biological objects is the technique called <em><a id="index_term654"/>L-systems</em> (after the name of their original inventor, Astrid Lindenmayer). This approach is based on <em>grammars</em> or sets of recursive rules for rewriting strings of symbols. There are two types of symbols: <em>terminal symbols</em> stand for elements of something we want to represent with a grammar. Depending on their meaning, grammars can describe structure of trees and bushes, buildings and whole cities, or programming and natural languages. In animation, L-systems are most popular for representing plants and corresponding terminals are instructions to the geometric modeling system: put a leaf (or a branch) at a current position–we will use the symbol @ and just draw a circle, move current position forward by some number of units (symbol <em>f</em>), turn current direction 60 degrees around world <em>Z</em>-axis (symbol +), pop (symbol [) or push (symbol ]) current position/orientation, etc. Auxiliary <em>non<a id="index_term1160"/>terminal symbols</em> (de-noted by capital letters) have only semantic rather than any direct meaning. They are intended to be eventually rewritten through terminals. We start from the special nonterminal start <a id="index_term1146"/>symbol <em>S</em> and keep applying <a id="index_term450"/>grammar rules to the current string in parallel, i.e., replace all nonterminals currently present to get the new <a id="term-19"/><a id="term-167"/><a id="term-171"/><a id="term-181"/><a id="term-492"/><span aria-label="455" epub:type="pagebreak" id="pg_455" role="doc-pagebreak"/>string, until we end up with a string containing only terminals and no more substitution is therefore possible. This string of modeling instructions is then used to output the actual geometry. For example, a set of rules (productions)</p>
<div class="disp-formula">
<m:math xmlns:mml="http://www.w3.org/1998/Math/MathML"><m:mrow><m:mtable columnalign="left"><m:mtr><m:mtd><m:mi>S</m:mi><m:mo>→</m:mo><m:mi>A</m:mi></m:mtd></m:mtr><m:mtr><m:mtd><m:mi>A</m:mi><m:mo>→</m:mo><m:mo>[</m:mo><m:mo>+</m:mo><m:mi>B</m:mi><m:mo>]</m:mo><m:mi>f</m:mi><m:mi>A</m:mi></m:mtd></m:mtr><m:mtr><m:mtd><m:mi>A</m:mi><m:mo>→</m:mo><m:mi>B</m:mi></m:mtd></m:mtr><m:mtr><m:mtd><m:mi>B</m:mi><m:mo>→</m:mo><m:mi>f</m:mi><m:mi>B</m:mi></m:mtd></m:mtr><m:mtr><m:mtd><m:mi>B</m:mi><m:mo>→</m:mo><m:mi>f</m:mi><m:mi>@</m:mi></m:mtd></m:mtr></m:mtable></m:mrow></m:math>
</div>
<p>might result in the following sequence of rewriting steps demonstrated in <a href="C21_chapter16.xhtml#f16_27">Figure 16.27</a>:</p>
<div class="disp-formula">
<m:math xmlns:mml="http://www.w3.org/1998/Math/MathML"><m:mrow><m:mtable columnalign="left"><m:mtr><m:mtd><m:mi>S</m:mi><m:mo>↦</m:mo><m:mi>A</m:mi><m:mo>↦</m:mo><m:mo>[</m:mo><m:mo>+</m:mo><m:mi>B</m:mi><m:mo>]</m:mo><m:mi>f</m:mi><m:mi>A</m:mi><m:mo>↦</m:mo><m:mo>[</m:mo><m:mo>+</m:mo><m:mi>f</m:mi><m:mi>B</m:mi><m:mo>]</m:mo><m:mi>f</m:mi><m:mo>[</m:mo><m:mo>+</m:mo><m:mi>B</m:mi><m:mo>]</m:mo><m:mi>f</m:mi><m:mi>A</m:mi><m:mo>↦</m:mo></m:mtd></m:mtr><m:mtr><m:mtd><m:mo>[</m:mo><m:mo>+</m:mo><m:mi>f</m:mi><m:mi>f</m:mi><m:mi>@</m:mi><m:mo>]</m:mo><m:mi>f</m:mi><m:mo>[</m:mo><m:mo>+</m:mo><m:mi>f</m:mi><m:mi>B</m:mi><m:mo>]</m:mo><m:mi>f</m:mi><m:mi>B</m:mi><m:mo>↦</m:mo><m:mo>[</m:mo><m:mo>+</m:mo><m:mi>f</m:mi><m:mi>f</m:mi><m:mi>@</m:mi><m:mo>]</m:mo><m:mi>f</m:mi><m:mo>[</m:mo><m:mo>+</m:mo><m:mi>f</m:mi><m:mi>f</m:mi><m:mi>@</m:mi><m:mo>]</m:mo><m:mi>f</m:mi><m:mi>f</m:mi><m:mi>@</m:mi><m:mn>.</m:mn></m:mtd></m:mtr></m:mtable></m:mrow></m:math>
</div>
<figure id="f16_27" tabindex="0">
<img alt="" src="../images/fig16_27.jpg"/>
<figcaption><p><span class="blue">Figure 16.27.</span> Consecutive derivation steps using a simple L-system. Capital letters denote nonterminals and illustrate positions at which corresponding nonterminal will be expanded. They are not part of the actual output.</p></figcaption>
</figure>
<p class="noindent1">As shown above, there are typically many different productions for the same nonterminal allowing the generation of many different objects with the same grammar. The choice of which rule to apply can depend on which symbols are located next to the one being replaced (context-sensitivity) or can be performed at random with some assigned probability for each rule (stochastic L-systems). More complex rules can model interaction with the environment, such as pruning to a particular shape, and parameters can be associated with symbols to control geometric commands issued.</p>
<p>L-systems already capture plant topology changes with time: each intermediate string obtained in the rewriting process can be interpreted as a “younger” version of the plant (see <a href="C21_chapter16.xhtml#f16_27">Figure 16.27</a>). For more significant changes, different productions can be in effect at different times allowing the structure of the plant to change significantly as it grows. A young tree, for example, produces a lot of new branches, while an older one branches only moderately.</p>
<p>Very realistic plant models have been created with L-systems. However, as with most procedural techniques, one needs some experience to meaningfully apply existing L-systems, and writing new grammars to capture some desired effect is certainly not easy.</p>
</section>
<section>
<h2 id="sec16_7"><a id="index_term210"/><a epub:type="backlink" href="C02a_toc.xhtml#rsec16_7" role="doc-backlink"><span class="green">16.7 Groups of Objects</span></a></h2>
<p>To animate <a id="index_term214"/>multiple objects one can, of course, simply apply standard techniques described in this chapter so far to each of them. This works reasonably well for a moderate number of independent objects whose desired motion is known in <a id="term-161"/><a id="term-164"/><span aria-label="456" epub:type="pagebreak" id="pg_456" role="doc-pagebreak"/>advance. However, in many cases, some kind of coordinated action in a dynamic environment is necessary. If only a few objects are involved, the animator can use an artificial intelligence (AI)-based system to automatically determine immediate tasks for each object based on some high-level goal, plan necessary motion, and execute the plan. Many modern games use such <em>autonomous objects</em> to create smart monsters or player’s collaborators.</p>
<p>Interestingly, as the number of objects in a group grows from just a few to several dozens, hundreds, and thousands, individual members of a group must have only very limited “intelligence” in order for the group as a whole to exhibit what looks like coordinated goal-driven motion. It turns out that this <em><a id="index_term208"/>flocking</em>is <em>emergent behavior</em> which can arise as a result of limited interaction of group members with just a few of their closest neighbors (Reynolds, 1987). Flocking should be familiar to anyone who has observed the fascinatingly synchronized motion of a flock of birds or a school of fish. The technique can also be used to control groups of animals moving over terrain or even a human crowd.</p>
<p>At any given moment, the motion of a member of a group, often called boid when applied to flocks, is the result of balancing several often contradictory tendencies, each of which suggests its own velocity vector (see <a href="C21_chapter16.xhtml#f16_28">Figure 16.28</a>). First, there are external physical forces <em>F</em> acting on the boid, such as gravity or wind. New velocity due to those forces can be computed directly through <a id="index_term774"/>Newton’s law as</p>
<figure id="f16_28" tabindex="0">
<img alt="" src="../images/fig16_28.jpg"/>
<figcaption><p><span class="blue">Figure 16.28.</span> (Left) Individual flock member (boid) can experience several urges of different importance (shown by line thickness) which have to be negotiated into a single velocity vector. A boid is aware of only its limited neighborhood (circle). (Right) <a id="index_term205"/>Boid control is commonly implemented as three separate modules.</p></figcaption>
</figure>
<div class="disp-formula">
<m:math xmlns:mml="http://www.w3.org/1998/Math/MathML"><m:mrow><m:msubsup><m:mrow><m:mi>v</m:mi></m:mrow><m:mrow><m:mi>n</m:mi><m:mi>e</m:mi><m:mi>w</m:mi></m:mrow><m:mrow><m:mi>p</m:mi><m:mi>h</m:mi><m:mi>y</m:mi><m:mi>s</m:mi><m:mi>i</m:mi><m:mi>c</m:mi><m:mi>s</m:mi></m:mrow></m:msubsup><m:mo>=</m:mo><m:msub><m:mrow><m:mtext>v</m:mtext></m:mrow><m:mrow><m:mi>o</m:mi><m:mi>l</m:mi><m:mi>d</m:mi></m:mrow></m:msub><m:mo>+</m:mo><m:mtext>F</m:mtext><m:mi mathvariant="normal">Δ</m:mi><m:mi>t</m:mi><m:mo>/</m:mo><m:mi>m</m:mi><m:mn>.</m:mn></m:mrow></m:math>
</div>

<p><span aria-label="457" epub:type="pagebreak" id="pg_457" role="doc-pagebreak"/>Second, a boid should react to global environment and to the behavior of other group members. Collision avoidance is one of the main results of such interaction. It is crucial for flocking that each group member has only limited field of view, and therefore is aware only of things happening within some neighborhood of its current position. To avoid objects in the environment, the simplest, if imperfect, strategy is to set up a limited extent repulsive force field around each such object. This will create a second desired velocity vector <span class="inline-formula"><m:math display="inline"><m:mrow><m:msubsup><m:mrow><m:mi mathvariant="bold">v</m:mi></m:mrow><m:mrow><m:mi>n</m:mi><m:mi>e</m:mi><m:mi>w</m:mi></m:mrow><m:mrow><m:mi>c</m:mi><m:mi>o</m:mi><m:mi>l</m:mi><m:mo>−</m:mo><m:mi>a</m:mi><m:mi>v</m:mi><m:mi>o</m:mi><m:mi>i</m:mi><m:mi>d</m:mi></m:mrow></m:msubsup></m:mrow></m:math></span>, also given by <a id="index_term775"/>Newton’s law. Interaction with other group members can be modeled by simultaneously applying different steering behaviors resulting in several additional desired velocity vectors <span class="inline-formula"><m:math display="inline"><m:mrow><m:msubsup><m:mrow><m:mi mathvariant="bold">v</m:mi></m:mrow><m:mrow><m:mi>n</m:mi><m:mi>e</m:mi><m:mi>w</m:mi></m:mrow><m:mrow><m:mi>s</m:mi><m:mi>t</m:mi><m:mi>e</m:mi><m:mi>e</m:mi><m:mi>r</m:mi></m:mrow></m:msubsup></m:mrow></m:math></span>. Moving away from neighbors to avoid crowding, steering toward flock mates to ensure flock cohesion, and adjusting a boid’s speed to align with average heading of neighbors are most common. Finally, some additional desired velocity vectors <span class="inline-formula"><m:math display="inline"><m:mrow><m:msubsup><m:mrow><m:mi mathvariant="bold">v</m:mi></m:mrow><m:mrow><m:mi>n</m:mi><m:mi>e</m:mi><m:mi>w</m:mi></m:mrow><m:mrow><m:mi>g</m:mi><m:mi>o</m:mi><m:mi>a</m:mi><m:mi>l</m:mi></m:mrow></m:msubsup></m:mrow></m:math></span> are usually applied to achieve needed global goals. These can be vectors along some path in space, following some specific designated leader of the flock, or simply representing migratory urge of a flock member.</p>
<p>Once all <strong>v</strong><em><sub>new</sub></em> are determined, the final desired vector is negotiated based on priorities among them. Collision avoidance and velocity matching typically have higher priority. Instead of simple averaging of desired velocity vectors which can lead to cancellation of urges and unnatural “moving nowhere” behavior, an acceleration allocation strategy is used. Some fixed total amount of acceleration is made available for a boid and fractions of it are being given to each urge in order of priority. If the total available acceleration runs out, some lower priority urges will have less effect on the motion or be completely ignored. The hope is that once the currently most important task (collision avoidance in most situations) is accomplished, other tasks can be taken care of in near future. It is also important to respect some physical limitations of real objects, for example, clamping too high accelerations or speeds to some realistic values. Depending on the internal complexity of the flock member, the final stage of animation might be to turn the negotiated velocity vector into a specific set of parameters (bird’s wing positions, orientation of plane model in space, leg skeleton bone configuration) used to control a boid’s motion. A diagram of a system implementing flocking is shown on <a href="C21_chapter16.xhtml#f16_28">Figure 16.28</a> (right).</p>
<figure id="f16_29" tabindex="0">
<img alt="" src="../images/fig16_29.jpg"/>
<figcaption><p><span class="blue">Figure 16.29.</span> After being emitted by a directional source, particles collide with an object and then are blown down by a local wind field once they clear the obstacle.</p></figcaption>
</figure>
<p>A much simpler, but still very useful, version of group control is implemented by <em><a id="index_term216"/>particle systems</em> (Reeves, 1983). The number of particles in a system is typically much larger than number of boids in a flock and can be in the tens or hundreds of thousands, or even more. Moreover, the exact number of particles can fluctuate during animation with new particles being born and some of the old ones destroyed at each step. Particles are typically completely independent from <a id="term-173"/><span aria-label="458" epub:type="pagebreak" id="pg_458" role="doc-pagebreak"/>each other, ignoring one’s neighbors and interacting with the environment only by experiencing external forces and collisions with objects, <em>not</em> through collision avoidance as was the case for flocks. At each step during animation, the system first creates new particles with some initial parameters, terminates old ones, and then computes necessary forces and updates velocities and positions of the remaining particles according to <a id="index_term776"/>Newton’s law.</p>
<p>All parameters of a particle system (number of particles, particle life span, initial velocity, and location of a particle, etc.) are usually under the direct control of the animator. Prime applications of particle systems include modeling fireworks, explosions, spraying liquids, smoke and fire, or other fuzzy objects and phenomena with no sharp boundaries. To achieve a realistic appearance, it is important to introduce some randomness to all parameters, for example, having a random number of particles born (and destroyed) at each step with their velocities generated according to some distribution. In addition to setting appropriate initial parameters, controlling the motion of a particle system is commonly done by creating a specific force pattern in space–blowing a particle in a new direction once it reaches some specific location or adding a center of attraction, for example. One should remember that with all their advantages, simplicity of implementation and ease of control being the prime ones, particle systems typically do not provide the level of realism characteristic of true physics-based simulation of the same phenomena.</p>
</section>
<section>
<h2 id="sec66"><span class="green">Notes</span></h2>
<p>In this chapter we have concentrated on techniques used in 3D animation. There also exist a rich set of algorithms to help with 2D animation production and post-processing <span aria-label="459" epub:type="pagebreak" id="pg_459" role="doc-pagebreak"/>of images created by computer graphics rendering systems. These include techniques for cleaning up scanned-in artist drawings, feature extraction, automatic 2D in-betweening, colorization, image warping, enhancement and compositing, and many others.</p>
<p>One of the most significant developments in the area of computer animation has been the increasing power and availability of sophisticated animation systems. While different in their specific set of features, internal structure, details of user interface, and price, most such systems include extensive support not only for animation, but also for modeling and rendering, turning them into complete production platforms. It is also common to use these systems to create still images. For example, many images for figures in this section were produced using Maya software generously donated by Alias.</p>
<p>Large-scale animation production is an extremely complex process which typically involves a combined effort by dozens of people with different backgrounds spread across many departments or even companies. To better coordinate this activity, a certain production pipeline is established which starts with a story and character sketches, proceeds to record necessary sound, build models, and rig characters for animation. Once actual animation commences, it is common to go back and revise the original designs, models, and rigs to fix any discovered motion and appearance problems. Setting up lighting and material properties is then necessary, after which it is possible to start rendering. In most sufficiently complex projects, extensive postprocessing and compositing stages bring together images from different sources and finalize the product.</p>
<p>We conclude this chapter by reminding the reader that in the field of computer animation, any technical sophistication is secondary to a good story, expressive characters, and other artistic factors, most of which are hard or simply impossible to quantify. It is safe to say that Snow White and her seven dwarfs will always share the screen with green ogres and donkeys, and most of the audience will be much more interested in the characters and the story rather than in which, if any, computers (and in what exact way) helped to create them.</p>
</section>
</section>
</body>
</html>