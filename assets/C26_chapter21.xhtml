<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xmlns:m="http://www.w3.org/1998/Math/MathML" xmlns:svg="http://www.w3.org/2000/svg" dir="ltr" lang="en" xml:lang="en">
<head>
<meta charset="UTF-8"/>
<title>21 Implicit Modeling</title>
<link href="../styles/9781000426359.css" rel="stylesheet" type="text/css"/>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
jax: ["input/TeX","input/MathML","output/SVG"],
extensions: ["tex2jax.js","mml2jax.js","MathEvents.js"],
TeX: {
extensions: ["noErrors.js","noUndefined.js","autoload-all.js"]
},
MathMenu: {
showRenderer: false
},
menuSettings: {
zoom: "Click"
},
messageStyle: "none"
});
</script>
<script src="../mathjax/MathJax.js" type="text/javascript"/>
<meta content="urn:uuid:e0000000-0000-0000-0000-000006665500" name="Adept.expected.resource"/>
</head>
<body epub:type="bodymatter">
<section epub:type="chapter" role="doc-chapter">
<header>
<p class="chap-auz"><span class="green">Brian Wyvill</span></p>
<h1 class="chapz1" id="c21"><a id="term-424"/><a id="term-534"/><span aria-label="595" epub:type="pagebreak" id="pg_595" role="doc-pagebreak"/><a epub:type="backlink" href="C02a_toc.xhtml#rc21" role="doc-backlink"><span class="green"><span class="big1">21</span><br/>Implicit Modeling</span></a></h1>
</header>
<p class="noindent">Implicit modeling (also known as implicit surfaces) in computer graphics covers many different methods for defining models. These include <em>skeletal implicit modeling</em>, <em>offset surfaces</em>, <em>level sets</em>, <em>variational surfaces</em>, and <em>algebraic surfaces</em>. In this chapter, we briefly touch on these methods and describe how to build skeletal implicit models in more detail. Curves can be defined by implicit equations of the form</p>
<div class="disp-formula">
<m:math alttext=""><m:mrow><m:mi mathvariant="italic">f</m:mi><m:mi mathvariant="normal">(</m:mi><m:mi mathvariant="italic">x</m:mi><m:mi mathvariant="normal">,</m:mi><m:mi mathvariant="normal"/><m:mi mathvariant="italic">y</m:mi><m:mi mathvariant="normal">)</m:mi><m:mo>=</m:mo><m:mi mathvariant="normal">0</m:mi><m:mi mathvariant="normal">.</m:mi></m:mrow></m:math>
</div>
<p class="indent">If we consider a closed curve, such as a circle, with radius <em>r</em>, then the implicit equation can be written as</p>
<div class="disp-formula" id="equ21_1">
<m:math alttext=""><m:mrow><m:mi mathvariant="italic">f</m:mi><m:mi mathvariant="normal">(</m:mi><m:mi mathvariant="italic">x</m:mi><m:mi mathvariant="normal">,</m:mi><m:mi mathvariant="normal"/><m:mi mathvariant="italic">y</m:mi><m:mi mathvariant="normal">)</m:mi><m:mo>=</m:mo><m:msup><m:mrow><m:mi mathvariant="italic">x</m:mi></m:mrow><m:mrow><m:mi mathvariant="normal">2</m:mi></m:mrow></m:msup><m:mo>+</m:mo><m:msup><m:mrow><m:mi mathvariant="italic">y</m:mi></m:mrow><m:mrow><m:mi mathvariant="normal">2</m:mi></m:mrow></m:msup><m:mo>−</m:mo><m:msup><m:mrow><m:mi mathvariant="italic">r</m:mi></m:mrow><m:mrow><m:mi mathvariant="normal">2</m:mi></m:mrow></m:msup><m:mo>=</m:mo><m:mi mathvariant="normal">0</m:mi><m:mn>.</m:mn></m:mrow><m:mspace width="3em"/><m:mo>(21.1)</m:mo></m:math>
</div>
<p class="indent">The value of <em>f</em> (<em>x, y</em>) can be positive (outside the circle), negative (inside the circle), or zero for points precisely on the circle. The equivalent in three dimensions is a closed surface around a set of points that occupy a given volume or region of space. The volume forms a scalar field, i.e., we can compute a value for every point and as can be seen for the circle, the negative values are bounded by the implicit curve or surface. The surface can be visualized as a contour in the field, connecting points with a particular value such as zero (see Equation (21.1)). To compute such a surface implies searching through space to find the points that satisfy the implicit equation; this method is unlikely to lead to an efficient algorithm for circle drawing (and even less likely in three dimensions). This was perhaps the reason that algorithmic methods for modeling with parametric curves <a id="term-56"/><a id="term-427"/><a id="term-430"/><a id="term-431"/><a id="term-445"/><a id="term-803"/><a id="term-833"/><span aria-label="596" epub:type="pagebreak" id="pg_596" role="doc-pagebreak"/>and surfaces were investigated before implicit methods; however, there are some good reasons to develop algorithms to visualize implicit surfaces. In this chapter we explore the implications of deriving the data from a modeling process rather than from a scanner.</p>
<p class="indent">Despite the computational overhead of finding the implicit surface, designing with implicit modeling techniques offers some advantages over other modeling methods. Many geometric operations are simplified using implicit methods including:</p>
<ul class="list-bullet">
<li><p class="list">the definition of blends;</p></li>
<li><p class="list">the standard set operations (union, intersection, difference, etc.) of constructive solid geometry (CSG);</p></li>
<li><p class="list">functional composition with other <a id="index_term570"/>implicit functions (e.g., R-functions, Barthe blends, Ricci blends, and warping);</p></li>
<li><p class="list">inside/outside tests, (e.g., for collision detection).</p></li>
</ul>
<p class="noindent">Visualizing the surfaces can be done either by direct ray tracing using an algorithm as described in (Kalra &amp; Barr, 1989; Mitchell, 1990; Hart &amp; Baker, 1996; deGroot &amp; Wyvill, 2005) or by first converting to polygons (Wyvill, McPheeters, &amp; Wyvill, 1986).</p>
<p class="indent">One of the first methods was proposed by Ricci as far back as 1973 (Ricci, 1973), who also introduced CSG in the same paper. Jim <a id="index_term577"/>Blinn’s algorithm for finding contours in electron density fields, known as <em>Blobby molecules</em> (J. Blinn, 1982), Nishimura’s <em>Metaballs</em> (Nishimura et al., 1985) and Wyvills’ <em>Soft Objects</em> (Wyvill et al., 1986) were all early examples of implicit modeling methods. Jim Blinn’s <em>Blobby Man</em> (see <a href="C26_chapter21.xhtml#f21_1">Figure 21.1</a>) was the first rendering of a non-algebraic implicit model.</p>
<figure id="f21_1" tabindex="0">
<img alt="" src="../images/fig21_1.jpg"/>
<figcaption><p><span class="blue">Figure 21.1.</span> Blinn’s Blobby Man 1980. <em>Image courtesy Jim Blinn.</em></p></figcaption>
</figure>
<section>
<h2 id="sec21_1"><a id="index_term1093"/><a id="index_term1136"/><a epub:type="backlink" href="C02a_toc.xhtml#rsec21_1" role="doc-backlink"><span class="green">21.1 Implicit Functions, Skeletal Primitives, and Summation Blending</span></a></h2>
<p>In the context of modeling an <em>implicit</em> function is defined as a function <em>f</em> applied to a point <span class="inline-formula"><m:math alttext=""><m:mrow><m:mtext>p </m:mtext><m:mo>∈</m:mo><m:msup><m:mrow><m:mtext>ℍ</m:mtext></m:mrow><m:mrow><m:mn>3</m:mn></m:mrow></m:msup></m:mrow></m:math></span> yielding a scalar value <span class="inline-formula"><m:math alttext=""><m:mrow><m:mo>∈</m:mo><m:mi>ℝ</m:mi></m:mrow></m:math></span>.</p>
<p>The implicit function <em>f<sub>i</sub></em>(<em>x, y, z</em>) may be split into a distance function <em>d<sub>i</sub></em>(<em>x, y, z</em>) and a <em>fall-off filter function</em><a epub:type="noteref" href="C26_chapter21.xhtml#fn21_1" id="rfn21_1" role="doc-noteref"><sup>1</sup></a><em>g<sub>i</sub></em>(<em>r</em>), where <em>r</em> stands for the distance from the skeleton and the subscript refers to the <em>i</em>th skeletal element.</p>
<aside class="footnote" epub:type="footnote" role="doc-footnote"><p><a href="#rfn21_1" id="fn21_1"><sup>1</sup></a> These functions have been given many names by researchers in the past, e.g., <em>filter, potential, radial-basis, kernel</em>, but we use <em>fall-off filter</em> as a simple term to describe their appearance.</p></aside>
<p class="indent"><a id="term-422"/><a id="term-446"/><span aria-label="597" epub:type="pagebreak" id="pg_597" role="doc-pagebreak"/>We will use the following notation:</p>
<div class="disp-formula" id="equ21_2">
<m:math alttext=""><m:mrow><m:msub><m:mrow><m:mi mathvariant="italic">f</m:mi></m:mrow><m:mrow><m:mi mathvariant="italic">i</m:mi></m:mrow></m:msub><m:mi mathvariant="normal">(</m:mi><m:mi mathvariant="italic">x</m:mi><m:mi mathvariant="normal">,</m:mi><m:mi mathvariant="normal"/><m:mi mathvariant="italic">y</m:mi><m:mi mathvariant="normal">,</m:mi><m:mi mathvariant="normal"/><m:mi mathvariant="italic">z</m:mi><m:mi mathvariant="normal">)</m:mi><m:mo>=</m:mo><m:msub><m:mrow><m:mi mathvariant="italic">g</m:mi></m:mrow><m:mrow><m:mi mathvariant="italic">i</m:mi></m:mrow></m:msub><m:mtext> </m:mtext><m:mi>ο</m:mi><m:mtext> </m:mtext><m:msub><m:mrow><m:mi mathvariant="italic">d</m:mi></m:mrow><m:mrow><m:mi mathvariant="italic">i</m:mi></m:mrow></m:msub><m:mi mathvariant="normal">(</m:mi><m:mi mathvariant="italic">x</m:mi><m:mi mathvariant="normal">,</m:mi><m:mi mathvariant="normal"/><m:mi mathvariant="italic">y</m:mi><m:mi mathvariant="normal">,</m:mi><m:mi mathvariant="normal"/><m:mi mathvariant="italic">z</m:mi><m:mi mathvariant="normal">)</m:mi></m:mrow><m:mspace width="3em"/><m:mo>(21.2)</m:mo></m:math>
</div>
<p class="indent">A simple example is a point primitive, and we take the analogy of a star radiating heat into space. The field value (temperature in this example) may be measured at any point <em>p</em> and can be found by taking the distance from <em>p</em> to the center of the star and supplying the value to a fall-off <a id="index_term588"/>filter function similar to one of those given in <a href="C26_chapter21.xhtml#f21_2">Figure 21.2</a>. In these sample functions, the field is given a value of 1 at the center of the star; the value falls off with distance. The surface of a model may be derived from the implicit function <em>f</em> (<em>x, y, z</em>) as the points of space whose values are equal to some desired <em>iso-value</em> (iso); in the star example, a spherical shell for values of iso <em>∈</em> (0, 1).</p>
<figure id="f21_2" tabindex="0">
<img alt="" src="../images/fig21_2.jpg"/>
<figcaption><p><span class="blue">Figure 21.2.</span> Fall-off filter functions (0 ≤ <em>r</em> ≤ 1). (a) Blinn’s Gaussian or “Blobby” function; (b) Nishimura’s “Metaball” function; (c) Wyvill et al.’s “soft objects” function; (d) the Wyvill function.</p></figcaption>
</figure>
<p>In general, filter functions ( <em>g<sub>i</sub></em>) are chosen so that the field values are maximized on the skeleton and fall off to zero at some chosen distance from the skeleton. In the simple case where the resulting surfaces are blended together, the global field <em>f</em> (<em>x, y, z</em>) of an object, the implicit function, may be defined as</p>
<p>
<a id="term-444"/><span aria-label="598" epub:type="pagebreak" id="pg_598" role="doc-pagebreak"/>
</p>
<div class="disp-formula" id="equ21_3">
<m:math xmlns:mml="http://www.w3.org/1998/Math/MathML" alttext=""><m:mrow><m:mi mathvariant="italic">f</m:mi><m:mi mathvariant="normal">(</m:mi><m:mi mathvariant="italic">x</m:mi><m:mi mathvariant="normal">,</m:mi><m:mi mathvariant="normal"/><m:mi mathvariant="italic">y</m:mi><m:mi mathvariant="normal">,</m:mi><m:mi mathvariant="normal"/><m:mi mathvariant="italic">z</m:mi><m:mi mathvariant="normal">)</m:mi><m:mo>=</m:mo><m:munderover><m:mrow><m:mi mathvariant="normal">Σ</m:mi></m:mrow><m:mrow><m:mi>i</m:mi><m:mo>=</m:mo><m:mn>1</m:mn></m:mrow><m:mrow><m:mi>i</m:mi><m:mo>=</m:mo><m:mi>n</m:mi></m:mrow></m:munderover><m:msub><m:mrow><m:mi mathvariant="italic">f</m:mi></m:mrow><m:mrow><m:mi mathvariant="italic">i</m:mi></m:mrow></m:msub><m:mi mathvariant="normal">(</m:mi><m:mi mathvariant="italic">x</m:mi><m:mi mathvariant="normal">,</m:mi><m:mi mathvariant="normal"/><m:mi mathvariant="italic">y</m:mi><m:mi mathvariant="normal">,</m:mi><m:mi mathvariant="normal"/><m:mi mathvariant="italic">z</m:mi><m:mi mathvariant="normal">)</m:mi><m:mo>,</m:mo><m:mspace width="10.0em"/><m:mo>(21.3)</m:mo></m:mrow></m:math>
</div>
<p>where <em>n</em> skeletal elements contribute to the resulting field value. An example is shown in <a href="C26_chapter21.xhtml#f21_3">Figure 21.3</a> in which the field at any point (<em>x, y, z</em>) is calculated as in Equation (21.3).</p>
<figure id="f21_3" tabindex="0">
<img alt="" src="../images/fig21_3.jpg"/>
<figcaption><p><span class="blue">Figure 21.3.</span> Each column shows two point primitives approaching each other. From left to right: the fall-off filter functions used are Blobby, Metaball, soft objects, and Wyvill. <em>Image courtesy Erwin DeGroot</em>.</p></figcaption>
</figure>
<p>In this case, two point primitives are placed in close proximity. As the two points are brought together, the surfaces bulge and then blend together. The term <em>filter</em> function is used because the function causes the primitives to be blurred together somewhat akin to a filter function for images. The summation blend is the most compact and efficient blending operation that can be applied to implicit surfaces (see Equation (21.3)).</p>
<p>One advantage of using filter functions with finite support is that primitives that are far from <em>p</em> will have zero contribution and thus need not be considered (Wyvill et al., 1986).</p>
<section>
<h3 id="sec21_1_1"><a id="term-448"/><span aria-label="599" epub:type="pagebreak" id="pg_599" role="doc-pagebreak"/><span class="green">21.1.1 <em>C</em><sup>1</sup> Continuity and the Gradient</span></h3>
<p>The most basic form of continuity is <em>C</em><sup>0</sup> continuity, which ensures that there are no “jumps” in a function. Higher-order continuity is defined in terms of derivatives of functions (see <a href="C20_chapter15.xhtml#c15">Chapter 15</a>).</p>
<p>In the case of a 3D scalar field <em>f</em> , the first derivative is a vector function known as the <em>gradient</em>, written ▽<em>f</em> and defined as</p>
<div class="disp-formula">
<m:math alttext=""><m:mrow><m:mi>▽</m:mi><m:mi mathvariant="italic">f</m:mi><m:mi mathvariant="normal">(</m:mi><m:mi mathvariant="bold">p</m:mi><m:mi mathvariant="normal">)</m:mi><m:mi mathvariant="normal">=</m:mi><m:mo>{</m:mo><m:mfrac><m:mrow><m:mo>∂</m:mo><m:mi mathvariant="italic">f</m:mi><m:mi mathvariant="normal">(</m:mi><m:mi mathvariant="bold">p</m:mi><m:mi mathvariant="normal">)</m:mi></m:mrow><m:mrow><m:mo>∂</m:mo><m:mi mathvariant="italic">x</m:mi></m:mrow></m:mfrac><m:mi mathvariant="normal">,</m:mi><m:mi mathvariant="normal"/><m:mfrac><m:mrow><m:mo>∂</m:mo><m:mi mathvariant="italic">f</m:mi><m:mi mathvariant="normal">(</m:mi><m:mi mathvariant="bold">p</m:mi><m:mi mathvariant="normal">)</m:mi></m:mrow><m:mrow><m:mo>∂</m:mo><m:mi mathvariant="italic">y</m:mi></m:mrow></m:mfrac><m:mi mathvariant="normal">,</m:mi><m:mi mathvariant="normal"/><m:mfrac><m:mrow><m:mo>∂</m:mo><m:mi mathvariant="italic">f</m:mi><m:mi mathvariant="normal">(</m:mi><m:mi mathvariant="bold">p</m:mi><m:mi mathvariant="normal">)</m:mi></m:mrow><m:mrow><m:mo>∂</m:mo><m:mi mathvariant="italic">z</m:mi></m:mrow></m:mfrac><m:mo>}</m:mo><m:mi mathvariant="normal">.</m:mi></m:mrow></m:math>
</div>
<p class="indent">If ▽<em>f</em> is defined at all points, and the three one-dimensional partial derivatives are each <em>C</em><sup>0</sup>, then <em>f</em> is <em>C</em><sup>1</sup>. Informally, <em>C</em><sup>1</sup> surface continuity means that the <em>surface normal</em> varies smoothly over the surface. The surface normal is the unit vector perpendicular to the surface. If no unique surface normal can be defined on the edge of a cube, for example, then the surface is not <em>C</em><sup>1</sup>. For points on an implicit surface, the surface normal can be computed by normalizing the gradient vector ▽<em>f</em> . In the example of the circle, points inside have a negative value and those on the outside have a positive one. For many types of implicit surfaces, the sense of inside and outside is inverted, and since the normal vector must always point outward, it can be opposite to the gradient direction.</p>
<p>Skeletal implicit primitives are created by applying a fall-off filter function to an unsigned <a id="index_term586"/>distance field as in Equation (21.2). Although the distance field is never <em>C</em><sup>1</sup> at the skeleton, these discontinuities can be removed by using a suitable fall-off function (Akleman &amp; Chen, 1999). If an operator, <em>g</em>, combines implicit functions, <em>f</em><sub>1</sub> and <em>f</em><sub>2</sub>, where all points are <em>C</em><sup>1</sup>, then <em>g</em>(<em>f</em><sub>1</sub><em>,f</em><sub>2</sub>) is not necessarily <em>C</em><sup>1</sup>. For example, it is possible to make a sharp CSG junction using the min and max operators. The combination is <em>not</em> <em>C</em><sup>1</sup> continuous because the min and max operators don’t have that property (see <a href="C26_chapter21.xhtml#sec21_5">Section 21.5</a>).</p>
<p>The analysis of operators is complicated by the fact that it is sometimes desirable to create a <em>C</em><sup>1</sup> dis<a id="index_term581"/>continuity. This case occurs whenever a crease in the surface is desired. For example, a cube is not <em>C</em><sup>1</sup> because tangent discontinuities occur at each edge. To create creases using <em>C</em><sup>1</sup> primitives, the operator must introduce <em>C</em><sup>1</sup> discontinuities, and hence cannot be <em>C</em><sup>1</sup> itself.</p>
</section>
<section>
<h3 id="sec21_1_2"><a id="index_term599"/><a id="index_term587"/><span class="green">21.1.2 Distance Fields, R-Functions, and F-Reps</span></h3>
<p>The <em>distance field</em> is defined with respect to some geometric object <strong>T</strong>:</p>
<div class="disp-formula">
<m:math alttext=""><m:mrow><m:mtext>F</m:mtext><m:mi mathvariant="normal">(</m:mi><m:mi mathvariant="normal">T</m:mi><m:mi mathvariant="normal">,</m:mi><m:mi mathvariant="normal"/><m:mi mathvariant="bold">p</m:mi><m:mi mathvariant="normal">)</m:mi><m:mo>=</m:mo><m:munder><m:mrow><m:mstyle><m:mrow><m:mtext>min</m:mtext></m:mrow></m:mstyle></m:mrow><m:mrow><m:mi mathvariant="bold">q</m:mi><m:mo>∈</m:mo><m:mtext>T</m:mtext></m:mrow></m:munder><m:mo>|</m:mo><m:mi mathvariant="bold">q</m:mi><m:mo>−</m:mo><m:mi mathvariant="bold">p</m:mi><m:mo>|</m:mo><m:mn>.</m:mn></m:mrow></m:math>
</div>
<p>Visually, <strong>F</strong>(<strong>T</strong>, <strong>p</strong>) is the shortest distance from <strong>p</strong> to <strong>T</strong>.Hence, when <strong>p</strong> lies on <strong>T</strong>, <a id="term-62"/><span aria-label="600" epub:type="pagebreak" id="pg_600" role="doc-pagebreak"/><strong>F</strong>(<strong>T</strong>, <strong>p</strong>) = 0 and the surface created by the implicit function is the object <strong>T</strong>. Outside of <strong>T</strong>, a nonzero distance is returned. The function <strong>T</strong> can be any geometric entity embedded in 3D—a point, curve, surface, or solid. Procedural modeling with distance fields started with Ricci (Ricci, 1973); <em>R-functions</em> (Rvachev, 1963) were first applied to shape modeling more than 20 years later (see (Shapiro, 1994) and (A. Pasko, Adzhiev, Sourin, &amp; Savchenko, 1995)).</p>
<p>An R-function or Rvachev function is a function whose sign can change if and only if the sign of one of its arguments changes; that is, its sign is determined solely by its arguments. R-functions provide a robust theoretical framework for boolean composition of real functions, permitting the construction of <em>C<sup>n</sup></em> CSG operators (Shapiro, 1988). These CSG operators can be used to create blending operators simply by adding a fixed offset to the result (A. Pasko et al., 1995). Although these <a id="index_term88"/>blending functions are no longer technically R-functions, they have most of the desirable properties and can be mixed freely with R-functions to create complex hierarchical models (Shapiro, 1988). These R-function-based blending and CSG operators are referred to as <em><a id="index_term600"/>R-operators</em> (see <a href="C26_chapter21.xhtml#sec21_4">Section 21.4</a>). The Hyperfun system (Adzhiev et al., 1999) is based on <em>F-reps</em> (function representation), another name for an implicit surface. The system uses a procedural C-like language to describe many types of implicit surfaces.</p>
</section>
<section>
<h3 id="sec21_1_3"><a id="index_term594"/><span class="green">21.1.3 Level Sets</span></h3>
<p>It is useful to represent an implicit field discretely via a regular grid (Barthe, Mora, Dodgson, &amp; Sabin, 2002) or an adaptive grid (Frisken, Perry, Rockwood, &amp; Jones, 2000). This is exactly what the polygonization algorithm does in the case of <em>level sets</em>; moreover, the grid can be used for various other purposes besides building polygons. Discrete representations of <em>f</em> are commonly obtained by sampling a continuous function at regular intervals. For example, the sampled function may be defined by other volume model representations (V. V. Savchenko, Pasko, Sourin, &amp; Kunii, 1998). The data may also be a physical object sampled using three-dimensional imaging techniques. Discrete volume data has most often been used in conjunction with the <em>level sets</em> method (Osher &amp; Sethian, 1988), which defines a means for dynamically modifying the data structure using curvature-dependent speed functions. Interactive modeling environments based on <em>level sets</em> have been defined (Museth, Breen, Whitaker, &amp; Barr, 2002), although level sets are only one method employing a discrete representation of the implicit field. Methods for interactively defining discrete representations using standard implicit surfaces techniques have also been explored (Baerentzen &amp; Christensen, 2002).</p>
<p>A key advantage to employing a discrete data structure is its ability to act as a unifying approach for all of the various volume models defined by potential <span aria-label="601" epub:type="pagebreak" id="pg_601" role="doc-pagebreak"/>fields (discrete or not) (V. V. Savchenko et al., 1998). The conversion of any continuous function to a discrete representation introduces the problem of how to reconstruct a continuous function, needed for the combined purposes of additional modeling operations and visualization of the resulting potential field. A well-known solution to this problem is to apply a filter <em>g</em> using the convolution operator (see <a href="C14_chapter9.xhtml#c9">Chapter 9</a>). The choice of a filter is guided by the desired properties of the reconstruction, and many filters have been explored (Marschner &amp; Lobb, 1994). The salient point is that there is typically a tradeoff between the efficiency of the chosen filter and the smoothness of the resulting reconstruction; see also <a href="C26_chapter21.xhtml#sec21_9">Section 21.9</a>.</p>
<p>To be interactive, a discrete system must restrict the size of the grid relative to the available computing power. This, in turn, limits the ability of the modeler to include high-frequency details. Additionally, the smoothing triquadratic filter makes it impossible to include sharp edges, should they be desired. A partial solution to this problem is the use of adaptive grids, although with any discrete representation there will be limitations. A discrete grid is used in (Schmidt, Wyvill, &amp; Galin, 2005) to act as a cache representing a <em>BlobTree</em> node. The grid in this work is used for fast prototyping and uses trilinear interpolation for position and the slower, more accurate triquadratic interpolation to calculate gradient values, because the eye is more discerning in observing gradient errors than position errors.</p>
</section>
<section>
<h3 id="sec21_1_4"><a id="index_term592"/><span class="green">21.1.4 Variational Implicit Surfaces</span></h3>
<p>It is often required to convert sampled data to an implicit representation. Variational implicit surfaces interpolate or approximate a set of points using a weighted sum of globally supported basis functions (V. Savchenko, Pasko, Okunev, &amp; Kunii, 1995; Turk &amp; O’Brien, 1999; Carr et al., 2001; Turk &amp; O’Brien, 2002). These radially symmetric basis functions are applied at each sample point. The continuity of such a surface depends on the choice of basis function. The <em>C</em><sup>2</sup> thin-plate spline is most commonly used (Turk &amp; O’Brien, 2002; Carr et al., 2001). Like Blinn’s exponential function (see <a href="C26_chapter21.xhtml#f21_2">Figure 21.2</a>), this function is unbounded as is the resulting variational implicit surface.</p>
<p>If the field is is globally <em>C</em><sup>2</sup>, creases cannot be defined;<a epub:type="noteref" href="C26_chapter21.xhtml#fn21_2" id="rfn21_2" role="doc-noteref"><sup>2</sup></a> however, anisotropic basis functions can be used to produce fields which change more rapidly and may appear to have creases (Dinh, Slabaugh, &amp; Turk, 2001). At the appropriate scale, the surface is still smooth. The smooth field implies that self-intersections do not <a id="term-437"/><span aria-label="602" epub:type="pagebreak" id="pg_602" role="doc-pagebreak"/>occur, and hence volumes are always well-defined. The thin-plate spline guarantees that global curvature is minimized (Duchon, 1977). Variational interpolation has many properties which are desirable for 3D modeling; however, controlling the resulting surfaces can be difficult.</p>
<aside class="footnote" epub:type="footnote" role="doc-footnote"><p><a href="#rfn21_2" id="fn21_2"><sup>2</sup></a> Except see <a href="C20_chapter15.xhtml#sec15_2">Section 15.2</a>.</p></aside>
<p class="indent">Variational implicit surfaces can also be based on compactly supported radial basis functions (CS-RBFs) to reduce the computational cost of variational interpolation techniques (Morse, Yoo, Rheingans, Chen, &amp; Subramanian, 2001). Each CS-RBF only influences a local region, so computing <em>f</em> (<strong>p</strong>) requires only evaluation of basis functions within some small neighborhood of <strong>p</strong>. As with the globally supported counterpart, the resulting field is <em>C<sup>k</sup></em>, creases are not supported, and self-intersections cannot occur.<a epub:type="noteref" href="C26_chapter21.xhtml#fn21_3" id="rfn21_3" role="doc-noteref"><sup>3</sup></a> The local support of each basis function results in a bounded global field. This also guarantees that additional iso-contours will be present, as noted by various researchers (Ohtake, Belyaev, &amp; Pasko, 2003; Reuter, 2003).</p>
</section>
<section>
<h3 id="sec21_1_5"><a id="index_term582"/><span class="green">21.1.5 Convolution Surfaces</span></h3>
<p>Convolution surfaces, introduced by Bloomenthal and Shoemake (Bloomenthal &amp; Shoemake, 1991) are produced by convolving a geometric skeleton <span class="monospace">S</span> with a <em>kernel</em> function <em>h</em>. Hence, the value at any position in space is defined by an integral over the skeleton:</p>
<div class="disp-formula">
<m:math alttext=""><m:mrow><m:mi>f</m:mi><m:mo>(</m:mo><m:mi mathvariant="bold">p</m:mi><m:mo>)</m:mo><m:mo>=</m:mo><m:msub><m:mrow><m:mo>∫</m:mo></m:mrow><m:mrow><m:mtext>S</m:mtext></m:mrow></m:msub><m:mi>g</m:mi><m:mo>(</m:mo><m:mi mathvariant="bold">r</m:mi><m:mo>)</m:mo><m:mtext> </m:mtext><m:mi>h</m:mi><m:mo>(</m:mo><m:mi mathvariant="bold">p</m:mi><m:mo>−</m:mo><m:mi>r</m:mi><m:mo>)</m:mo><m:mi>d</m:mi><m:mi mathvariant="bold">r</m:mi><m:mn>.</m:mn></m:mrow></m:math>
</div>
<p>Any finitely supported function can be used as <em>h</em>; see (Sherstyuk, 1999) for a detailed analysis of different kernels.</p>
<p>Like skeletal primitives, convolution surfaces have bounded fields. Blinn’s “Blobby molecules” is the simplest form of a convolution surface (J. Blinn, 1982); in this case, the skeleton consists of points only. This idea was extended by Bloomenthal to include line, arc, triangle, and polygon skeletons (Bloomenthal &amp; Shoemake, 1991). These represent 1<em>D</em> and 2<em>D</em> primitives; 3<em>D</em> primitives were later described by Bloomenthal (Bloomenthal, 1995).</p>
<p>Combination of convolution surfaces is defined by composition of the underlying geometric skeletons and has the advantage of eliminating the bulges that tend to occur when composing multiple skeletal primitives with additive blending. The surface resulting from convolution of the combined skeleton does not have bulges, as in <a href="C26_chapter21.xhtml#f21_4">Figure 21.4</a>, and the field is continuous even if the combined skeleton <a id="term-438"/><a id="term-455"/><a id="term-804"/><span aria-label="603" epub:type="pagebreak" id="pg_603" role="doc-pagebreak"/>is nonconvex. Convolution surfaces are offset a fixed distance from convex portions of a skeleton, but produce a fillet along concave portions of a skeleton.</p>
<aside class="footnote" epub:type="footnote" role="doc-footnote"><p><a href="#rfn21_3" id="fn21_3"><sup>3</sup></a> Note, <em>k &gt;</em> 0 depending on the RBF (see <a href="C20_chapter15.xhtml#sec15_2">Section 15.2</a>).</p></aside>
<figure id="f21_4" tabindex="0">
<img alt="" src="../images/fig21_4.jpg"/>
<figcaption><p><span class="blue">Figure 21.4.</span> Two blended cylinders. Left: summation blend; right: convolution surface with barely discernible bulge (Bloomenthal, 1997). <em>Image courtesy Erwin DeGroot</em>.</p></figcaption>
</figure>
<p>An example of skeletal elements convolved to build a complex model is shown in <a href="C26_chapter21.xhtml#f21_5">Figure 21.5</a>. The hand model contains fourteen primitives.</p>
<figure id="f21_5" tabindex="0">
<img alt="" src="../images/fig21_5.jpg"/>
<figcaption><p><span class="blue">Figure 21.5.</span> Skeletal elements convolved to build a hand model. <em>Image courtesy Jules Bloomenthal.</em></p></figcaption>
</figure>
</section>
<section>
<h3 id="sec21_1_6"><span class="green">21.1.6 Defining Skeletal Primitives</span></h3>
<p>As we will see in the following sections rendering the implicit models requires finding the field value and gradient for a large number of points. We need the distance to supply to Equation (21.2) and the gradient is useful for root finding as well as lighting calculations. Supplying the distance to the fall-off filter functions of <a href="C26_chapter21.xhtml#f21_2">Figure 21.2</a> is a matter of calculating the nearest distance to the skeletal primitive, simple for point primitives but a little trickier for more complex geometrical shapes. A line segment primitive ( <em>AB</em>) can be defined as a cylinder around a line with hemispherical end caps (see <a href="C26_chapter21.xhtml#f21_6">Figure 21.6</a>). Point <em>P</em><sub>0</sub> lies on the surface where <em>f</em> (<em>P</em><sub>0</sub>) = iso and <em>f</em> (<em>P</em><sub>1</sub>) = 0 since it lies outside of the influence of the line primitive. The distance from some <em>P<sub>i</sub></em> to the line is found by simply projecting onto the line <em>AB</em> and calculating the perpendicular distance, e.g., <em>|CP</em><sub>0</sub><em>|</em>; this can be found <a id="term-454"/><a id="term-700"/><a id="term-701"/><a id="term-727"/><a id="term-998"/><span aria-label="604" epub:type="pagebreak" id="pg_604" role="doc-pagebreak"/>from <em>AC</em>, since <em>A, P</em><sub>0</sub><em>,</em> and <em>B</em>, are all known:</p>
<figure id="f21_6" tabindex="0">
<img alt="" src="../images/fig21_6.jpg"/>
<figcaption><p><span class="blue">Figure 21.6.</span> Line primitive <em>ab</em> and example points <em>p</em><sub>0</sub>, <em>p</em><sub>1</sub>, <em>p</em><sub>2</sub> showing distance calculation.</p></figcaption>
</figure>
<div class="disp-formula">
<m:math xmlns:mml="http://www.w3.org/1998/Math/MathML" alttext=""><m:mrow><m:mover><m:mrow><m:mi>A</m:mi><m:mi mathvariant="italic">C</m:mi></m:mrow><m:mrow><m:mo>→</m:mo></m:mrow></m:mover><m:mo>=</m:mo><m:mover><m:mrow><m:mi mathvariant="italic">A</m:mi><m:mi>B</m:mi></m:mrow><m:mrow><m:mo>→</m:mo></m:mrow></m:mover><m:mfrac><m:mrow><m:mover><m:mrow><m:mi>A</m:mi><m:msub><m:mrow><m:mi>P</m:mi></m:mrow><m:mrow><m:mn>0</m:mn></m:mrow></m:msub></m:mrow><m:mrow><m:mo>→</m:mo></m:mrow></m:mover><m:mo>⋅</m:mo><m:mover><m:mrow><m:mi>A</m:mi><m:mi>B</m:mi></m:mrow><m:mrow><m:mo>→</m:mo></m:mrow></m:mover></m:mrow><m:mrow><m:mo>|</m:mo><m:mo>|</m:mo><m:msup><m:mrow><m:mi>A</m:mi><m:mi>B</m:mi><m:mo>|</m:mo><m:mo>|</m:mo></m:mrow><m:mrow><m:mn>2</m:mn></m:mrow></m:msup></m:mrow></m:mfrac><m:mi mathvariant="normal">.</m:mi></m:mrow></m:math>
</div>
<p>In <a href="C26_chapter21.xhtml#f21_6">Figure 21.6</a>, the field value of <em>P</em><sub>2</sub><em>&gt;</em> 0,since <em>P</em><sub>2</sub> is in the hemispherical endcap, which can be checked separately. Variations of this idea can define primitives with endcaps of different radii producing interesting cone shapes. An example is shown in <a href="C26_chapter21.xhtml#f21_7">Figure 21.7</a>.</p>
<figure id="f21_7" tabindex="0">
<img alt="" src="../images/fig21_7.jpg"/>
<figcaption><p><span class="blue">Figure 21.7.</span> Cylinder primitive blended with a sphere. <em>Image courtesy Erwin DeG-root</em>.</p></figcaption>
</figure>
<p>A great variety of geometrical skeletons have been described, and, in principle, it is simply a matter of defining the distance to the skeleton from some point <strong>p</strong> and also the gradient at <strong>p</strong>. For example, an offset surface of a triangle can be defined from the vertices of the triangle and a radius <em>r</em>. A simple way to implement this is to use line segment primitives to describe bounding cylinders connecting the vertices (radius <em>r</em>). The distance from a point <strong>q</strong> within the triangle that does not fall within the bounding fields of one of the line segment primitives is returned as the perpendicular distance to the plane of the triangle. Other examples include an implicit disk, defined by a circle and a thickness parameter, a torus also defined by a circle and the radius of the cross section (or inner and outer circle radii), a circular cone from a disk and a height, a cube with rounded corners, etc. (see <a href="C26_chapter21.xhtml#f21_8">Figure 21.8</a>).</p>
<figure id="f21_8" tabindex="0">
<img alt="" src="../images/fig21_8.jpg"/>
<figcaption><p><span class="blue">Figure 21.8.</span> Implicit models from various skeletal primitives. <em>Image courtesy ErwinDeGroot</em>.</p></figcaption>
</figure>
</section>
</section>
<section>
<h2 id="sec21_2"><a id="index_term601"/><a epub:type="backlink" href="C02a_toc.xhtml#rsec21_2" role="doc-backlink"><span class="green">21.2 Rendering</span></a></h2>
<p>Modeling methods, such as parametric surfaces, lend themselves to visualization, since it is easy to iterate over points on the surface that can be found directly from the defining equations; for example (<em>x, y</em>) = (cos<em>θ,</em> sinθ)<em>, θ∈</em> [0, 2π) produces a circle.</p>
<p>There are two techniques that are commonly used to render implicit surfaces: ray tracing and surface tiling. In practice, a designer wants to visualize an implicit surface model quickly, sacrificing quality for speed for interaction purposes. Prototyping algorithms have been concerned with producing a polygon mesh that can be rendered in real time on modern workstations. Finding the polygonal mesh which best approximates the desired surface is referred to as <em>polygonization</em> or <em>surface tiling</em>. For animation or for a final visualization, where quality is preferred over speed, ray tracing implicit surfaces directly without first polygonizing produces excellent results.</p>
<figure id="f21_9" tabindex="0">
<img alt="" src="../images/fig21_9.jpg"/>
<figcaption><p><span class="blue">Figure 21.9.</span> A ray-traced dinosaur model showing the underlying skeletal primitives. <em>Image courtesy Erwin DeG-root</em>.</p></figcaption>
</figure>
<p>As previously mentioned, finding an implicit surface requires searching through space to find the points that satisfy, <em>f</em> (<strong>p</strong>) = 0. There are two main approaches to executing such a search: space partitioning—partitioning space into <span aria-label="605" epub:type="pagebreak" id="pg_605" role="doc-pagebreak"/>manageable units such as cubes, and non-<a id="index_term604"/><a id="index_term1104"/>space partitioning, e.g., marching triangles (Hartmann, 1998; Akkouche &amp; Galin, 2001) and the shrinkwrap algorithm (van Overveld &amp; Wyvill, 2004).</p>
<p>In this chapter, we describe the original space partitioning algorithm and leave it to the reader to explore the more advanced methods. This algorithm together with postprocessing for mesh refinement (see <a href="C17_chapter12.xhtml#c12">Chapter 12</a>) and caching provide a method for interactive viewing of implicit models on modern workstations.</p>
</section>
<section>
<h2 id="sec21_3"><a epub:type="backlink" href="C02a_toc.xhtml#rsec21_3" role="doc-backlink"><span class="green">21.3 Space Partitioning</span></a></h2>
<section>
<h3 id="sec21_3_1"><span class="green">21.3.1 Exhaustive Search</span></h3>
<p>The basic cubic space partitioning algorithm for tiling implicit surfaces was first published in (Wyvill et al., 1986) and a similar algorithm oriented toward volume visualization, called marching cubes in (Lorensen &amp; Cline, 1987). Since then there have been many refinements and extensions.</p>
<p>A first approach to finding the implicit surface might be to subdivide space uniformly into a regular <a id="index_term664"/>lattice of cubic cells and calculate a value for every vertex. Each cell is replaced with a set of polygons that best approximates the part of the surface contained within that cell. The problem with this method is that many of the cells will be completely outside or completely inside the volume; thus, many cells that contain no part of the surface are processed. For large grids of data this can be very time consuming and memory intensive.</p>
<p>To avoid storing the whole grid, a hash table is used to store only the cubes that contain a piece of the surface, based on the data structures used in (Wyvill et al., 1986). Working software was published in <em>Graphics Gems IV</em> (Bloomenthal, 1990). The algorithm is based on <em>numerical continuation</em>; it starts with a seed cube that intersects part of the surface and builds neighboring cubes as necessary to follow the surface.</p>
<p>The algorithm has two parts. In the first part, cubic cells are found that contain the surface and in the second part, each cube is replaced by triangles. The first part of the algorithm is driven by a queue of cubes, each of which contains part of the surface; the second part of the algorithm is table-driven.</p>
</section>
<section>
<h3 id="sec21_3_2"><a id="index_term573"/><span class="green">21.3.2 Algorithm Description</span></h3>
<p>A fast overview of the algorithm is as follows:</p>
<ul class="list-bullet">
<li>
<p class="list">divide space into cubic voxels;</p>
</li>
<li>
<p class="list">search for surface, starting from a skeletal element;</p>
</li>
<li>
<p class="list"><span aria-label="606" epub:type="pagebreak" id="pg_606" role="doc-pagebreak"/>add voxel to queue, mark it visited;</p>
</li>
<li>
<p class="list">search neighbors;</p>
</li>
<li>
<p class="list">when done, replace voxel with polygons.</p>
</li>
</ul>
<p>First, space is subdivided into a cubic lattice, and the next task is to find a seed cube containing part of the surface. A cube vertex <em>v<sub>i</sub></em> inside the surface will have a field value <em>v<sub>i</sub>&gt;</em>= iso and a vertex outside the surface will have a field value <em>v<sub>i</sub>&lt;</em> iso; thus, an edge with one of each type of vertex will intersect the surface. We call this an <em>intersecting</em> edge. The field value at the nearest cube vertex to the first primitive can be evaluated by summing the contributions of the primitives as per Equation (21.3), although other operators can also be used as will be seen later. We will assume that <em>f</em> (<em>v</em><sub>0</sub>)<em>&gt;</em> iso, which indicates that <em>v</em><sub>0</sub> lies within the solid. The value of iso is chosen by the user; an example is iso = 0<em>.</em>5 when using the <em>soft</em> fall-off function, which has some symmetry properties that lead to nice blending (see <a href="C26_chapter21.xhtml#f21_3">Figure 21.3</a>). The vertices along one axis are evaluated in turn until a value <em>v<sub>i</sub>&lt;</em> iso is found. The cube containing the <em>intersecting</em> edge is the seed cube.</p>
<p>The neighbors of the seed cube are examined, and those that contain at least one <em>intersecting</em> edge are added to the queue ready for processing. To process a cube, we examine each face. If any of the bounding edges have oppositely signed vertices, the surface will pass through that face and the face neighbor must be processed. When this process has been completed for all the faces, the second phase of the algorithm is applied to the cube. If the surface is closed, eventually a cube will be revisited and no more unmarked neighbors found, and the search algorithm will terminate. Processing a cube involves marking it as processed and processing its unmarked neighbors. Those that contain <em>intersecting</em> edges are processed until the entire surface has been covered (see <a href="C26_chapter21.xhtml#f21_10">Figure 21.10</a>).</p>
<figure id="f21_10" tabindex="0">
<img alt="" src="../images/fig21_10.jpg"/>
<figcaption><p><span class="blue">Figure 21.10.</span> A section through the cubic lattice. The <em>+</em> sign indicates a vertex inside the surface ( <em>f</em> ( <em>v</em><sub><em>i</em></sub> <em>≥</em> iso) and <em>-</em> is outside <em>f</em> ( <em>vi&lt;</em> iso).</p></figcaption>
</figure>
<p>Each cube is indexed by an <em>identifying vertex</em> which we define to be the lower-left far corner (i.e., the vertex with the lowest (<em>x, y, z</em>)-coordinate values (see <a href="C26_chapter21.xhtml#f21_11">Figure 21.11</a>)). For each vertex that is inside the surface, the corresponding bit will be set to form the address in an 8-bit table (see <a href="C26_chapter21.xhtml#f21_11">Figure 21.11</a> and <a href="C26_chapter21.xhtml#sec21_3_3">Section 21.3.3</a>).</p>
<figure id="f21_11" tabindex="0">
<img alt="" src="../images/fig21_11.jpg"/>
<figcaption><p><span class="blue">Figure 21.11.</span> Vertex numbering.</p></figcaption>
</figure>
<p>The identifying vertex is addressed by integers <em>i, j, k</em>, computed from the (<em>x, y, z</em>)-coordinate location of the cube such that <em>x</em> = side * <em>i</em>, etc., where side is the size of the cube. The identifying vertex of each cube may appear in as many as eight other cubes, and it would be inefficient to store these vertices more than once. Thus, the vertices are stored uniquely in a chained hash table. Since most of the space does not contain any part of the surface, only those cubes that are visited will be stored. The implicit function value is found for each vertex as it is stored in the hash table.</p>
<p><a id="term-63"/><a id="term-443"/><a id="term-494"/><span aria-label="607" epub:type="pagebreak" id="pg_607" role="doc-pagebreak"/>Nothing is known about the topology of the surface so a search must be started from every primitive to avoid any disconnected parts of the surface being missed. A scalar can be used to scale the influence of a primitive. If the scalar can be less than zero, then it is possible to search along an axis without finding an intersecting edge. In this case, a more sophisticated search must be done to find a seed cube (Galin &amp; Akkouche, 1999).</p>
<section>
<h4 id="sec72"><span class="blue">Data Structures</span></h4>
<p>The hash table entry holds five values:</p>
<ul class="list-bullet">
<li>
<p class="list">the <em>i, j, k</em> lattice indices of the identifying vertex (see <a href="C26_chapter21.xhtml#f21_11">Figure 21.11</a>);</p>
</li>
<li>
<p class="list"><em>f</em> , the implicit function value of the identifying vertex;</p>
</li>
<li>
<p class="list">Boolean to indicate whether this cube has been visited.</p>
</li>
</ul>
<p>The hash function computes an address in the hash table by selecting a few bits out of each of <em>i, j, k</em> and combining them arithmetically. For example, the five least significant bits produces a 15-bit address for a table, which must have a length <a id="term-440"/><span aria-label="608" epub:type="pagebreak" id="pg_608" role="doc-pagebreak"/>of 2<sup>15</sup>. Such a hash function can be neatly implemented in the C-preprocessor as follows:</p>
<pre class="pre">#define NBITS       5<br/>#define BMASK       037<br/>#define HASH(a,b,c) (((a&amp;BMASK)&lt;&lt;NBITS|b&amp;BMASK)<br/>                                     &lt;&lt;NBITS|c&amp;BMASK)<br/>#define HSIZE       1&lt;&lt;NBITS*3</pre>
<p>The queue (FIFO list) is used as temporary storage to identify the neighbors for processing. The algorithm begins with a seed cube that is marked as visited and placed on the queue. The first cube on the queue is dequeued and all its unvisited neighbors are added to the queue. Each cube is processed and passed to the second phase of the algorithm if it contains part of the surface. The queue is then processed until empty.</p>
</section>
</section>
<section>
<h3 id="sec21_3_3"><a id="index_term595"/><span class="green">21.3.3 Polygonization Algorithm</span></h3>
<p>The second phase of the algorithm treats each cube independently. The cell is replaced by a set of triangles that best matches the shape of the part of the surface that passes through the cell. The algorithm must decide how to polygonize the cell given the implicit function values at each vertex. These values will be positive or negative (i.e., less than or greater than the iso-value), giving 256 combinations of positive or negative vertices for the eight vertices of the cube. A table of 256 entries provides the right vertices to use in each triangle (<a href="C26_chapter21.xhtml#f21_12">Figure 21.12</a>). For example, entry 4(00000100) points to a second table that records the vertices that bound the <em>intersecting</em> edges. In this example, vertex number 2 is inside the surface ( <em>f</em> (<em>V</em> 2)<em>&gt;</em>= iso) and, therefore, we wish to draw a triangle that connects the points on the surface that intersect with edges bounded by ( <em>V</em> 2<em>,V</em> 0), ( <em>V</em> 2<em>,V</em> 3), and ( <em>V</em> 2<em>,V</em> 6) as shown in <a href="C26_chapter21.xhtml#f21_13">Figure 21.13</a>.</p>
<figure id="f21_12" tabindex="0">
<img alt="" src="../images/fig21_12.jpg"/>
<figcaption><p><span class="blue">Figure 21.12.</span> Table 2 contains the edges intersected by the surface. Table 1 points to the appropriate entry in Table 2.</p></figcaption>
</figure>
<section>
<h4 id="sec73"><a id="index_term584"/><span class="blue">Finding Cube-Surface Intersections</span></h4>
<p><a href="C26_chapter21.xhtml#f21_13">Figure 21.13</a> shows a cube where vertex <em>V</em><sub>2</sub> is inside the surface and all other vertices are outside. Intersections with the surface occur on three edges as shown. The surface intersects edge <em>V</em><sub>2</sub> – <em>V</em><sub>6</sub> at the point <em>A</em>. The fastest, but inaccurate, way to calculate <em>A</em> is to use linear interpolation:</p>
<figure id="f21_13" tabindex="0">
<img alt="" src="../images/fig21_13.jpg"/>
<figcaption><p><span class="blue">Figure 21.13.</span> Finding the intersection of the surface with a cube edge.</p></figcaption>
</figure>
<div class="disp-formula">
<m:math alttext=""><m:mrow><m:mfrac><m:mrow><m:mi mathvariant="italic">f</m:mi><m:mi mathvariant="normal">(</m:mi><m:mi mathvariant="italic">A</m:mi><m:mi mathvariant="normal">)</m:mi><m:mo>−</m:mo><m:mi mathvariant="italic">f</m:mi><m:mi mathvariant="normal">(</m:mi><m:msub><m:mrow><m:mi mathvariant="italic">V</m:mi></m:mrow><m:mrow><m:mi mathvariant="normal">2</m:mi></m:mrow></m:msub><m:mi mathvariant="normal">)</m:mi></m:mrow><m:mrow><m:mi mathvariant="italic">f</m:mi><m:mi mathvariant="normal">(</m:mi><m:msub><m:mrow><m:mi mathvariant="italic">V</m:mi></m:mrow><m:mrow><m:mi mathvariant="normal">6</m:mi></m:mrow></m:msub><m:mi mathvariant="normal">)</m:mi><m:mo>−</m:mo><m:mi mathvariant="italic">f</m:mi><m:mi mathvariant="normal">(</m:mi><m:msub><m:mrow><m:mi mathvariant="italic">V</m:mi></m:mrow><m:mrow><m:mi mathvariant="normal">2</m:mi></m:mrow></m:msub><m:mi mathvariant="normal">)</m:mi></m:mrow></m:mfrac><m:mo>=</m:mo><m:mfrac><m:mrow><m:mi mathvariant="normal">|</m:mi><m:mi>A</m:mi><m:mo>−</m:mo><m:msub><m:mrow><m:mi mathvariant="italic">V</m:mi></m:mrow><m:mrow><m:mi mathvariant="normal">2</m:mi></m:mrow></m:msub><m:mi mathvariant="normal">|</m:mi></m:mrow><m:mrow><m:mi mathvariant="normal">s</m:mi><m:mi mathvariant="normal">i</m:mi><m:mi mathvariant="normal">d</m:mi><m:mi mathvariant="normal">e</m:mi></m:mrow></m:mfrac><m:mi mathvariant="normal">.</m:mi></m:mrow></m:math>
</div>
<p><a id="term-225"/><a id="term-441"/><a id="term-496"/><a id="term-652"/><span aria-label="609" epub:type="pagebreak" id="pg_609" role="doc-pagebreak"/>If the cube side is 1 and the iso-value sought for <em>f</em> (<em>A</em>) is 0<em>.</em>5,then</p>
<div class="disp-formula">
<m:math alttext=""><m:mrow><m:mi mathvariant="italic">A</m:mi><m:mo>=</m:mo><m:msub><m:mrow><m:mi mathvariant="italic">V</m:mi></m:mrow><m:mrow><m:mi mathvariant="normal">3</m:mi></m:mrow></m:msub><m:mo>+</m:mo><m:mfrac><m:mrow><m:mi mathvariant="normal">0</m:mi><m:mi mathvariant="normal">.</m:mi><m:mi mathvariant="normal">5</m:mi><m:mo>−</m:mo><m:mi mathvariant="italic">f</m:mi><m:mi mathvariant="normal">(</m:mi><m:msub><m:mrow><m:mi mathvariant="italic">V</m:mi></m:mrow><m:mrow><m:mi mathvariant="normal">2</m:mi></m:mrow></m:msub><m:mi mathvariant="normal">)</m:mi></m:mrow><m:mrow><m:mi mathvariant="italic">f</m:mi><m:mi mathvariant="normal">(</m:mi><m:msub><m:mrow><m:mi mathvariant="italic">V</m:mi></m:mrow><m:mrow><m:mi mathvariant="normal">6</m:mi></m:mrow></m:msub><m:mi mathvariant="normal">)</m:mi><m:mo>−</m:mo><m:mi mathvariant="italic">f</m:mi><m:mi mathvariant="normal">(</m:mi><m:msub><m:mrow><m:mi mathvariant="italic">V</m:mi></m:mrow><m:mrow><m:mi mathvariant="normal">2</m:mi></m:mrow></m:msub><m:mi mathvariant="normal">)</m:mi></m:mrow></m:mfrac><m:mi mathvariant="normal">.</m:mi></m:mrow></m:math>
</div>
<p class="indent">This works well for a static image, but in animation error differences between frames will be very noticeable. A root-finding method such as <em>regula falsi</em> should be employed. This becomes more computationally costly as the gradient is needed to evaluate the point of intersection. The gradient is also needed at surface points for rendering. For many types of primitives it is simpler to find a numerical approximation using sample points around <em>p</em>, as in</p>
<div class="disp-formula">
<m:math alttext=""><m:mrow><m:mi>▽</m:mi><m:mi mathvariant="italic">f</m:mi><m:mi mathvariant="normal">(</m:mi><m:mi mathvariant="bold">p</m:mi><m:mi mathvariant="normal">)</m:mi><m:mo>=</m:mo><m:mi mathvariant="normal">(</m:mi><m:mfrac><m:mrow><m:mi mathvariant="italic">f</m:mi><m:mi mathvariant="normal">(</m:mi><m:mi mathvariant="bold">p</m:mi><m:mo>+</m:mo><m:mi mathvariant="normal">Δ</m:mi><m:mi mathvariant="italic">x</m:mi><m:mi mathvariant="normal">)</m:mi><m:mo>−</m:mo><m:mi mathvariant="italic">f</m:mi><m:mi mathvariant="normal">(</m:mi><m:mi mathvariant="bold">p</m:mi><m:mi mathvariant="normal">)</m:mi></m:mrow><m:mrow><m:mi mathvariant="normal">Δ</m:mi><m:mi mathvariant="italic">x</m:mi></m:mrow></m:mfrac><m:mi mathvariant="normal">,</m:mi><m:mi mathvariant="normal"/><m:mfrac><m:mrow><m:mi mathvariant="italic">f</m:mi><m:mi mathvariant="normal">(</m:mi><m:mi mathvariant="bold">p</m:mi><m:mo>+</m:mo><m:mi mathvariant="normal">Δ</m:mi><m:mi mathvariant="italic">y</m:mi><m:mi mathvariant="normal">)</m:mi><m:mo>−</m:mo><m:mi mathvariant="italic">f</m:mi><m:mi mathvariant="normal">(</m:mi><m:mi mathvariant="bold">p</m:mi><m:mi mathvariant="normal">)</m:mi></m:mrow><m:mrow><m:mi mathvariant="normal">Δ</m:mi><m:mi mathvariant="italic">y</m:mi></m:mrow></m:mfrac><m:mi mathvariant="normal">,</m:mi><m:mi mathvariant="normal"/><m:mfrac><m:mrow><m:mi mathvariant="italic">f</m:mi><m:mi mathvariant="normal">(</m:mi><m:mi mathvariant="bold">p</m:mi><m:mo>+</m:mo><m:mi mathvariant="normal">Δ</m:mi><m:mi mathvariant="italic">z</m:mi><m:mi mathvariant="normal">)</m:mi><m:mo>−</m:mo><m:mi mathvariant="italic">f</m:mi><m:mi mathvariant="normal">(</m:mi><m:mi mathvariant="bold">p</m:mi><m:mi mathvariant="normal">)</m:mi></m:mrow><m:mrow><m:mi mathvariant="normal">Δ</m:mi><m:mi mathvariant="italic">z</m:mi></m:mrow></m:mfrac><m:mi mathvariant="normal">)</m:mi><m:mn>.</m:mn></m:mrow></m:math>
</div>
<p>A reasonable value for Δ has been found empirically to be 0.01 * side where side is the length of a cube edge.</p>
<p>For manufacturing a mesh, as opposed to a set of independent triangles, a second hash table can maintain a list of all the <em>intersecting edges</em>. Since each cube edge is shared by up to four neighbors, the edge hash table prevents repetition of the surface-cube edge intersection calculation. The hash address can be derived from the same hash function as for vertices (applied to the edge endpoints).</p>
</section>
</section>
<section>
<h3 id="sec21_3_4"><a id="index_term602"/><a id="term-224"/><a id="term-226"/><a id="term-439"/><a id="term-442"/><a id="term-456"/><a id="term-497"/><span aria-label="610" epub:type="pagebreak" id="pg_610" role="doc-pagebreak"/><span class="green">21.3.4 Sampling Problems</span></h3>
<p>Ambiguities occur when opposite corners of a face (or the cube) have the same sign and the other pair of vertices on the face have the opposite sign (see Figure21.14). A sample taken in the center of the face will give a clue as to whether the cube represents the meeting of two surfaces or a saddle. It should be made clear that a spatial grid stores a sample of the implicit function at every vertex. If the function happens to vary considerably within a cell, the polygonal representation will not show such variations (see <a href="C26_chapter21.xhtml#f21_15">Figure 21.15</a>). The surface cannot be resolved by sampling alone unless something is known about the curvature of the surface. A good discussion of this topic appears in (Kalra &amp; Barr, 1989).</p>
<figure id="f21_14" tabindex="0">
<img alt="" src="../images/fig21_14.jpg"/>
<figcaption><p><span class="blue">Figure 21.14.</span> Examples of vertices inside (+) and outside (-) the surface. Note the extra sample gives a clue to avoid ambiguous cases.</p></figcaption>
</figure>
<figure id="f21_15" tabindex="0">
<img alt="" src="../images/fig21_15.jpg"/>
<figcaption><p><span class="blue">Figure 21.15.</span> Cube too large to capture small variation in implicit function.</p></figcaption>
</figure>
<p>This ambiguity problem (not the undersampling problem) is avoided by subdividing the cubic cell into tetrahedra. The tetrahedra can then be polygonized unambiguously. Since there are four vertices in each tetrahedron, a table of 16 entries will provide the correct triangle information. The disadvantage is that approximately twice the number of polygons will be generated.</p>
<section>
<h4 id="sec74"><span class="blue">Subdividing a Cube</span></h4>
<p>Without requiring additional cell vertices, a cube may be decomposed into five or six tetrahedra as shown in <a href="C26_chapter21.xhtml#f21_16">Figure 21.16</a>. These decompositions introduce diagonals on the cube faces, and to maintain a consistent diagonal direction between <a id="term-428"/><a id="term-450"/><span aria-label="611" epub:type="pagebreak" id="pg_611" role="doc-pagebreak"/>neighbors, the six decomposition is preferable. The introduction of diagonal edges produces a higher-resolution surface than replacing each cube directly with triangles. The decomposition into tetrahedra and the replacement of the tetrahedra with triangles are fast, table-driven algorithms, which produce topologically consistent meshes.</p>
<figure id="f21_16" tabindex="0">
<img alt="" src="../images/fig21_16.jpg"/>
<figcaption><p><span class="blue">Figure 21.16.</span> Decomposing a cube into six tetrahedra. <em>Image courtesy Erwin DeGroot</em>.</p></figcaption>
</figure>
</section>
</section>
<section>
<h3 id="sec21_3_5"><a id="index_term579"/><span class="green">21.3.5 Cell Polygonization</span></h3>
<p>Two obvious problems emerge from the use of uniform space subdivision. The size of triangles output by this algorithm do not adapt to the curvature of the surface and a further sample is required to solve the ambiguities, in which cubic cells are replaced by polygons. A space subdivision algorithm based on an octree was developed by Bloomenthal (Bloomenthal, 1988), which does adapt to the curvature of the surface. Cells are subdivided into eight octants and cracks are avoided by using a restricted octree scheme, i.e., neighboring cells cannot differ by more than one level of subdivision. This indeed reduces the number of polygons generated, but full advantage of large cells can only be taken if the flat regions of the surface happen to fall entirely within the appropriate octants. The algorithm proves in practice to be considerably slower than the uniform voxel algorithm and is more complicated to implement.</p>
</section>
</section>
<section>
<h2 id="sec21_4"><a epub:type="backlink" href="C02a_toc.xhtml#rsec21_4" role="doc-backlink"><span class="green">21.4 More on Blending</span></a></h2>
<p><a href="C26_chapter21.xhtml#sec21_1">Section 21.1</a> showed that blending can be made to occur when field values are summed. Ricci, in his landmark paper (Ricci, 1973), describes super-elliptic <a id="term-53"/><a id="term-64"/><a id="term-429"/><a id="term-436"/><a id="term-447"/><span aria-label="612" epub:type="pagebreak" id="pg_612" role="doc-pagebreak"/>blending. Given two functions <em>F<sub>A</sub></em> and <em>F<sub>B</sub></em>, previously we simply found the implicit value as <em>F</em><sub>total</sub> =<em>F<sub>A</sub></em> + <em>F<sub>B</sub></em>. We can denote this more general blending operator as <em>A</em> ◊ <em>B</em>. The Ricci blend is defined as:</p>
<div class="disp-formula" id="equ21_4">
<m:math alttext=""><m:mrow><m:msub><m:mrow><m:mi mathvariant="italic">f</m:mi></m:mrow><m:mrow><m:mi mathvariant="italic">A</m:mi><m:mi>◊</m:mi><m:mi mathvariant="italic">B</m:mi></m:mrow></m:msub><m:mo>=</m:mo><m:mi mathvariant="normal">(</m:mi><m:msub><m:mrow><m:mi mathvariant="italic">f</m:mi></m:mrow><m:mrow><m:msup><m:mrow><m:mi mathvariant="italic">A</m:mi></m:mrow><m:mrow><m:mi mathvariant="italic">n</m:mi></m:mrow></m:msup></m:mrow></m:msub><m:mo>+</m:mo><m:msub><m:mrow><m:mi mathvariant="italic">f</m:mi></m:mrow><m:mrow><m:msup><m:mrow><m:mi mathvariant="italic">B</m:mi></m:mrow><m:mrow><m:mi mathvariant="italic">n</m:mi></m:mrow></m:msup></m:mrow></m:msub><m:msup><m:mrow><m:mi mathvariant="normal">)</m:mi></m:mrow><m:mrow><m:mfrac><m:mrow><m:mi mathvariant="normal">1</m:mi></m:mrow><m:mrow><m:mi mathvariant="italic">n</m:mi></m:mrow></m:mfrac></m:mrow></m:msup><m:mn>.</m:mn></m:mrow><m:mspace width="3em"/><m:mo>(21.4)</m:mo></m:math>
</div>
<p>It is interesting to point out the following properties:</p>
<div class="disp-formula">
<m:math alttext=""><m:mrow><m:mtable><m:mtr><m:mtd><m:munder><m:mrow><m:mi>lim</m:mi><m:mo>⁡</m:mo></m:mrow><m:mrow><m:mi>n</m:mi><m:mo>→</m:mo><m:mo>+</m:mo><m:mi>∞</m:mi></m:mrow></m:munder><m:mrow><m:mo>(</m:mo><m:msup><m:mrow><m:msub><m:mrow><m:mi>f</m:mi></m:mrow><m:mrow><m:mi>A</m:mi></m:mrow></m:msub></m:mrow><m:mrow><m:mi>n</m:mi></m:mrow></m:msup><m:mo>+</m:mo><m:msup><m:mrow><m:msub><m:mrow><m:mi>f</m:mi></m:mrow><m:mrow><m:mi>B</m:mi></m:mrow></m:msub></m:mrow><m:mrow><m:mi>n</m:mi></m:mrow></m:msup><m:msup><m:mrow><m:mo>)</m:mo></m:mrow><m:mrow><m:mfrac><m:mrow><m:mn>1</m:mn></m:mrow><m:mrow><m:mi>n</m:mi></m:mrow></m:mfrac></m:mrow></m:msup></m:mrow></m:mtd><m:mtd><m:mo>=</m:mo></m:mtd><m:mtd><m:mtext>max</m:mtext><m:mrow><m:mo>(</m:mo><m:msub><m:mrow><m:mi>f</m:mi></m:mrow><m:mrow><m:mi>A</m:mi><m:mo>,</m:mo></m:mrow></m:msub><m:msub><m:mrow><m:mi>f</m:mi></m:mrow><m:mrow><m:mi>B</m:mi></m:mrow></m:msub><m:mo>)</m:mo><m:mo>,</m:mo></m:mrow></m:mtd></m:mtr><m:mtr><m:mtd><m:munder><m:mrow><m:mi>lim</m:mi><m:mo>⁡</m:mo></m:mrow><m:mrow><m:mi>n</m:mi><m:mo>→</m:mo><m:mo>−</m:mo><m:mi>∞</m:mi></m:mrow></m:munder><m:mrow><m:mo>(</m:mo><m:msup><m:mrow><m:msub><m:mrow><m:mi>f</m:mi></m:mrow><m:mrow><m:mi>A</m:mi></m:mrow></m:msub></m:mrow><m:mrow><m:mi>n</m:mi></m:mrow></m:msup><m:mo>+</m:mo><m:msup><m:mrow><m:msub><m:mrow><m:mi>f</m:mi></m:mrow><m:mrow><m:mi>B</m:mi></m:mrow></m:msub></m:mrow><m:mrow><m:mi>n</m:mi></m:mrow></m:msup><m:msup><m:mrow><m:mo>)</m:mo></m:mrow><m:mrow><m:mfrac><m:mrow><m:mn>1</m:mn></m:mrow><m:mrow><m:mi>n</m:mi></m:mrow></m:mfrac></m:mrow></m:msup></m:mrow></m:mtd><m:mtd><m:mo>=</m:mo></m:mtd><m:mtd><m:mtext>max</m:mtext><m:mrow><m:mo>(</m:mo><m:msub><m:mrow><m:mi>f</m:mi></m:mrow><m:mrow><m:mi>A</m:mi><m:mo>,</m:mo></m:mrow></m:msub><m:msub><m:mrow><m:mi>f</m:mi></m:mrow><m:mrow><m:mi>B</m:mi></m:mrow></m:msub><m:mo>)</m:mo><m:mn>.</m:mn></m:mrow></m:mtd></m:mtr></m:mtable></m:mrow></m:math>
</div>
<p class="indent">Moreover, this generalized blending is associative, i.e., <em>f<sub>(A◊B)◊C</sub></em> =<em>f<sub>A◊(B◊C)</sub></em>. The standard blending operator + proves to be a special case of the super-elliptic blend with <em>n</em> = 1. When <em>n</em> varies from 1 to infinity, it creates a set of blends interpolating between blending <em>A</em> + <em>B</em> and union <em>A</em> ∪ <em>B</em> (see <a href="C26_chapter21.xhtml#f21_17">Figure 21.17</a>). <a href="C26_chapter21.xhtml#f21_27">Figure 21.27</a> shows the nodes to be binary or unary; in fact the binary nodes can easily be extended using the above formulation to n-ary nodes.</p>
<figure id="f21_17" tabindex="0">
<img alt="" src="../images/fig21_17.jpg"/>
<figcaption><p><span class="blue">Figure 21.17.</span> By varying <em>n</em>, the Ricci blend may be made to change smoothly from blend to union. <em>Image courtesy Erwin DeGroot</em>.</p></figcaption>
</figure>
<p>The power of Ricci’s operators is that they are <em>closed</em> under the operations on the space of all possible implicit volumes, meaning that an application of an operator simply produces another scalar field defining another implicit volume. This new field can be composed with other fields, again using Ricci’s operators. Equation (21.4) will always produce the exact union of two implicit volumes, regardless of how complex they are. Compared with the difficulties involved in applying boolean <a id="index_term234"/>CSG operations to B-rep surfaces, solid modeling with implicit volumes is incredibly simple.</p>
<p>Following Pasko’s functional representation (A. Pasko et al., 1995), another generalized <a id="index_term89"/>blending function may be defined:</p>
<div class="disp-formula">
<m:math alttext=""><m:mrow><m:msub><m:mrow><m:mi mathvariant="italic">f</m:mi></m:mrow><m:mrow><m:mi mathvariant="italic">A</m:mi><m:mi>◊</m:mi><m:mi mathvariant="italic">B</m:mi></m:mrow></m:msub><m:mo>=</m:mo><m:mi mathvariant="normal">(</m:mi><m:msub><m:mrow><m:mi mathvariant="italic">f</m:mi></m:mrow><m:mrow><m:mi mathvariant="italic">A</m:mi></m:mrow></m:msub><m:mo>+</m:mo><m:msub><m:mrow><m:mi mathvariant="italic">f</m:mi></m:mrow><m:mrow><m:mi mathvariant="italic">B</m:mi></m:mrow></m:msub><m:mo>+</m:mo><m:mi>α</m:mi><m:msqrt><m:mrow><m:msup><m:mrow><m:msub><m:mrow><m:mi>f</m:mi></m:mrow><m:mrow><m:mi>A</m:mi></m:mrow></m:msub></m:mrow><m:mrow><m:mn>2</m:mn></m:mrow></m:msup><m:mo>+</m:mo><m:msup><m:mrow><m:msub><m:mrow><m:mi>f</m:mi></m:mrow><m:mrow><m:mi>B</m:mi></m:mrow></m:msub></m:mrow><m:mrow><m:mn>2</m:mn></m:mrow></m:msup></m:mrow></m:msqrt><m:mi mathvariant="normal">)</m:mi><m:mi mathvariant="normal">(</m:mi><m:msup><m:mrow><m:msub><m:mrow><m:mi>f</m:mi></m:mrow><m:mrow><m:mi>A</m:mi></m:mrow></m:msub></m:mrow><m:mrow><m:mn>2</m:mn></m:mrow></m:msup><m:mo>+</m:mo><m:msup><m:mrow><m:msub><m:mrow><m:mi>f</m:mi></m:mrow><m:mrow><m:mi>B</m:mi></m:mrow></m:msub></m:mrow><m:mrow><m:mn>2</m:mn></m:mrow></m:msup><m:msup><m:mrow><m:mi mathvariant="normal">)</m:mi></m:mrow><m:mrow><m:mfrac><m:mrow><m:mi mathvariant="italic">n</m:mi></m:mrow><m:mrow><m:mi mathvariant="normal">2</m:mi></m:mrow></m:mfrac></m:mrow></m:msup><m:mn>.</m:mn></m:mrow></m:math>
</div>
<p>When <em>α∈</em> [—1<em>,</em> 1] varies from —1 to 1, it creates a set of blends interpolating the union and the intersection operators. However, this operator is no longer associative which is incompatible with the definition of n-ary operators.</p>
</section>
<section>
<h2 id="sec21_5"><a id="index_term434"/><a epub:type="backlink" href="C02a_toc.xhtml#rsec21_5" role="doc-backlink"><span class="green">21.5 Constructive Solid Geometry</span></a></h2>
<p>Implicit models are frequently termed <em>implicit surfaces</em>; however, they are inherently volume models and useful for <em>solid modeling</em> operations. Ricci introduced a <a id="term-187"/><a id="term-336"/><span aria-label="613" epub:type="pagebreak" id="pg_613" role="doc-pagebreak"/><em>constructive geometry</em> for defining complex shapes from operations such as union, intersection, difference, and blend upon primitives (Ricci, 1973). The surface was considered as the boundary between the half spaces <em>f</em> (<strong>p</strong>)<em>&lt;</em> 1, defining the inside, and <em>f</em> (<strong>p</strong>)<em>&gt;</em> 1 defining the outside. This initial approach to solid modeling evolved into <em>constructive solid geometry</em> or CSG (Ricci, 1973; Requicha, 1980). CSG is typically evaluated bottom-up according to a binary tree, with low-degree polynomial primitives as the leaf nodes and internal nodes representing Boolean set operations. These methods are readily adapted for use in implicit modeling, and in the case of skeletal implicit surfaces, the Boolean set operations union ∪<sub>max</sub>, intersection <em>∩</em><sub>min</sub> and difference <em>\</em><sub>minmax</sub> are defined as follows (Wyvill, Galin, &amp; Guy, 1999):</p>
<div class="disp-formula" id="equ21_5">
<m:math alttext=""><m:mrow><m:mtable><m:mtr><m:mtd><m:msub><m:mrow><m:mo>∪</m:mo></m:mrow><m:mrow><m:mtext>max</m:mtext></m:mrow></m:msub><m:mtext> </m:mtext><m:mi>f</m:mi></m:mtd><m:mtd><m:mo>=</m:mo></m:mtd><m:mtd columnalign="left"><m:munderover><m:mrow><m:mtext>max</m:mtext></m:mrow><m:mrow><m:mi>i</m:mi><m:mo>=</m:mo><m:mn>0</m:mn></m:mrow><m:mrow><m:mi>k</m:mi><m:mo>−</m:mo><m:mn>1</m:mn></m:mrow></m:munderover><m:mrow><m:mo>(</m:mo><m:msub><m:mrow><m:mi>f</m:mi></m:mrow><m:mrow><m:mi>i</m:mi></m:mrow></m:msub><m:mo>)</m:mo><m:mo>,</m:mo></m:mrow></m:mtd></m:mtr><m:mtr><m:mtd><m:msub><m:mrow><m:mo>∩</m:mo></m:mrow><m:mrow><m:mtext>min</m:mtext></m:mrow></m:msub><m:mtext> </m:mtext><m:mi>f</m:mi></m:mtd><m:mtd><m:mo>=</m:mo></m:mtd><m:mtd columnalign="left"><m:munderover><m:mrow><m:mtext>min</m:mtext></m:mrow><m:mrow><m:mi>i</m:mi><m:mo>=</m:mo><m:mn>0</m:mn></m:mrow><m:mrow><m:mi>k</m:mi><m:mo>−</m:mo><m:mn>1</m:mn></m:mrow></m:munderover><m:mrow><m:mo>(</m:mo><m:msub><m:mrow><m:mi>f</m:mi></m:mrow><m:mrow><m:mi>i</m:mi></m:mrow></m:msub><m:mo>)</m:mo><m:mo>,</m:mo></m:mrow></m:mtd></m:mtr><m:mtr><m:mtd><m:mo>\</m:mo><m:mtext>minmax</m:mtext><m:mi>f</m:mi></m:mtd><m:mtd><m:mo>=</m:mo></m:mtd><m:mtd columnalign="left"><m:mtext>min</m:mtext><m:mrow><m:mo>(</m:mo><m:msub><m:mrow><m:mi>f</m:mi></m:mrow><m:mrow><m:mn>0</m:mn></m:mrow></m:msub><m:mo>,</m:mo><m:mn>2</m:mn><m:mo>*</m:mo><m:mtext>iso</m:mtext><m:mo>−</m:mo><m:munderover><m:mrow><m:mtext>max</m:mtext></m:mrow><m:mrow><m:mi>j</m:mi><m:mo>=</m:mo><m:mn>1</m:mn></m:mrow><m:mrow><m:mi>k</m:mi><m:mo>−</m:mo><m:mn>1</m:mn></m:mrow></m:munderover><m:mrow><m:mo>(</m:mo><m:msub><m:mrow><m:mi>f</m:mi></m:mrow><m:mrow><m:mi>j</m:mi></m:mrow></m:msub><m:mo>)</m:mo></m:mrow><m:mo>)</m:mo><m:mn>.</m:mn></m:mrow></m:mtd></m:mtr></m:mtable></m:mrow><m:mspace width="3em"/><m:mo>(21.5)</m:mo></m:math>
</div>
<p>The Ricci operators are illustrated in <a href="C26_chapter21.xhtml#f21_18">Figure 21.18</a> for point primitives <em>A</em> and <em>B</em>. For union (bottom left) the field at all points inside the union will be the greater of <em>f<sub>A</sub></em>() and <em>f<sub>B</sub></em>(). For intersection (center), points in the region marked as <em>P</em><sub>1</sub> will have value min (<em>f<sub>A</sub></em>(<em>P</em><sub>1</sub>)<em>,f<sub>B</sub></em>(<em>P</em><sub>1</sub>)) = 0, since the contribution of <em>B</em> will be zero outside of its range of influence. Similarly, for the region marked as <em>P</em><sub>2</sub>, (influence of <em>A</em> is zero, i.e., the minimum) leaving only the intersection region with positive values. Difference works similarly using the iso-value in the three <a id="term-8"/><a id="term-41"/><a id="term-188"/><a id="term-337"/><a id="term-346"/><a id="term-461"/><a id="term-1135"/><a id="term-1136"/><span aria-label="614" epub:type="pagebreak" id="pg_614" role="doc-pagebreak"/>marked regions ( <em>P<sub>i</sub></em>) as follows:</p>
<figure id="f21_18" tabindex="0">
<img alt="" src="../images/fig21_18.jpg"/>
<figcaption><p><span class="blue">Figure 21.18.</span> Ricci operators for CSG. <em>Image courtesy Erwin DeGroot</em>.</p></figcaption>
</figure>
<div class="disp-formula">
<m:math xmlns:mml="http://www.w3.org/1998/Math/MathML" alttext=""><m:mrow><m:mtable><m:mtr><m:mtd><m:mi>f</m:mi><m:mo>(</m:mo><m:msub><m:mrow><m:mi>P</m:mi></m:mrow><m:mrow><m:mn>0</m:mn></m:mrow></m:msub><m:mo>)</m:mo></m:mtd><m:mtd><m:mo>=</m:mo></m:mtd><m:mtd columnalign="left"><m:mtext>min</m:mtext><m:mo>(</m:mo><m:msub><m:mrow><m:mi>f</m:mi></m:mrow><m:mrow><m:mi>B</m:mi></m:mrow></m:msub><m:mo>(</m:mo><m:msub><m:mrow><m:mi>P</m:mi></m:mrow><m:mrow><m:mn>0</m:mn></m:mrow></m:msub><m:mo>)</m:mo><m:mo>,</m:mo><m:mn>2</m:mn><m:mo>*</m:mo><m:mtext> </m:mtext><m:mtext> </m:mtext><m:mtext>iso</m:mtext><m:mo>−</m:mo><m:msub><m:mrow><m:mi>f</m:mi></m:mrow><m:mrow><m:mi>A</m:mi></m:mrow></m:msub><m:mo>(</m:mo><m:msub><m:mrow><m:mi>P</m:mi></m:mrow><m:mrow><m:mn>0</m:mn></m:mrow></m:msub><m:mo>)</m:mo><m:mo>)</m:mo></m:mtd></m:mtr><m:mtr><m:mtd/><m:mtd><m:mo>=</m:mo></m:mtd><m:mtd columnalign="left"><m:mtext>min</m:mtext><m:mo>(</m:mo><m:mo>[</m:mo><m:mtext>iso,1</m:mtext><m:mo>]</m:mo><m:mo>,</m:mo><m:mo>[</m:mo><m:mn>2</m:mn><m:mo>*</m:mo><m:mtext>iso</m:mtext><m:mo>−</m:mo><m:mn>1</m:mn><m:mo>,</m:mo><m:mtext>iso</m:mtext><m:mo>]</m:mo><m:mo>)</m:mo></m:mtd></m:mtr><m:mtr><m:mtd/><m:mtd><m:mo>=</m:mo></m:mtd><m:mtd columnalign="left"><m:mo>[</m:mo><m:mn>2</m:mn><m:mo>*</m:mo><m:mtext>iso</m:mtext><m:mo>−</m:mo><m:mn>1</m:mn><m:mo>,</m:mo><m:mtext>iso</m:mtext><m:mo>]</m:mo><m:mo>&lt;</m:mo><m:mtext>iso</m:mtext></m:mtd></m:mtr><m:mtr><m:mtd><m:mi>f</m:mi><m:mo>(</m:mo><m:msub><m:mrow><m:mi>P</m:mi></m:mrow><m:mrow><m:mn>1</m:mn></m:mrow></m:msub><m:mo>)</m:mo></m:mtd><m:mtd><m:mo>=</m:mo></m:mtd><m:mtd columnalign="left"><m:mtext>min</m:mtext><m:mo>(</m:mo><m:msub><m:mrow><m:mi>f</m:mi></m:mrow><m:mrow><m:mi>B</m:mi></m:mrow></m:msub><m:mo>(</m:mo><m:msub><m:mrow><m:mi>P</m:mi></m:mrow><m:mrow><m:mn>1</m:mn></m:mrow></m:msub><m:mo>)</m:mo><m:mo>,</m:mo><m:mn>2</m:mn><m:mo>*</m:mo><m:mtext>iso</m:mtext><m:mo>−</m:mo><m:msub><m:mrow><m:mi>f</m:mi></m:mrow><m:mrow><m:mi>A</m:mi></m:mrow></m:msub><m:mo>(</m:mo><m:msub><m:mrow><m:mi>P</m:mi></m:mrow><m:mrow><m:mn>1</m:mn></m:mrow></m:msub><m:mo>)</m:mo><m:mo>)</m:mo></m:mtd></m:mtr><m:mtr><m:mtd/><m:mtd><m:mo>=</m:mo></m:mtd><m:mtd columnalign="left"><m:mi>min</m:mi><m:mo>⁡</m:mo><m:mo>(</m:mo><m:mo>[</m:mo><m:mn>0</m:mn><m:mo>,</m:mo><m:mtext>iso</m:mtext><m:mo>]</m:mo><m:mo>,</m:mo><m:mtext>[2*</m:mtext><m:mtext> iso</m:mtext><m:mo>−</m:mo><m:mn>1</m:mn><m:mo>,</m:mo><m:mtext>iso</m:mtext><m:mtext>]</m:mtext><m:mo>)</m:mo><m:mo>&lt;</m:mo><m:mtext>iso</m:mtext></m:mtd></m:mtr><m:mtr><m:mtd><m:mi>f</m:mi><m:mo>(</m:mo><m:msub><m:mrow><m:mi>P</m:mi></m:mrow><m:mrow><m:mn>2</m:mn></m:mrow></m:msub><m:mo>)</m:mo></m:mtd><m:mtd><m:mo>=</m:mo></m:mtd><m:mtd columnalign="left"><m:mtext>min</m:mtext><m:mrow><m:mo>(</m:mo><m:msub><m:mrow><m:mi>f</m:mi></m:mrow><m:mrow><m:mi>B</m:mi></m:mrow></m:msub><m:mo>(</m:mo><m:msub><m:mrow><m:mi>P</m:mi></m:mrow><m:mrow><m:mn>2</m:mn></m:mrow></m:msub><m:mo>)</m:mo><m:mo>,</m:mo><m:mn>2</m:mn><m:mo>*</m:mo><m:mtext>iso</m:mtext><m:mo>−</m:mo><m:msub><m:mrow><m:mi>f</m:mi></m:mrow><m:mrow><m:mi>A</m:mi></m:mrow></m:msub><m:mo>(</m:mo><m:msub><m:mrow><m:mi>P</m:mi></m:mrow><m:mrow><m:mn>2</m:mn></m:mrow></m:msub><m:mo>)</m:mo><m:mo>)</m:mo></m:mrow></m:mtd></m:mtr><m:mtr><m:mtd/><m:mtd><m:mo>=</m:mo></m:mtd><m:mtd columnalign="left"><m:mtext>min</m:mtext><m:mrow><m:mo>(</m:mo><m:mo>[</m:mo><m:mtext>iso, 1</m:mtext><m:mo>]</m:mo><m:mo>)</m:mo><m:mo>,</m:mo><m:mrow><m:mo>(</m:mo><m:mo>[</m:mo><m:mtext>iso, 2* iso</m:mtext><m:mo>]</m:mo><m:mo>)</m:mo><m:mo>&gt;</m:mo><m:mo>=</m:mo><m:mtext> </m:mtext><m:mtext>iso</m:mtext></m:mrow></m:mrow></m:mtd></m:mtr></m:mtable></m:mrow></m:math>
</div>
<p>CSG operators create creases, i.e., <em>C</em><sup>1</sup> discontinuities. For example, the min() operator (Equation (21.5)) creates <em>C</em><sup>1</sup> discontinuities at all points where <em>f</em><sub>1</sub>(<strong>p</strong>) = <em>f</em><sub>2</sub>(<strong>p</strong>). When applied to two spheres, the discontinuities produced by this union operator result in a crease on the surface, as shown in <a href="C26_chapter21.xhtml#f21_18">Figure 21.18</a>, which is the desired result. Discontinuities unfortunately extend into the field outside of the surface, which is not visible in this image. If a blend is then applied to the result of the union, the <em>C</em><sup>1</sup>-discontinuous plane in the field produces a shading discontinuity (<a href="C26_chapter21.xhtml#f21_19">Figure 21.19</a>).</p>
<figure id="f21_19" tabindex="0">
<img alt="" src="../images/fig21_19.jpg"/>
<figcaption><p><span class="blue">Figure 21.19.</span> Two point primitives on the left are connected by the Ricci union. A third primitive is blended to the result, creating an unwanted crease in the field. <em>Image courtesy Erwin DeGroot</em>.</p></figcaption>
</figure>
<p>The problem can be avoided to an extent (G. Pasko, Pasko, Ikeda, &amp; Kunii, 2002), and CSG operators have been developed that are <em>C</em><sup>1</sup> at all points except those where <em>f</em><sub>1</sub>(<strong>p</strong>) =<em>f</em><sub>2</sub>(<strong>p</strong>) = iso (Barthe, Dodgson, Sabin, Wyvill, &amp; Gaildrat, 2003).</p>
</section>
<section>
<h2 id="sec21_6"><a id="index_term1461"/><a epub:type="backlink" href="C02a_toc.xhtml#rsec21_6" role="doc-backlink"><span class="green">21.6 Warping</span></a></h2>
<p>The ability to distort the shape of a surface by warping the space in its neighborhood is a useful modeling tool. A warp is a continuous function <em>w</em>(<em>x, y, z</em>) that maps ℝ<sup>3</sup> onto ℝ<sup>3</sup>. Sederberg provides a good analogy for warping when describing free form deformations (Sederberg &amp; Parry, 1986). He suggests that the warped space can be likened to a clear, flexible, plastic parallelepiped in which the objects to be warped are embedded. A warped element may be defined by simply applying some warp function <em>w</em>(<strong>p</strong>) to the implicit equation:</p>
<div class="disp-formula" id="equ21_6">
<m:math alttext=""><m:mrow><m:msub><m:mrow><m:mi>f</m:mi></m:mrow><m:mrow><m:mi>i</m:mi></m:mrow></m:msub><m:mo>(</m:mo><m:mi>x</m:mi><m:mo>,</m:mo><m:mi>y</m:mi><m:mo>,</m:mo><m:mi>z</m:mi><m:mo>)</m:mo><m:mo>=</m:mo><m:msub><m:mrow><m:mi>g</m:mi></m:mrow><m:mrow><m:mi>i</m:mi></m:mrow></m:msub><m:mtext> </m:mtext><m:mi>ο</m:mi><m:mtext> </m:mtext><m:msub><m:mrow><m:mi>d</m:mi></m:mrow><m:mrow><m:mi>i</m:mi></m:mrow></m:msub><m:mtext> </m:mtext><m:mi>ο</m:mi><m:mtext> </m:mtext><m:msub><m:mrow><m:mi>w</m:mi></m:mrow><m:mrow><m:mi>i</m:mi></m:mrow></m:msub><m:mo>(</m:mo><m:mi>x</m:mi><m:mo>,</m:mo><m:mi>y</m:mi><m:mo>,</m:mo><m:mi>z</m:mi><m:mo>)</m:mo><m:mn>.</m:mn></m:mrow><m:mspace width="3em"/><m:mo>(21.6)</m:mo></m:math>
</div>
<p>A warped element may be fully characterized by the distance to its skeleton <em>d<sub>i</sub></em>(<em>x, y, z</em>), its fall-off filter function <em>g<sub>i</sub></em>(<em>r</em>), and eventually its warp function <em>w<sub>i</sub></em>(<em>x, y, z</em>). To render or perform operations on an implicit surface, the implicit <a id="term-425"/><a id="term-457"/><a id="term-458"/><a id="term-459"/><a id="term-460"/><a id="term-528"/><a id="term-656"/><span aria-label="615" epub:type="pagebreak" id="pg_615" role="doc-pagebreak"/>value of many points <em>f</em> (<em>P</em> ) must be found. First, <em>P</em> is transformed by the warp function to some new point <em>Q</em>, and <em>f</em> (<em>Q</em>) is returned in place of <em>f</em> (<em>P</em> ). In <a href="C26_chapter21.xhtml#f21_20">Figure 21.20</a>, instead of returning the implicit value of some point <em>f</em> (<em>Q</em>), the value for <em>f</em> (<em>P</em> ) is returned. In this case, the iso-value is returned and the implicit surface (curve in 2D) passes through <em>Q</em> instead of <em>P</em> . Thus, the circle is warped into an ellipse.</p>
<figure id="f21_20" tabindex="0">
<img alt="" src="../images/fig21_20.jpg"/>
<figcaption><p><span class="blue">Figure 21.20.</span> Point <em>Q</em> returns the field value for point <em>P</em>.</p></figcaption>
</figure>
<p>Barr introduced the notion of global and local deformations using the operations of <em>twist</em>, <em>taper</em>, and <em>bend</em> applied to parametric surfaces (Barr, 1984). The deformations can be nested to produce models such as the one shown in <a href="C26_chapter21.xhtml#f21_27">Figure 21.27</a>. Conceptually, these are easy to apply to an implicit surface, as indicated in Equation (21.6).</p>
<p>Note that the normal cannot be calculated in a similar manner to warping a point. This problem is similar to the problem outlined in <a href="C18_chapter13.xhtml#sec13_2">Section 13.2</a> on instancing. In this case, the normal can most easily be approximated using Equation (21.3.3) although the use of the Jacobian, as suggested in (Barr, 1984), yields precise results. The Barr warps are described in the following sections.</p>
<section>
<h3 id="sec21_6_1"><span class="green">21.6.1 Twist</span></h3>
<p>In this example, the twist is around the <em>z</em>-axis by θ (see <a href="C26_chapter21.xhtml#f21_21">Figure 21.21</a>) for three blended implicit cylinders with a twist warp applied to them.</p>
<figure id="f21_21" tabindex="0">
<img alt="" src="../images/fig21_21.jpg"/>
<figcaption><p><span class="blue">Figure 21.21.</span> Three blended implicit cylinders twisted together. <em>Image courtesy Erwin DeGroot</em>.</p></figcaption>
</figure>
<p>The twist around <em>z</em> is expressed as</p>
<div class="disp-formula">
<m:math alttext=""><m:mrow><m:mi>w</m:mi><m:mrow><m:mo>(</m:mo><m:mi>x</m:mi><m:mo>,</m:mo><m:mi>y</m:mi><m:mo>,</m:mo><m:mi>z</m:mi><m:mo>)</m:mo></m:mrow><m:mo>=</m:mo><m:mo>{</m:mo><m:mtable><m:mtr><m:mtd><m:mi>x</m:mi><m:mo>*</m:mo><m:mtext>cos</m:mtext><m:mo>(</m:mo><m:mi>θ</m:mi><m:mo>(</m:mo><m:mi>z</m:mi><m:mo>)</m:mo><m:mo>)</m:mo><m:mo>−</m:mo><m:mi>y</m:mi><m:mo>*</m:mo><m:mtext>sin</m:mtext><m:mo>(</m:mo><m:mi>θ</m:mi><m:mo>(</m:mo><m:mi>z</m:mi><m:mo>)</m:mo><m:mo>)</m:mo></m:mtd></m:mtr><m:mtr><m:mtd><m:mi>x</m:mi><m:mo>*</m:mo><m:mtext>sin</m:mtext><m:mo>(</m:mo><m:mi>θ</m:mi><m:mo>(</m:mo><m:mi>z</m:mi><m:mo>)</m:mo><m:mo>+</m:mo><m:mi>y</m:mi><m:mo>*</m:mo><m:mtext>cos</m:mtext><m:mo>(</m:mo><m:mi>θ</m:mi><m:mo>(</m:mo><m:mi>z</m:mi><m:mo>)</m:mo><m:mo>)</m:mo><m:mo>)</m:mo></m:mtd></m:mtr></m:mtable><m:mo>}</m:mo><m:mn>.</m:mn></m:mrow></m:math>
</div>
</section>
<section>
<h3 id="sec21_6_2"><span class="green">21.6.2 Taper</span></h3>
<p>Taper is applied along one major axis. A linear taper has proved to be the most useful although quadratic and cubic tapers are easily implemented. For example, a linear taper along the <em>y</em>-axis involves changing both <em>x</em>- and <em>z</em>-coordinates. (See <a href="C26_chapter21.xhtml#f21_22">Figure 21.22</a>.) A linear scale is applied to <em>y</em> between <em>y</em><sub>max</sub> and <em>y</em><sub>min</sub>:</p>
<figure id="f21_22" tabindex="0">
<img alt="" src="../images/fig21_22.jpg"/>
<figcaption><p><span class="blue">Figure 21.22.</span> Three blended implicit cylinders, twisted then tapered. <em>Image courtesy Erwin DeGroot</em>.</p></figcaption>
</figure>
<div class="disp-formula">
<m:math alttext=""><m:mrow><m:mi>s</m:mi><m:mrow><m:mrow><m:mo>(</m:mo><m:mi>y</m:mi><m:mo>)</m:mo></m:mrow><m:mo>=</m:mo><m:mfrac><m:mrow><m:msub><m:mrow><m:mi>y</m:mi></m:mrow><m:mrow><m:mtext>max</m:mtext></m:mrow></m:msub><m:mo>−</m:mo><m:mi>y</m:mi></m:mrow><m:mrow><m:msub><m:mrow><m:mi>y</m:mi></m:mrow><m:mrow><m:mi>max</m:mi><m:mo>⁡</m:mo></m:mrow></m:msub><m:mo>−</m:mo><m:msub><m:mrow><m:mi>y</m:mi></m:mrow><m:mrow><m:mtext>min</m:mtext></m:mrow></m:msub></m:mrow></m:mfrac><m:mtext> </m:mtext><m:mi>w</m:mi><m:mrow><m:mo>(</m:mo><m:mi>x</m:mi><m:mo>,</m:mo><m:mi>y</m:mi><m:mo>,</m:mo><m:mi>z</m:mi><m:mo>)</m:mo></m:mrow><m:mo>=</m:mo><m:mo>{</m:mo><m:mtable><m:mtr><m:mtd><m:mtable><m:mtr><m:mtd><m:mi>s</m:mi><m:mrow><m:mo>(</m:mo><m:mi>y</m:mi><m:mo>)</m:mo><m:mi>x</m:mi></m:mrow></m:mtd></m:mtr><m:mtr><m:mtd><m:mi>y</m:mi></m:mtd></m:mtr></m:mtable></m:mtd></m:mtr><m:mtr><m:mtd><m:mi>s</m:mi><m:mrow><m:mo>(</m:mo><m:mi>y</m:mi><m:mo>)</m:mo><m:mi>z</m:mi></m:mrow></m:mtd></m:mtr></m:mtable><m:mo>}</m:mo></m:mrow></m:mrow></m:math>
</div>
</section>
<section>
<h3 id="sec21_6_3"><a id="term-426"/><a id="term-451"/><a id="term-637"/><span aria-label="616" epub:type="pagebreak" id="pg_616" role="doc-pagebreak"/><span class="green">21.6.3 Bend</span></h3>
<p>Bend is also applied along one major axis. (See <a href="C26_chapter21.xhtml#f21_23">Figure 21.23</a>.) For the bend example below, the bending rate is <em>k</em> measured in radians per unit length, the axis of the bend is (<em>x</em><sub>0</sub><em>,</em> 1<em>/k</em>), and the angle θ is defined as (<em>x</em> – <em>x</em><sub>0</sub>) * <em>k</em>. The bend around <em>z</em> is</p>
<figure id="f21_23" tabindex="0">
<img alt="" src="../images/fig21_23.jpg"/>
<figcaption><p><span class="blue">Figure 21.23.</span> Three blended implicit cylinders, twisted together, tapered and bent. <em>Image courtesy Erwin DeGroot</em>.</p></figcaption>
</figure>
<div class="disp-formula">
<m:math alttext=""><m:mrow><m:mi>w</m:mi><m:mrow><m:mrow><m:mo>(</m:mo><m:mi>x</m:mi><m:mo>,</m:mo><m:mi>y</m:mi><m:mo>,</m:mo><m:mi>z</m:mi><m:mo>)</m:mo></m:mrow><m:mo>=</m:mo><m:mo>{</m:mo><m:mtable><m:mtr><m:mtd><m:mtable><m:mtr><m:mtd><m:mo>−</m:mo><m:mtext>sin</m:mtext><m:mo>(</m:mo><m:mi>θ</m:mi><m:mo>)</m:mo><m:mo>*</m:mo><m:mo>(</m:mo><m:mi>y</m:mi><m:mo>−</m:mo><m:mn>1</m:mn><m:mo>/</m:mo><m:mi>k</m:mi><m:mo>)</m:mo><m:mo>+</m:mo><m:msub><m:mrow><m:mi>x</m:mi></m:mrow><m:mrow><m:mn>0</m:mn></m:mrow></m:msub></m:mtd></m:mtr><m:mtr><m:mtd><m:mtext>cos</m:mtext><m:mo>(</m:mo><m:mi>θ</m:mi><m:mo>)</m:mo><m:mo>*</m:mo><m:mo>(</m:mo><m:mi>y</m:mi><m:mo>−</m:mo><m:mn>1</m:mn><m:mo>/</m:mo><m:mi>k</m:mi><m:mo>)</m:mo><m:mo>+</m:mo><m:mn>1</m:mn><m:mo>/</m:mo><m:mi>k</m:mi></m:mtd></m:mtr></m:mtable></m:mtd></m:mtr><m:mtr><m:mtd><m:mi>z</m:mi></m:mtd></m:mtr></m:mtable><m:mo>}</m:mo></m:mrow></m:mrow></m:math>
</div>
</section>
</section>
<section>
<h2 id="sec21_7"><a id="index_term597"/><a id="index_term893"/><a epub:type="backlink" href="C02a_toc.xhtml#rsec21_7" role="doc-backlink"><span class="green">21.7 Precise Contact Modeling</span></a></h2>
<p><em>Precise contact modeling</em> (PCM) is a method of deforming implicit surface primitives in contact situations while maintaining a precise contact surface with <em>C</em><sup>1</sup> continuity (Gascuel, 1993). PCM is important in that it is a simple and automatic way of showing how a model can react to its environment. This cannot be so easily done with non-implicit methods (see <a href="C26_chapter21.xhtml#f21_24">Figure 21.24</a>).</p>
<figure id="f21_24" tabindex="0">
<img alt="" src="../images/fig21_24.jpg"/>
<figcaption><p><span class="blue">Figure 21.24.</span> Sea anemone deforms to implicit rock. <em>Image courtesy Mai Nur and X. Liang.</em></p></figcaption>
</figure>
<p>PCM is implemented by the inclusion of a deforming function <em>s</em>(<em>p</em>) that modifies the field value returned for each point. For each pair of objects, collision is first detected using a bounding-box test. Once it is established that a collision is likely, PCM is applied. A local, geometric deformation term <em>s<sub>i</sub></em> is computed and added to the implicit function <em>f<sub>i</sub></em>. The volume of the colliding objects is divided into an interpenetration region and a deformation region. The result of applying <em>s<sub>i</sub></em> is that the interpenetration region is compressed so that contact is maintained without interpenetration occurring (see <a href="C26_chapter21.xhtml#f21_25">Figure 21.25</a>). The effect of <em>s<sub>i</sub></em> is attenuated to zero within the propagation region so that the volume outside of the two regions is not deformed.</p>
<figure id="f21_25" tabindex="0">
<img alt="" src="../images/fig21_25.jpg"/>
<figcaption><p><span class="blue">Figure 21.25.</span> A 2D slice through objects in collision showing the various regions and PCM deformation. <em>Image courtesy Erwin DeGroot</em>.</p></figcaption>
</figure>
<p>Given two skeletal elements generating fields <em>f</em><sub>1</sub>(<em>p</em>) and <em>f</em><sub>2</sub>(<em>p</em>), the surface around each one is calculated as</p>
<div class="disp-formula">
<m:math alttext=""><m:mrow><m:mtable><m:mtr><m:mtd><m:msub><m:mrow><m:mi>f</m:mi></m:mrow><m:mrow><m:mn>1</m:mn></m:mrow></m:msub><m:mrow><m:mo>(</m:mo><m:mi>p</m:mi><m:mo>)</m:mo><m:mo>+</m:mo><m:msub><m:mrow><m:mi>s</m:mi></m:mrow><m:mrow><m:mn>1</m:mn></m:mrow></m:msub><m:mrow><m:mo>(</m:mo><m:mi>p</m:mi><m:mo>)</m:mo></m:mrow></m:mrow></m:mtd><m:mtd><m:mo>=</m:mo></m:mtd><m:mtd><m:mn>0</m:mn><m:mo>,</m:mo></m:mtd></m:mtr><m:mtr><m:mtd><m:msub><m:mrow><m:mi>f</m:mi></m:mrow><m:mrow><m:mn>2</m:mn></m:mrow></m:msub><m:mrow><m:mo>(</m:mo><m:mi>p</m:mi><m:mo>)</m:mo><m:mo>+</m:mo><m:msub><m:mrow><m:mi>s</m:mi></m:mrow><m:mrow><m:mn>2</m:mn></m:mrow></m:msub><m:mrow><m:mo>(</m:mo><m:mi>p</m:mi><m:mo>)</m:mo></m:mrow></m:mrow></m:mtd><m:mtd><m:mo>=</m:mo></m:mtd><m:mtd><m:mn>0.</m:mn></m:mtd></m:mtr></m:mtable></m:mrow></m:math>
</div>
<p class="indent">We need to generate a surface common to both elements (dotted line in <a href="C26_chapter21.xhtml#f21_25">Figure 21.25</a>), i.e., where they share a solution in the interpenetration region for some <em>p</em> in that region:</p>
<div class="disp-formula" id="equ21_7">
<m:math alttext=""><m:mrow><m:mtable><m:mtr><m:mtd><m:mrow><m:msub><m:mrow><m:mi>s</m:mi></m:mrow><m:mrow><m:mn>1</m:mn></m:mrow></m:msub><m:mrow><m:mo>(</m:mo><m:mi>p</m:mi><m:mo>)</m:mo></m:mrow><m:mo>−</m:mo><m:msub><m:mrow><m:mi>f</m:mi></m:mrow><m:mrow><m:mn>1</m:mn></m:mrow></m:msub><m:mo>(</m:mo><m:mi>p</m:mi><m:mo>)</m:mo></m:mrow></m:mtd><m:mtd><m:mo>=</m:mo></m:mtd><m:mtd><m:mtext>iso</m:mtext><m:mo>,</m:mo></m:mtd></m:mtr><m:mtr><m:mtd><m:msub><m:mrow><m:mi>s</m:mi></m:mrow><m:mrow><m:mn>2</m:mn></m:mrow></m:msub><m:mrow><m:mo>(</m:mo><m:mi>p</m:mi><m:mo>)</m:mo><m:mo>−</m:mo><m:msub><m:mrow><m:mi>f</m:mi></m:mrow><m:mrow><m:mn>2</m:mn></m:mrow></m:msub><m:mrow><m:mo>(</m:mo><m:mi>p</m:mi><m:mo>)</m:mo></m:mrow></m:mrow></m:mtd><m:mtd><m:mo>=</m:mo></m:mtd><m:mtd><m:mtext>iso</m:mtext><m:mn>.</m:mn></m:mtd></m:mtr></m:mtable></m:mrow><m:mspace width="3em"/><m:mo>(21.7)</m:mo></m:math>
</div>
<p><a id="term-452"/><a id="term-453"/><a id="term-638"/><span aria-label="617" epub:type="pagebreak" id="pg_617" role="doc-pagebreak"/>Intuitively, the deeper within object 1 that object 2 penetrates, the higher the implicit value of object 1 and thus the more that object 2 will be compressed.</p>
<p>The function, <em>s<sub>i</sub></em> is defined to produce a smooth junction at the boundary of the interpenetration region, in other words where <em>s<sub>i</sub></em> = 0 but its derivative is greater than zero. From here to the boundary of the <a id="index_term598"/>propagation region, <em>s<sub>i</sub></em> is used to attenuate the propagation to zero. The <em>nearest</em> point on the interpenetration region boundary <em>p</em><sub>0</sub> is found by following the gradient.</p>
<p>Within the propagation region <em>s<sub>i</sub></em>(<em>p</em>) =<em>h<sub>i</sub></em>(<em>r</em>), where <em>p</em> = (<em>x, y, z</em>) is the point whose implicit value is being calculated and <em>r</em> = ||<em>p</em> – <em>p</em><sub>0</sub>|| (see <a href="C26_chapter21.xhtml#f21_26">Figure 21.26</a>). The value of <em>r<sub>i</sub></em>, set by the user, defines the size of the propagation region; no deformation occurs beyond this region. To control how much the objects inflate in the propagation region, the user provides a value for the parameter <em>α</em>. The maximum <a id="term-57"/><a id="term-432"/><span aria-label="618" epub:type="pagebreak" id="pg_618" role="doc-pagebreak"/>value of <em>h<sub>i</sub></em> is <em>M<sub>i</sub></em>. The current minimum of <em>s<sub>i</sub></em> is negative in the interpenetration region and is given as <em>s<sub>i</sub></em><sub>min</sub>, where <em>M<sub>i</sub></em> = –α<em><sub>i</sub>s<sub>i</sub></em><sub>min</sub>. Thus an object will be compressed in the interpenetration region and will inflate in the propagation region. The equation for <em>h<sub>i</sub></em> is formed in two parts by two cubic polynomials that are designed to join at <em>r</em> =<em>r<sub>i</sub>/</em>2, where the slope is zero:</p>
<figure id="f21_26" tabindex="0">
<img alt="" src="../images/fig21_26.jpg"/>
<figcaption><p><span class="blue">Figure 21.26.</span> The function, <em>h<sub>i</sub>(r)</em> is the value of the deformation function <em>w<sub>i</sub></em> in the propagation region.</p></figcaption>
</figure>
<div class="disp-formula">
<m:math xmlns:mml="http://www.w3.org/1998/Math/MathML" alttext=""><m:mrow><m:mtable><m:mtr><m:mtd><m:mi>c</m:mi></m:mtd><m:mtd><m:mo>=</m:mo></m:mtd><m:mtd columnalign="left"><m:mfrac><m:mrow><m:mn>4</m:mn><m:mo>(</m:mo><m:msub><m:mrow><m:mi>w</m:mi></m:mrow><m:mrow><m:mi>i</m:mi></m:mrow></m:msub><m:mi>k</m:mi><m:mo>−</m:mo><m:mn>4</m:mn><m:msub><m:mrow><m:mi>M</m:mi></m:mrow><m:mrow><m:mi>i</m:mi></m:mrow></m:msub><m:mo>)</m:mo></m:mrow><m:mrow><m:msubsup><m:mrow><m:mi>w</m:mi></m:mrow><m:mrow><m:mi>i</m:mi></m:mrow><m:mrow><m:mn>3</m:mn></m:mrow></m:msubsup></m:mrow></m:mfrac><m:mo>,</m:mo></m:mtd></m:mtr><m:mtr><m:mtd><m:mi>d</m:mi></m:mtd><m:mtd><m:mo>=</m:mo></m:mtd><m:mtd columnalign="left"><m:mfrac><m:mrow><m:mn>4</m:mn><m:mo>(</m:mo><m:mn>3</m:mn><m:msub><m:mrow><m:mi>M</m:mi></m:mrow><m:mrow><m:mi>i</m:mi></m:mrow></m:msub><m:mo>−</m:mo><m:msub><m:mrow><m:mi>w</m:mi></m:mrow><m:mrow><m:mi>i</m:mi></m:mrow></m:msub><m:mi>k</m:mi><m:mo>)</m:mo></m:mrow><m:mrow><m:msubsup><m:mrow><m:mi>w</m:mi></m:mrow><m:mrow><m:mi>i</m:mi></m:mrow><m:mrow><m:mn>2</m:mn></m:mrow></m:msubsup></m:mrow></m:mfrac><m:mo>,</m:mo></m:mtd></m:mtr><m:mtr><m:mtd><m:msub><m:mrow><m:mi>h</m:mi></m:mrow><m:mrow><m:mi>i</m:mi></m:mrow></m:msub><m:mrow><m:mo>(</m:mo><m:mi>r</m:mi><m:mo>)</m:mo></m:mrow></m:mtd><m:mtd><m:mo>=</m:mo></m:mtd><m:mtd columnalign="left"><m:mi>c</m:mi><m:msup><m:mrow><m:mi>r</m:mi></m:mrow><m:mrow><m:mn>3</m:mn></m:mrow></m:msup><m:mo>+</m:mo><m:mi>d</m:mi><m:msup><m:mrow><m:mi>r</m:mi></m:mrow><m:mrow><m:mn>2</m:mn></m:mrow></m:msup><m:mo>+</m:mo><m:mi>k</m:mi><m:mi>r</m:mi><m:mo>⁢</m:mo><m:mtext> </m:mtext><m:mtext> </m:mtext><m:mtext> </m:mtext><m:mtext> </m:mtext><m:mtext> </m:mtext><m:mtext>if  </m:mtext><m:mi>r</m:mi><m:mo>∈</m:mo><m:mrow><m:mo>[</m:mo><m:mn>0</m:mn><m:mo>,</m:mo><m:msub><m:mrow><m:mi>w</m:mi></m:mrow><m:mrow><m:mi>i</m:mi></m:mrow></m:msub><m:mo>/</m:mo><m:mn>2</m:mn><m:mo>]</m:mo><m:mo>,</m:mo></m:mrow></m:mtd></m:mtr><m:mtr><m:mtd><m:msub><m:mrow><m:mi>h</m:mi></m:mrow><m:mrow><m:mi>i</m:mi></m:mrow></m:msub><m:mrow><m:mo>(</m:mo><m:mi>r</m:mi><m:mo>)</m:mo></m:mrow></m:mtd><m:mtd><m:mo>=</m:mo></m:mtd><m:mtd columnalign="left"><m:mfrac><m:mrow><m:mn>4</m:mn><m:msub><m:mrow><m:mi>M</m:mi></m:mrow><m:mrow><m:mi>i</m:mi></m:mrow></m:msub></m:mrow><m:mrow><m:msubsup><m:mrow><m:mi>w</m:mi></m:mrow><m:mrow><m:mi>i</m:mi></m:mrow><m:mrow><m:mn>3</m:mn></m:mrow></m:msubsup></m:mrow></m:mfrac><m:mrow><m:mo>(</m:mo><m:mi>r</m:mi><m:mo>−</m:mo><m:msub><m:mrow><m:mi>w</m:mi></m:mrow><m:mrow><m:mi>i</m:mi></m:mrow></m:msub><m:msup><m:mrow><m:mo>)</m:mo></m:mrow><m:mrow><m:mn>2</m:mn></m:mrow></m:msup><m:mrow><m:mo>(</m:mo><m:mn>4</m:mn><m:mi>r</m:mi><m:mo>−</m:mo><m:msub><m:mrow><m:mi>w</m:mi></m:mrow><m:mrow><m:mi>i</m:mi></m:mrow></m:msub><m:msup><m:mrow><m:mo>)</m:mo></m:mrow><m:mrow><m:mn>3</m:mn></m:mrow></m:msup><m:mtext> </m:mtext><m:mtext> </m:mtext><m:mtext> </m:mtext><m:mtext>if</m:mtext><m:mtext> </m:mtext><m:mtext> </m:mtext><m:mi>r</m:mi><m:mo>∈</m:mo><m:mrow><m:mo>[</m:mo><m:msub><m:mrow><m:mi>w</m:mi></m:mrow><m:mrow><m:mi>i</m:mi></m:mrow></m:msub><m:mo>/</m:mo><m:mn>2</m:mn><m:mo>,</m:mo><m:msub><m:mrow><m:mi>w</m:mi></m:mrow><m:mrow><m:mi>i</m:mi></m:mrow></m:msub><m:mo>]</m:mo><m:mn>.</m:mn></m:mrow></m:mrow></m:mrow></m:mtd></m:mtr></m:mtable></m:mrow></m:math>
</div>
<p class="indent">It is desirable that we have <em>C</em><sup>1</sup>-continuity as we move from the interpenetration to the propagation region. Thus, <em>h'<sub>i</sub></em>(0) =<em>k</em> in <a href="C26_chapter21.xhtml#f21_26">Figure 21.26</a>, is the directional derivative of <em>s<sub>i</sub></em> at the junction (marked as <em>p</em><sub>0</sub> in <a href="C26_chapter21.xhtml#f21_25">Figure 21.25</a>). As indicated in Equation (21.7), <em>s<sub>i</sub></em> = –<em>f</em><em><sub>i</sub></em> in the interpenetration region, thus:</p>
<div class="disp-formula">
<m:math alttext=""><m:mrow><m:mi>k</m:mi><m:mo>=</m:mo><m:mo>|</m:mo><m:mo>|</m:mo><m:mi>▽</m:mi><m:mo>(</m:mo><m:msub><m:mrow><m:mi>f</m:mi></m:mrow><m:mrow><m:mi>i</m:mi></m:mrow></m:msub><m:mo>,</m:mo><m:msub><m:mrow><m:mi>p</m:mi></m:mrow><m:mrow><m:mn>0</m:mn></m:mrow></m:msub><m:mo>)</m:mo><m:mo>|</m:mo><m:mo>|</m:mo></m:mrow></m:math>
</div>
<p class="indent">PCM is only an approximation to a properly deformed surface, but it is an attractive algorithm due to its simplicity.</p>
</section>
<section>
<h2 id="sec21_8"><a epub:type="backlink" href="C02a_toc.xhtml#rsec21_8" role="doc-backlink"><span class="green">21.8 The BlobTree</span></a></h2>
<p>The <em>BlobTree</em> is a method that employs a tree structure that extended the CSG tree to include various blending operations using skeletal primitives (Wyvill et al., 1999). A system with similar capabilities, the <em>Hyperfun</em> project, used a specialized language to describe F-rep objects (Adzhiev et al., 1999).</p>
<p>In the BlobTree system, models are defined by expressions that combine implicit primitives and the operators ∪ (union), ∩ (intersection), — (difference), + (blend), ◊ (super-elliptic blend), and <em>w</em> (warp). The BlobTree is not only the data structure built from these expressions but also a way of visualizing the structure of the models. The operators listed above are binary with the exception of warp, which is a unary operator. In general it is more efficient to use n-ary rather than binary operators. The BlobTree incorporates affine transformations as nodes so that it is also a scene graph and primitives (e.g., skeletons) form the leaf nodes.</p>
<section>
<h3 id="sec21_8_1"><a id="term-58"/><a id="term-433"/><span aria-label="619" epub:type="pagebreak" id="pg_619" role="doc-pagebreak"/><span class="green">21.8.1 Traversing the BlobTree</span></h3>
<p>An example of a BlobTree including the Barr warps and CSG operations is shown in <a href="C26_chapter21.xhtml#f21_27">Figure 21.27</a>. Other nodes can include 2D texturing (Schmidt, Grimm, &amp; Wyvill, 2006), precise contact modeling, as well as animation and other attributes. The traversal of the BlobTree is in essence very simple. All that is required to render the object either by polygonizing or ray tracing is to find the implicit value of any point (and the corresponding gradient). This can be done by traversing the tree. Polygonization and ray-tracing algorithms need to evaluate the implicit field function at a large number of points in space. The function <em>f</em> (<em>N,M</em> ) returns the field value for the node <em>N</em> at the point <em>M</em> , which depends on the type of the node. The values <em>L</em> and <em>R</em> indicate that the left or right branch of the tree is explored. The algorithm below is written (for simplicity) as if the tree were binary:</p>
<figure id="f21_27" tabindex="0">
<img alt="" src="../images/fig21_27.jpg"/>
<figcaption><p><span class="blue">Figure 21.27.</span> BlobTree. The spiral staircase is built from a central textured cylinder to which the stairs and the railing are blended. The railing is comprised of a series of cylinders blended with two circle (torus) primitives, blended together and further blended with a vertical cylinder. The BlobTree is also a scene graph and instancing nodes repeat the various parts transformed by the appropriate matrices. Each stair is made from a tapered polygon primitive (that becomes an offset surface); intersection and union nodes combine the inflated disk with the stair.</p></figcaption>
</figure>
<p>function <em>f</em> (<em>N,M</em> ):</p>
<ul class="list-bullet">
<li>
<p class="list">primitive: <em>f</em> (<em>M</em> );</p>
</li>
<li>
<p class="list">warp: <em>f</em> (<em>L</em>(<em>N</em> )<em>,w</em>(<em>M</em> ));</p>
</li>
<li>
<p class="list">blend: <em>f</em> (<em>L</em>(<em>N</em> )<em>,M</em> )+ <em>f</em> (<em>R</em>(<em>N</em> )<em>,M</em> ));</p>
</li>
<li>
<p class="list">union: max(<em>f</em> (<em>L</em>(<em>N</em> )<em>,M</em> )<em>,f</em> (<em>R</em>(<em>N</em> )<em>,M</em> ));</p>
</li>
<li>
<p class="list"><a id="term-59"/><a id="term-434"/><a id="term-449"/><span aria-label="620" epub:type="pagebreak" id="pg_620" role="doc-pagebreak"/>intersection: min(<em>f</em> (<em>L</em>(<em>N</em> )<em>,M</em> )<em>,f</em> (<em>R</em>(<em>N</em> )<em>,M</em> ));</p>
</li>
<li>
<p class="list">difference: min(<em>f</em> (<em>L</em>(<em>N</em> )<em>,M</em>), –<em>f</em> (<em>R</em>(<em>N</em> )<em>,M</em> )).</p>
</li>
</ul>
<p class="indent">A complex BlobTree model showing many of the features that have been integrated is shown in <a href="C26_chapter21.xhtml#f21_28">Figure 21.28</a>.</p>
<figure id="f21_28" tabindex="0">
<img alt="" src="../images/fig21_28.jpg"/>
<figcaption><p><span class="blue">Figure 21.28.</span> “Spiral Stairs.” A complex BlobTree implicit model created in Erwin DeGroot’s BlobTree.net system.</p></figcaption>
</figure>
</section>
</section>
<section>
<h2 id="sec21_9"><a epub:type="backlink" href="C02a_toc.xhtml#rsec21_9" role="doc-backlink"><span class="green">21.9 Interactive Implicit Modeling Systems</span></a></h2>
<p>Early sketch-based modeling systems, such as Teddy (Igarashi, Matsuoka, &amp; Tanaka, 1999), used a few drawn strokes from the user to infer a polygonal model in 3-space. With better hardware and improved algorithms, sketch-based implicit modeling systems are now possible. Shapeshop uses implicit sweep surfaces to manufacture 3D strokes from 2D user strokes and also preserves the hierarchy of the BlobTree unlike the early systems that produced homogeneous <a id="index_term736"/>meshes (Schmidt, Wyvill, Sousa, &amp; Jorge, 2005). This enables a user to produce complex models of arbitrary topology from a few simple strokes. The margin figures show a closed drawn stroke (<a href="C26_chapter21.xhtml#f21_29">Figure 21.29</a>) inflated into a an implicit sweep and a second sweep (<a href="C26_chapter21.xhtml#f21_30">Figure 21.30</a>) that has a smaller sweep object subtracted using CSG.</p>
<figure id="f21_29" tabindex="0">
<img alt="" src="../images/fig21_29.jpg"/>
<figcaption><p><span class="blue">Figure 21.29.</span> Outlines are inflated. <em>Image courtesy Erwin DeGroot</em>.</p></figcaption>
</figure>
<p><a id="term-13"/><a id="term-60"/><a id="term-165"/><a id="term-435"/><a id="term-498"/><a id="term-759"/><a id="term-760"/><a id="term-1120"/><span aria-label="621" epub:type="pagebreak" id="pg_621" role="doc-pagebreak"/>One of the improvements that made this possible is a caching system that uses a fixed 3D grid of implicit values at each node of the BlobTree representing the values found by traversing the tree below the node (Schmidt, Wyvill, &amp; Galin, 2005). If the value of some point <em>p</em> is required at node <em>N</em>, a value may be returned without traversing the tree below <em>N</em>, provided that part of the tree is unaltered. Instead, an interpolation scheme (see <a href="C14_chapter9.xhtml#c9">Chapter 9</a>) is used to find a value for <em>p</em>. This scheme speeds up traversal for complex BlobTrees and is one factor in enabling a system to run at interactive rates.</p>
<p>The next generation of implicit modeling systems will exploit hardware and software advances to be able to handle more and more complex hierarchical models interactively. A more complex Shapeshop example is shown in <a href="C26_chapter21.xhtml#f21_31">Figure 21.31</a>.</p>
<figure id="f21_30" tabindex="0">
<img alt="" src="../images/fig21_30.jpg"/>
<figcaption><p><span class="blue">Figure 21.30.</span> BlobTree operations can be applied, e.g.,CSG difference. <em>Image courtesy Erwin DeGroot</em>.</p></figcaption>
</figure>
<figure id="f21_31" tabindex="0">
<img alt="" src="../images/fig21_31.jpg"/>
<figcaption><p><span class="blue">Figure 21.31.</span> “The Next Step.” A complex BlobTree implicit model created interactively in Ryan Schmidt’s Shapeshop by artist Corien Clapwijk (Andusan).</p></figcaption>
</figure>
</section>
<section>
<h2 id="sec75"><a id="term-14"/><a id="term-166"/><span aria-label="622" epub:type="pagebreak" id="pg_622" role="doc-pagebreak"/><span class="green">Exercises</span></h2>
<p class="qpara"><span class="green">1.</span> In an implicit surface modeling system the fall-off filter function is defined as</p>
<div class="disp-formula">
<m:math alttext=""><m:mrow><m:mi>f</m:mi><m:mrow><m:mo>(</m:mo><m:mi>r</m:mi><m:mo>)</m:mo></m:mrow><m:mo>=</m:mo><m:mo>{</m:mo><m:mtable><m:mtr><m:mtd><m:mn>0</m:mn><m:mo>,</m:mo></m:mtd></m:mtr><m:mtr><m:mtd><m:mn>1</m:mn><m:mo>−</m:mo><m:mi>r</m:mi><m:mo>/</m:mo><m:mi>R</m:mi><m:mo>,</m:mo></m:mtd></m:mtr></m:mtable><m:mtable><m:mtr><m:mtd><m:mi>r</m:mi><m:mo>&gt;</m:mo><m:mi>R</m:mi><m:mo>,</m:mo></m:mtd></m:mtr><m:mtr><m:mtd><m:mtext>otherwise,</m:mtext></m:mtd></m:mtr></m:mtable></m:mrow></m:math>
<p class="indent">where <em>R</em> is a constant. A point primitive placed at (—1<em>,</em> 0) and another at (1<em>,</em> 0) are rendered to show the <em>f</em> = 0<em>.</em>5 iso-surface. The value <em>R</em>, the distance where the potential due to the point falls to zero in both cases, is 1<em>.</em>5.</p>
<p class="indent">Calculate the potential at the point (0<em>,</em> 0) and at +0<em>.</em>5 intervals until the point (2<em>.</em>5<em>,</em> 0). Sketch the 0<em>.</em>5 contour and the contour at which the field falls to zero.</p>
</div>
<p class="qpara"><span class="green">2.</span> Why are the ambiguous cases in the polygonization algorithm considered to be a sampling problem?</p>
<p class="qpara"><span class="green">3.</span> Calculate the error involved in using linear interpolation to estimate the intersection of an implicit surface and a cubic voxel.</p>
<p class="qpara"><span class="green">4.</span> Design an implicit primitive function using the skeleton of your choice. The function must take as input a point and return an implicit value and also the gradient at that point.</p>
</section>
</section>
</body>
</html>