<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xmlns:svg="http://www.w3.org/2000/svg" dir="ltr" lang="en" xml:lang="en">
<head>
<meta charset="UTF-8"/>
<title>22 Computer Graphics in Games</title>
<link href="../styles/9781000426359.css" rel="stylesheet" type="text/css"/>
<meta content="urn:uuid:e0000000-0000-0000-0000-000006665500" name="Adept.expected.resource"/>
</head>
<body epub:type="bodymatter">
<section epub:type="chapter" role="doc-chapter">
<header>
<p class="chap-auz"><span class="green">Naty Hoffman</span></p>
<h1 class="chapz1" id="c22"><a id="index_term390"/><a id="term-185"/><span aria-label="623" epub:type="pagebreak" id="pg_623" role="doc-pagebreak"/><a epub:type="backlink" href="C02a_toc.xhtml#rc22" role="doc-backlink"><span class="green"><span class="big1">22</span><br/>Computer Graphics in Games</span></a></h1>
</header>
<p class="noindent1">Of all the applications of computer graphics, computer and video games attract perhaps the most attention. The graphics methods selected for a given game have a profound effect, not only on the game engine code, but also on the art asset creation, and even sometimes on the <em>gameplay</em>, or core game mechanics.</p>
<p>Although game graphics rely on the material in all of the preceding chapters, two chapters are particularly germane. Games need to make highly efficient use of graphics hardware, so an understanding of the material in <a href="C22_chapter17.xhtml#c17">Chapter 17</a> is important.</p>
<p>In this chapter, I will detail the specific considerations that apply to graphics in <a id="index_term385"/><a id="index_term227"/>game development, from the <a id="index_term408"/>platforms on which games run to the game production process.</p>
<section>
<h2 id="sec22_1"><a epub:type="backlink" href="C02a_toc.xhtml#rsec22_1" role="doc-backlink"><span class="green">22.1 Platforms</span></a></h2>
<p>Here, I use the term <em>platform</em> to refer to a specific combination of hardware, operating system, and API (application programming interface) for which a game is designed. Games run on a large variety of platforms, ranging from virtual machines used for browser-based games to dedicated game consoles using specialized hardware and APIs.</p>
<p><a id="term-318"/><a id="term-324"/><span aria-label="624" epub:type="pagebreak" id="pg_624" role="doc-pagebreak"/>In the past, it was common for games to be designed for a single platform. The increasing cost of game development has made this rare; <em>multiplatform</em> game development is now the norm. The incremental increase in development cost to support multiple platforms is more than repaid by a potential doubling or tripling of the customer base.</p>
<p>Some platforms are quite loosely defined. For example, when developing a game for the Windows PC platform, the developer must account for a very large variety of possible hardware configurations. Games are even expected to run (and run well) on PC configurations that did not exist when the game was developed! This is only possible due to the abstractions afforded by the APIs defining the Windows platform.</p>
<p>One way in which developers account for wide variance in graphics performance is by <em>scaling</em>—adjusting graphics quality in response to system capabilities. This can ensure reasonable performance on low-end systems, while still achieving competitive visuals on high-performance systems. This adjustment is sometimes done automatically by profiling the system performance, but more often this control is left in the hands of the user, who can best judge his personal preferences for quality versus speed. Display resolution is easiest to adjust, followed by antialiasing quality. It is also fairly common to offer several quality levels for visual effects such as shadows and motion blur, including the option of turning the effect off entirely.</p>
<p>Differences in graphics performance can be so large that some machines may not run the game at a playable frame rate, even with the lowest quality settings; for this reason PC game developers publish minimum and recommended machine specifications for each game.</p>
<p>As platforms, game consoles are strictly defined. When developing a game for, e.g., Nintendo’s Wii console, the developer knows exactly what hardware the game will run on. If the platform’s hardware implementation is changed (often done to reduce manufacturing costs), the console manufacturer must ensure that the new implementation behaves <em>exactly</em> like the previous one, including timing and performance. This is not to say that the console developer’s task is easy; console APIs tend to be much less abstract and closer to the underlying hardware. This gives console development its own set of difficulties. In some sense, multiplatform development (which commonly includes at least two different console platforms and often Windows as well) is the hardest of all, since the <a id="index_term406"/>multiplatform game developer has neither the assurance of a fixed platform or the convenience of a single high-level API.</p>
<p>Browser-based <em>virtual machines</em> such as Adobe Flash are an interesting class of game platforms. Although such virtual machines run on a wide class of hardware <span aria-label="625" epub:type="pagebreak" id="pg_625" role="doc-pagebreak"/>from personal computers to mobile phones, the high degree of abstraction provided by the virtual machine results in a stable and unified development platform. The relative ease of development for these platforms and the huge pool of potential customers makes them increasingly attractive to game developers. However, these platforms are defined by the lowest common denominator of the supported hardware, and virtual machines have lower performance than native code on any given platform. For these reasons, such platforms are best suited to games with modest graphics requirements.</p>
<p>Platforms can also be characterized by their openness to development, which is a business or legal distinction rather than a technical one. For example, Windows is open in the sense that development tools are widely available, and there are no gatekeepers controlling access to the marketplace of Windows games. Apple’s iPhone is a somewhat more restricted platform in that all applications need to pass a certification process and certain classes of applications are banned outright. Consoles are the most restrictive game platforms, where access to the development tools is tightly controlled. This is opening up somewhat with the introduction of online console game marketplaces, which tend to be more open. A particularly interesting example is Microsoft’s Xbox LIVE Community Games service, where the development tools are freely available and the “gatekeeping” is performed primarily by peer review. Games distributed through this service must use a virtual machine platform provided by Microsoft for security reasons.</p>
<p>The game platform determines many elements of the game experience. For example, PC gamers use keyboard and mouse, while console gamers use specialized game controllers. Many console games support multiple players on the same console, either sharing a screen or providing a window for each player. Due to the difficulty of sharing keyboard and mouse, this type of play is not found on PC. A handheld game system will have a different control scheme than a touch-screen phone, etc.</p>
<p>Although game platforms vary widely, some common trends can be discerned. Most platforms have multiple processing cores, divided between general-purpose (CPU) and graphics-specific (GPU). Performance gains over time are due mostly to increases in core count; gains in individual core performance are modest. As GPU cores grow in generality, the lines between GPU and CPU cores are increasingly blurred. Storage capacity tends to increase at a slower rate than processing power, and communication bandwidth (between cores as well as between each core and storage) grows at a slower pace still.</p>
</section>
<section>
<h2 id="sec22_2"><a id="index_term402"/><a id="term-307"/><a id="term-316"/><span aria-label="626" epub:type="pagebreak" id="pg_626" role="doc-pagebreak"/><a epub:type="backlink" href="C02a_toc.xhtml#rsec22_2" role="doc-backlink"><span class="green">22.2 Limited Resources</span></a></h2>
<p>One of the primary challenges of game graphics is the need to manage multiple pools of limited resources. Each platform imposes its own constraints on hardware resources such as <a id="index_term410"/>processing time, storage, and memory bandwidth. At a higher level, development resources also need to be managed; there is a fixed-size team of programmers, artists, and game designers with limited time to complete the game, hopefully without working <em>too</em> much overtime! This needs to be taken into account when deciding which graphics techniques to adopt.</p>
<section>
<h3 id="sec22_2_1"><span class="green">22.2.1 Processing Time</span></h3>
<p>Early game developers only had to worry about budgeting a single processor. Current game platforms contain multiple CPU and GPU cores. These processors need to be carefully synchronized to avoid deadlocks or excessive stalls.</p>
<p>Since the time consumed by a single rendering command is highly variable, graphics processors are decoupled from the rest of the system via a <em>command buffer</em>. This buffer acts as a queue; commands are deposited on one end and the GPU reads rendering commands from the other. Increasing the size of this buffer decreases the chances of GPU starvation. It is fairly common for games to buffer an entire frame’s worth of rendering commands before sending them to the GPU; this guarantees that GPU starvation does not occur. However, this approach requires reserving enough storage space for two full frame’s worth of commands (the GPU works on one, while the CPU deposits commands in the other). It also increases the latency between the user’s input and the display, which can be problematic for fast-paced games.</p>
<p>Processing budgets are determined by the <em>frame rate</em>, which is the frequency at which the frame buffer is refreshed with new renderings of the scene. On fixed platforms (such as consoles), the frame rate experienced by the user is essentially the same one seen by the game developer, so fairly strict frame–rate limits can be imposed. Most games target a frame rate of 30 frames per second (fps); in games where response latency is especially important, the target is often 60 fps. On highly variable platforms (such as PCs), the frame-rate budgets are (by necessity) defined more loosely.</p>
<p>The required frame rate gives the graphics programmer a fixed budget per frame to work with. In the case of a 30 fps target, the CPU cores have 33 milliseconds to gather inputs, process the game logic, perform any physical simulations, traverse the scene description, and send the rendering commands to the graphics <span aria-label="627" epub:type="pagebreak" id="pg_627" role="doc-pagebreak"/>hardware. In parallel, other tasks such as audio and network processing must be handled, with their own required response times. While this is happening, the GPU is typically executing the graphics commands submitted during the previous frame.</p>
<p>In most cases, CPU cores are a <em>homogeneous</em> resource; all cores are the same, and any of them are equally well suited to a given workload (there are some exceptions, such as the Cell processor used in Sony’s PLAYSTATION 3 console).</p>
<p>In contrast, GPUs contain a <em>heterogeneous</em> mix of resources, each specialized to a certain set of tasks. Some of these resources consist of fixed-function hardware (for triangle rasterization, alpha blending, and texture sampling), and some are programmable cores. On older GPUs, programmable cores were further differentiated into vertex and pixel processing cores; newer GPU designs have <em>unified shader cores</em> which can execute any of the programmable shader types.</p>
<p>Such heterogeneous resources are budgeted separately. Typically, at any point, only one resource type will be the bottleneck, and the others will have excess capacity. On the one hand, this is good, since this capacity can be leveraged to improve visual quality without decreasing performance. On the other hand, it makes it harder to improve performance, since decreasing usage of any of the non-bottleneck resources will have no effect. Even decreasing usage of the bottleneck resource may only improve performance slightly, depending on the degree of utilization of the “next bottleneck.”</p>
</section>
<section>
<h3 id="sec22_2_2"><span class="green">22.2.2 Storage</span></h3>
<p>Game platforms, like any modern computing system, possess multi-stage <em><a id="index_term421"/>storage hierarchies</em>, with smaller, faster memory types at the top and larger, slower storage at the bottom. This arrangement is borne of engineering necessity, although it does complicate life for the developer. Most platforms include optical disc storage, which is extremely slow and is used mostly for delivery. On platforms such as Windows, a lengthy installation process is performed once to move all data from the optical disc onto the hard drive, which is significantly faster. The optical disc is never used again (except as an anti-piracy measure). On console platforms, this is less common, although it does sometimes happen when a hard drive is guaranteed to be present, as on Sony’s PLAYSTATION 3 console. More often, the hard drive (if present) is only used as a cache for the optical disc.</p>
<p>The next step up the memory hierarchy is RAM, which on many platforms is divided into general system RAM and VRAM (video RAM) which benefits from a high-speed interface to the graphics hardware. A game level may be too large to <a id="term-301"/><span aria-label="628" epub:type="pagebreak" id="pg_628" role="doc-pagebreak"/>fit in RAM, in which case the game developer needs to manage moving the data in and out of RAM as needed. On platforms such as Windows, virtual memory is often used for this. On console platforms, custom data streaming and caching systems are typically employed.</p>
<p>Finally, both the CPU and GPU boast various kinds of on-chip memory and caches. These are extremely small and fast and are usually managed by the graphics API.</p>
<p>Graphics resources take up a lot of memory, so they are a primary focus of storage budgets in game development. Textures are usually the greatest memory consumers, followed by geometry (vertex data), and finally other types of graphics data such as animations. Not all memory can be used for graphics—audio also takes up a fair bit, and game logic may use sizeable data structures. As in the case of processing time, budgeting tends to be somewhat looser on Windows, where the exact amount of memory present on the user’s system is unknown and virtual memory covers a multitude of sins. In contrast, memory budgeting on console platforms is quite strict—often the lead programmer keeps track of memory on a spreadsheet and a programmer requiring more memory for their system needs to beg, borrow, or steal it from someone else.</p>
<p>The various levels of the memory hierarchy differ not only in size, but also in access speed. This has two separate dimensions: <em>latency</em> and <em>bandwidth</em>.</p>
<p>Latency is the time that elapses between a storage access request and its final fulfillment. This varies from a few clock cycles (for on-chip cache) to millions of clock cycles (for data residing on optical disc). Latency is usually an issue for read access (although write latency can also be an issue if the result needs to be read back from memory soon after). In some cases, the read request is <em>blocking</em>,which means that the processor core that submitted the read can do nothing else until the request is fulfilled. In other cases, the read is <em>non-blocking</em>; the processing core can submit the read request, do other types of processing, and then use the results of the read after it has arrived. Texture accesses by the GPU are an example of non-blocking reads; an important aspect of GPU design is to find ways to “hide” texture read latency by performing unrelated computations while the texture read is being fulfilled.</p>
<p>For this latency hiding to work, there must be a sufficient amount of computation relative to texture accesses. This is an important consideration for the shader writer; the optimal mix of computation vs. texture access keeps changing (in favor of more computation) as memory fails to keep up with increases in processing power.</p>
<p>Bandwidth refers to the maximum rate of transfer to and from storage. It is typically measured in gigabytes per second.</p>
</section>
<section>
<h3 id="sec22_2_3"><a id="index_term393"/><a id="term-302"/><a id="term-308"/><a id="term-314"/><span aria-label="629" epub:type="pagebreak" id="pg_629" role="doc-pagebreak"/><span class="green">22.2.3 Development Resources</span></h3>
<p>Besides hardware resources, such as processing power and storage space, the game graphics programmer also has to contend with a different kind of limited resource—the time of his teammates! When selecting graphics techniques, the engineering resources needed to implement each technique must be taken into account, as well as any tools necessary to compute the input data (in many cases, tools can take significantly more time than implementing the technique itself). Perhaps most importantly, the impact on artist productivity must be taken into account. Most graphics techniques use assets created by game artists, who comprise by far the largest part of most modern game teams. The graphics programmer must foster the artist’s productivity and creativity, which will ultimately determine the visual quality of the game.</p>
</section>
</section>
<section>
<h2 id="sec22_3"><a id="index_term407"/><a epub:type="backlink" href="C02a_toc.xhtml#rsec22_3" role="doc-backlink"><span class="green">22.3 Optimization Techniques</span></a></h2>
<p>Making wise use of these limited resources is the primary challenge of the game graphics programmer. To this end, various optimization techniques are commonly employed.</p>
<p>In many games, pixel shader processing is a primary bottleneck. Most GPUs contain hierarchical depth-culling hardware which can avoid executing pixel shaders on occluded surfaces. To make good use of this hardware, opaque objects can be rendered back-to-front. Alternatively, optimal depth-culling usage can be achieved by performing a <em><a id="index_term392"/>depth prepass</em>, i.e., rendering all the opaque objects into the depth buffer (without any color output or pixel shaders) before rendering the scene normally. This does incur some overhead (due to the need to render every object twice), but in many cases the performance gain is worth it.</p>
<p>The fastest way to render an object is to not render it at all; thus any method of discerning early on that an object is occluded can be useful. This saves not only pixel processing but also vertex processing and even CPU time that would be spent submitting the object to the graphics API. View frustum culling (see Section 8.4.1) is universally employed, but in many games it is not sufficient. High-level occlusion culling algorithms are often used, utilizing data structures such as PVS (potentially visible sets) or BSP (binary spatial partitioning) trees to quickly narrow down the pool of potentially visible objects.</p>
<p>Even if an object is visible, it may be at such a distance that most of its detail can be removed without apparent effect. LOD (level-of-detail) algorithms render different representations of an object based on distance (or other factors, such <a id="term-313"/><span aria-label="630" epub:type="pagebreak" id="pg_630" role="doc-pagebreak"/>as screen coverage or importance). This can save significant processing, vertex processing in particular. Examples can be seen in <a href="C27_chapter22.xhtml#f22_1">Figure 22.1</a>.</p>
<figure id="f22_1" tabindex="0">
<img alt="" src="../images/fig22_1.jpg"/>
<figcaption><p><span class="blue">Figure 22.1.</span> Two examples of game objects at a varying level of detail. The small inset images show the relative sizes at which the simplified models might be used. <em>Upper row of images courtesy Crytek; lower row courtesy Valve Corp.</em></p></figcaption>
</figure>
<p>In many cases, processing can be performed before the game even starts. The results of such <em>preprocessing</em> can be stored and used each frame, thus speeding up the game. This is most commonly employed for lighting, where global illumination algorithms are utilized to compute lighting throughout the scene and store it in lightmaps and other data structures for later use.</p>
</section>
<section>
<h2 id="sec22_4"><a id="index_term395"/><a epub:type="backlink" href="C02a_toc.xhtml#rsec22_4" role="doc-backlink"><span class="green">22.4 Game Types</span></a></h2>
<p>Since game requirements vary widely, the selection of graphics techniques is driven by the exact type of game being developed.</p>
<p>The allocation of processing time depends strongly on the frame rate. Currently, most console games tend to target 30 frames per second, since this enables much higher graphics quality. However, certain game types with fast gameplay require very low latency, and such games typically render at 60 frames per second. <span aria-label="631" epub:type="pagebreak" id="pg_631" role="doc-pagebreak"/>This includes music games such as <em>Guitar Hero</em> and first-person shooters such as <em>Call of Duty</em>.</p>
<p>The frame rate determines the available time to render the scene. The composition of the scene itself also varies widely from game to game. Most games have a division between <em>background geometry</em> (scenery, mostly static) and <em>foreground geometry</em> (characters and dynamic objects). These are handled differently by the rendering engine. For example, background geometry will often have lightmaps containing precomputed lighting, which is not feasible for foreground objects. Precomputed lighting is typically applied to foreground objects via some type of volumetric representation which can take account of the changing position of each object over time.</p>
<p>Some games have relatively enclosed environments, where the camera remains largely in place. The purest examples are fighting games such as the <em>Street Fighter</em> series, but this is also true to some extent for games such as <em>Devil May Cry</em> and <em>God of War</em>. These games have cameras that are not under direct player control, and the game play tends to move from one enclosed environment to another, spending a significant amount of playing time in each. This allows the game developer to lavish large amounts of resources (processing, storage, and artist time) on each room or enclosed environment, resulting in very high levels of graphics fidelity.</p>
<p>Other games have extremely large worlds, where the player can move about freely. This is most true for “sandbox games” such as the <em>Grand Theft Auto</em> series and online role-playing games such as <em>World of Warcraft</em>. Such games pose great challenges to the graphics developer, since resource allocation is very difficult when during each frame the player can see a large extent of the world. Further complicating things, the player can freely go to some formerly distant part of the world and observe it from up close. Such games typically have changing time of day, which makes precomputation of lighting difficult at best, if not impossible.</p>
<p>Most games, such as first-person shooters, are somewhere between the two extremes. The player can see a fair amount of scenery each frame, but movement through the game world is somewhat constrained. Many games also have a fixed time of day for each game level, for ease of lighting precomputation.</p>
<p>The number of foreground objects rendered also varies widely between game types. Real-time strategy games such as the <em>Command and Conquer</em> series often have many dozens, if not hundreds, of units visible on screen. Other types of games have more limited quantities of visible characters, with fighting games at the opposite extreme, where only two characters are visible, each rendered with extremely high detail. A distinction must be drawn between the number of characters visible at any time (which affects budgeting of processing time) and <a id="term-303"/><a id="term-304"/><span aria-label="632" epub:type="pagebreak" id="pg_632" role="doc-pagebreak"/>the number of <em>unique</em> characters which can potentially be visible at short notice (which affects storage budgets).</p>
<p>The type or <em><a id="index_term396"/>genre</em> of game also determines audience expectations of the graphics. For example, first-person shooters have historically had very high levels of graphics fidelity, and this expectation drives the graphics design when developing new games in that genre; see <a href="C27_chapter22.xhtml#f22_2">Figure 22.2</a>. On the other hand, puzzle games have typically had relatively simplistic graphics, so most game developers will not invest large amounts of programming or art resources into developing photorealistic graphics for such games.</p>
<figure id="f22_2" tabindex="0">
<img alt="" src="../images/fig22_2.jpg"/>
<figcaption><p><span class="blue">Figure 22.2.</span> <em>Crysis</em> exemplifies the realistic and detailed graphics expected of first-person shooters. <em>Image courtesy Crytek.</em></p></figcaption>
</figure>
<p>Although most games aim for a photorealistic look, a few do attempt more stylized rendering. One interesting example of this is <em>Okami</em>, which can be seen in <a href="C27_chapter22.xhtml#f22_3">Figure 22.3</a>.</p>
<figure id="f22_3" tabindex="0">
<img alt="" src="../images/fig22_3.jpg"/>
<figcaption><p><span class="blue">Figure 22.3.</span> An example of highly stylized, non-photorealistic rendering from the game <em>Okami</em>. <em>Image courtesy Capcom Entertainment, Inc.</em></p></figcaption>
</figure>
<p>The management of development resources also differs by game type. Most games have a closed development cycle of one to two years, which ends after the game ships. Recently it has become common to have downloadable content (DLC), which can be purchased after the game ships, so some development resources need to be reserved for that. Persistent-world online games have a never-ending development process where new content is continually being generated, at least as long as the game is economically viable (which may be a period of decades).</p>
<p><a id="term-305"/><span aria-label="633" epub:type="pagebreak" id="pg_633" role="doc-pagebreak"/>The creative exploitation of the specific requirements and restrictions of a particular game is the hallmark of a skilled game graphics programmer. A good example is the game <em>LittleBigPlanet</em>, which has a “two-and-a-half-dimensional” game world comprising a small number of two-dimensional layers, as well as a noninteractive background. The graphics quality of this game is excellent, driven by the use of unusual rendering techniques specialized to this type of environment; see <a href="C27_chapter22.xhtml#f22_4">Figure 22.4</a>.</p>
<figure id="f22_4" tabindex="0">
<img alt="" src="../images/fig22_4.jpg"/>
<figcaption><p><span class="blue">Figure 22.4.</span> The <em>LittleBigPlanet</em> developers took care to choose techniques that fit the game’s constraints, combining them in unusual ways to achieve stunning results. <em>LittleBigPlanet © 2007 Sony Computer Entertainment Europe. Developed by Media Molecule. LittleBigPlanet is a trademark of Sony Computer Entertainment Europe.</em></p></figcaption>
</figure>
</section>
<section>
<h2 id="sec22_5"><a id="index_term411"/><a epub:type="backlink" href="C02a_toc.xhtml#rsec22_5" role="doc-backlink"><span class="green">22.5 The Game Production Process</span></a></h2>
<p>The <a id="index_term394"/>game production process starts with the basic game design or <a id="index_term391"/>concept. In some cases (such as sequels), the basic gameplay and visual design is clear, and only incremental changes are made. In the case of a new game type, extensive prototyping is needed to determine gameplay and design. Most cases sit somewhere in the middle, where there are some new gameplay elements and the visual design is somewhat open. After this step there may be a <em>greenlight</em> stage where <a id="term-306"/><a id="term-315"/><span aria-label="634" epub:type="pagebreak" id="pg_634" role="doc-pagebreak"/>some early demo or concept is shown to the game publisher to get approval (and funding!) for the game.</p>
<p>The next step is typically <em><a id="index_term409"/>pre-production</em>. While other teams are working on finishing up the last game, a small core team works on making any needed changes to the game engine and production tool chain, as well as working out the rough details of any new gameplay elements. This core team is working under a strict deadline. After the existing game ships and the rest of the team comes back from a well-deserved vacation, the entire tool chain and engine must be ready for them. If the core team misses this deadline, several dozen developers may be left idle—an extremely expensive proposition!</p>
<p>Full production is the next step, with the entire team creating art assets, designing levels, tweaking gameplay, and implementing further changes to the game engine. In a perfect world, everything done during this process would be used in the final game, but in reality there is an iterative nature to game development which will result in some work being thrown out and redone. The goal is to minimize this with careful planning and prototyping.</p>
<p>When the game is functionally complete, the final stage begins. The term <em>alpha release</em> usually refers to the version which marks the start of extensive internal testing, <em>beta release</em> to the one which marks the start of extensive external testing, and <em>gold release</em> to the final release submitted to the console manufacturer, <a id="term-311"/><span aria-label="635" epub:type="pagebreak" id="pg_635" role="doc-pagebreak"/>but different companies have slightly varying definitions of these terms. In any case, testing, or <em>quality assurance</em> (QA) is an important part of this phase, and it involves testers at the game development studio, at the publisher, at the console manufacturer, and possibly external QA contractors as well. These various rounds of testing result in bug reports which are submitted back to the game developers and worked on until the next release.</p>
<p>After the game ships, most of the developers go on vacation for a while, but a small team may have to stay to work on patches or downloadable content. In the meantime, a small core team has been working on pre-production for the next game.</p>
<p><a id="index_term387"/>Art asset creation is an aspect of game production that is particularly relevant to graphics development, so I will go into it in some detail.</p>
<section>
<h3 id="sec22_5_1"><span class="green">22.5.1 Asset Creation</span></h3>
<p>While the exact process of art asset creation varies from game to game, the outline I give here is fairly representative. In the past, a single artist would create an entire asset from start to finish, but this process is now much more specialized, involving people with different skill sets working on each asset at various times. Some of these <a id="index_term420"/>stages have clear dependencies (for example, a character cannot be animated until it is rigged and cannot be rigged before it is modeled). Most game developers have well-defined approval processes, where the art director or a lead artist signs off on each stage before the asset is sent on to the next. Ideally an asset proceeds through each stage exactly once, but in practice changes may be made that require resubmission.</p>
<section>
<h4 id="sec76"><a id="index_term398"/><span class="blue">Initial Modeling</span></h4>
<p>Typically the art asset creation process starts by modeling the object geometry. This step is performed in a general-purpose modeling package such as Maya, MAX or Softimage. The modeled geometry will be passed directly to the game engine, so it is important to minimize vertex count while preserving good silhouettes. Character <a id="index_term403"/>meshes must also be constructed so as to be amenable to animation.</p>
<p>In this stage, a two-dimensional surface parameterization for textures is usually created. It is important that this parameterization be highly continuous, since discontinuities require vertex duplication and may cause filtering artifacts. An example of a mesh with its associated texture parameterization is shown in <a href="C27_chapter22.xhtml#f22_5">Figure 22.5</a>.</p>
<figure id="f22_5" tabindex="0">
<img alt="" src="../images/fig22_5.jpg"/>
<figcaption><p><span class="blue">Figure 22.5.</span> <a id="term-310"/><a id="term-312"/><a id="term-322"/><a id="term-323"/><span aria-label="636" epub:type="pagebreak" id="pg_636" role="doc-pagebreak"/>A mesh being modeled in Maya, with associated texture parameterization. <em>Image courtesy Keith Bruns.</em></p></figcaption>
</figure>
</section>
<section>
<h4 id="sec77"><span class="blue">Texturing</span></h4>
<p>In the past, texturing was a straightforward process of painting a color texture, typically in Photoshop. Now, specialized detail modeling packages such as ZBrush or Mudbox are commonly used to sculpt fine surface detail. <a href="C27_chapter22.xhtml#f22_6">Figures 22.6</a> and <a href="C27_chapter22.xhtml#f22_7">22.7</a> show an example of this process.</p>
<figure id="f22_6" tabindex="0">
<img alt="" src="../images/fig22_6.jpg"/>
<figcaption><p><span class="blue">Figure 22.6.</span> The mesh from <a href="C27_chapter22.xhtml#f22_5">Figure 22.5</a> has been brought into ZBrush for detail modeling. <em>Image courtesy Keith Bruns.</em></p></figcaption>
</figure>
<figure id="f22_7" tabindex="0">
<img alt="" src="../images/fig22_7.jpg"/>
<figcaption><p><span class="blue">Figure 22.7.</span> The mesh from <a href="C27_chapter22.xhtml#f22_6">Figure 22.6</a>, with fine detail added to it in ZBrush. <em>Image courtesy Keith Bruns.</em></p></figcaption>
</figure>
<p>If this additional detail were to be represented with actual geometry, millions of triangles would be needed. Instead, the detail is commonly “baked” into a normal map which is applied onto the original, coarse mesh, as shown in <a href="C27_chapter22.xhtml#f22_8">Figures 22.8</a> and <a href="C27_chapter22.xhtml#f22_9">22.9</a>.</p>
<figure id="f22_8" tabindex="0">
<img alt="" src="../images/fig22_8.jpg"/>
<figcaption><p><span class="blue">Figure 22.8.</span> A visualization (in ZBrush) of the mesh from <a href="C27_chapter22.xhtml#f22_6">Figure 22.6</a>, rendered with a normal map derived from the detailed mesh in <a href="C27_chapter22.xhtml#f22_7">Figure 22.7</a>. The bottom of the figure shows the interface for ZBrush’s “Zmapper” tool, which was used to derive the normal map. <em>Image courtesy Keith Bruns.</em></p></figcaption>
</figure>
<figure id="f22_9" tabindex="0">
<img alt="" src="../images/fig22_9.jpg"/>
<figcaption><p><span class="blue">Figure 22.9.</span> The normal map used in <a href="C27_chapter22.xhtml#f22_8">Figure 22.8</a>. In this image, the red, green, and blue channels of the texture contain the X, Y, and Z coordinates of the surface normals. <em>Image courtesy Keith Bruns.</em></p></figcaption>
</figure>
<p><span aria-label="637" epub:type="pagebreak" id="pg_637" role="doc-pagebreak"/><span aria-label="638" epub:type="pagebreak" id="pg_638" role="doc-pagebreak"/>Besides normal maps, multiple textures containing surface properties such as diffuse color, specular color, and smoothness (specular power) are also created. These are either painted directly on the surface in the detail modeling application, or in a two-dimensional application such as Photoshop. All of these texture maps use the surface parameterization defined in the initial modeling phase. When the texture is painted in a two-dimensional painting application, the artist must frequently switch between the painting application and some other application which can show a three-dimensional rendering of the object with the texture applied. This iterative process is illustrated in <a href="C27_chapter22.xhtml#f22_10">Figures 22.10</a>, <a href="C27_chapter22.xhtml#f22_11">22.11</a>, <a href="C27_chapter22.xhtml#f22_12">22.12</a>, and <a href="C27_chapter22.xhtml#f22_13">22.13</a>.</p>
<figure id="f22_10" tabindex="0">
<img alt="" src="../images/fig22_10.jpg"/>
<figcaption><p><span class="blue">Figure 22.10.</span> <span aria-label="639" epub:type="pagebreak" id="pg_639" role="doc-pagebreak"/>An early version of a diffuse color texture for the mesh from <a href="C27_chapter22.xhtml#f22_8">Figure 22.8</a>, shown in Photoshop. <em>Image courtesy Keith Bruns.</em></p></figcaption>
</figure>
<figure id="f22_11" tabindex="0">
<img alt="" src="../images/fig22_11.jpg"/>
<figcaption><p><span class="blue">Figure 22.11.</span> A rendering (in ZBrush) of the mesh with normal map and early diffuse color texture (from <a href="C27_chapter22.xhtml#f22_10">Figure 22.10</a>) applied. <em>Image courtesy Keith Bruns.</em></p></figcaption>
</figure>
<figure id="f22_12" tabindex="0">
<img alt="" src="../images/fig22_12.jpg"/>
<figcaption><p><span class="blue">Figure 22.12.</span> <span aria-label="640" epub:type="pagebreak" id="pg_640" role="doc-pagebreak"/>Final version of the color texture from <a href="C27_chapter22.xhtml#f22_10">Figure 22.10</a>. <em>Image courtesy Keith Bruns.</em></p></figcaption>
</figure>
<figure id="f22_13" tabindex="0">
<img alt="" src="../images/fig22_13.jpg"/>
<figcaption><p><span class="blue">Figure 22.13.</span> Rendering of the mesh with normal map and final color texture (from <a href="C27_chapter22.xhtml#f22_12">Figure 22.12</a>) applied. <em>Image courtesy Keith Bruns.</em></p></figcaption>
</figure>
</section>
<section>
<h4 id="sec78"><a id="term-299"/><a id="term-309"/><a id="term-317"/><a id="term-319"/><a id="term-320"/><a id="term-321"/><span aria-label="641" epub:type="pagebreak" id="pg_641" role="doc-pagebreak"/><span class="blue">Shading</span></h4>
<p>Shaders are typically applied in the same application used for initial modeling. In this process, a shader (from the set of shaders defined for that game) is applied to the mesh. The various textures resulting from the detail modeling stage are applied as inputs to this shader, using the surface parameterization defined during initial modeling. Various other shader inputs are set via visual experimentation (“tweaking”); see <a href="C27_chapter22.xhtml#f22_14">Figure 22.14</a>.</p>
<figure id="f22_14" tabindex="0">
<img alt="" src="../images/fig22_14.jpg"/>
<figcaption><p><span class="blue">Figure 22.14.</span> Shader configuration in Maya. The interface on the right is used to select the shader, assign textures to shader inputs, and set the values of non-texture shader inputs (such as the “Specular Color” and “Specular Power” sliders). The rendering on the left is updated dynamically while these properties are modified, enabling immediate visual feedback. <em>Image courtesy Keith Bruns.</em></p></figcaption>
</figure>
</section>
<section>
<h4 id="sec79"><span class="blue">Lighting</span></h4>
<p>In the case of background scenery, lighting artists will typically start their work after modeling, texturing, and shading have been completed. Light sources are placed and their effect computed in a preprocessing step. The results of this process are stored in lightmaps for later use by the rendering engine.</p>
</section>
<section>
<h4 id="sec80"><span class="blue">Animation</span></h4>
<p>Character meshes undergo several additional steps related to animation. The primary method used to animate game characters is <em>skinning</em>. This requires a <em>rig</em>, consisting of a hierarchy of transform nodes that is attached to the character, a <a id="term-300"/><span aria-label="642" epub:type="pagebreak" id="pg_642" role="doc-pagebreak"/>process known as <em>rigging</em>. The area of effect of each transform node is painted onto a subset of mesh vertices. Finally, animators create animations that move, rotate, and scale these transform nodes, “dragging” the mesh behind them.</p>
<p>A typical game character will have many dozens of animations, corresponding to different modes of motion (walking, running, turning) as well as different actions such as attacks. In the case of a main character, the number of animations can be in the hundreds. Transitions between different animations also need to be defined.</p>
<p>For facial animation, another technique, called <em>morph targets</em> is sometimes employed. In this technique, the mesh vertices are directly manipulated to deform the mesh. Different copies of the deformed mesh are stored (e.g., for different facial expressions) and combined by the game engine at runtime. The creation of morph targets is shown in <a href="C27_chapter22.xhtml#f22_15">Figure 22.15</a>.</p>
<figure id="f22_15" tabindex="0">
<img alt="" src="../images/fig22_15.jpg"/>
<figcaption><p><span class="blue">Figure 22.15.</span> Morph target interface in Maya. The bottom row shows four different morph targets, and the model at the top shows the effects of combining several morph targets together. The interface at the upper left is used to control the degree to which each morph target is applied. <em>Image courtesy Keith Bruns.</em></p></figcaption>
</figure>
</section>
</section>
</section>
<section>
<h2 id="sec81"><span class="green">Notes</span></h2>
<p>There is a huge amount of information on <a id="index_term413"/>real-time rendering and game programming available, both in books and online. Here are some resources I can recommend from personal familiarity.</p>
<p><span aria-label="643" epub:type="pagebreak" id="pg_643" role="doc-pagebreak"/><em>Game Developer Magazine</em> is a good source of information on game development, as are slides from the talks given at the annual <em>Game Developers Conference</em> (GDC) and Microsoft’s <em>Gamefest</em> conference. The <em>GPU Gems</em> and <em>ShaderX</em> book series also contain good information—all of the former and the first two of the latter are also available online.</p>
<p>Eric Lengyel’s <em>Mathematics for 3D Game Programming &amp; Computer Graphics</em>, now in its second edition, is a good reference for the various types of math used in graphics and games. A specific area of game programming that is closely related to graphics is collision detection, for which Christer Ericson’s <em>Real-Time Collision Detection</em> is the definitive resource.</p>
<p>Since its first edition in 1999, Eric <a id="index_term511"/>Haines and Tomas <a id="index_term7"/>Akenine-Möller’s <em>Real-Time Rendering</em> has endeavored to cover this fast-growing field in a thorough manner. As a longtime fan of this book, I was glad to have the opportunity to be a coauthor on the third edition, which came out in mid-2008.</p>
<p>Reading is not enough—make sure you play a variety of games regularly to get a good idea of the requirements of various game types, as well as the current state of the art.</p>
</section>
<section>
<h2 id="sec82"><span class="green">Exercises</span></h2>
<p class="qpara"><span class="green">1.</span> Examine the visuals of two dissimilar games. What differences can you deduce in the graphics requirements of these two games? Analyze the effect on rendering time, storage budgets, etc.</p>
</section>
</section>
</body>
</html>