<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xmlns:m="http://www.w3.org/1998/Math/MathML" xmlns:svg="http://www.w3.org/2000/svg" dir="ltr" lang="en" xml:lang="en">
<head>
<meta charset="UTF-8"/>
<title>14 Physics-Based Rendering</title>
<link href="../styles/9781000426359.css" rel="stylesheet" type="text/css"/>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
jax: ["input/TeX","input/MathML","output/SVG"],
extensions: ["tex2jax.js","mml2jax.js","MathEvents.js"],
TeX: {
extensions: ["noErrors.js","noUndefined.js","autoload-all.js"]
},
MathMenu: {
showRenderer: false
},
menuSettings: {
zoom: "Click"
},
messageStyle: "none"
});
</script>
<script src="../mathjax/MathJax.js" type="text/javascript"/>
<meta content="urn:uuid:e0000000-0000-0000-0000-000006665500" name="Adept.expected.resource"/>
</head>
<body epub:type="bodymatter">
<section epub:type="chapter" role="doc-chapter">
<h1 class="chapz" id="c14"><a id="term-613"/><span aria-label="357" epub:type="pagebreak" id="pg_357" role="doc-pagebreak"/><a epub:type="backlink" href="C02a_toc.xhtml#rc14" role="doc-backlink"><span class="green"><span class="big1">14</span><br/>Physics-Based Rendering</span></a></h1>
<p>While all rendering is to some extent or another “physics-based,” the term “physics-based” implies in practice that we will adhere strictly to physics models rather than being “phenomenological,” which captures subjective perceptual features heuristically, such as an empirical formula that puts a highlight in the “right” place. This chapter covers physics-based rendering at a high level, defines the units and terms used in the area, and provides a brute force “path tracing” algorithm that can produce very accurate images very slowly. We do not delve into the details of the many rendering algorithms out there, but almost all of them can be viewed as improvements only over the brute force algorithm. Note that improvements in efficiency are why we have realistic graphics in movies and games and is nothing to be sneezed at; we don’t cover these details because they are a moving target and have good coverage out there in the ecosystem, most notably the superb PBRT book and code-base of <a id="index_term843"/>Pharr et al. (2016).</p>
<section>
<h2 id="sec14_1"><a id="index_term857"/><a epub:type="backlink" href="C02a_toc.xhtml#rsec14_1" role="doc-backlink"><span class="green">14.1 Photons</span></a></h2>
<p>To aid our intuition, we will describe radiometry in terms of collections of large numbers of <em>photons</em>, and this section establishes what is meant by a photon in this context. Note that in graphics, “photon” does not necessarily mean precisely what it does in physics and many physicists are confused when they read discussions of things like “photon tracing” written by graphics people. For us, a photon is <span aria-label="358" epub:type="pagebreak" id="pg_358" role="doc-pagebreak"/>usually just an energy packet that behaves in a way that obeys geometric optics (where light travels in straight lines and doesn’t have wave properties).</p>
<p>More precisely, for us a photon is a packet of light that has a position, direction of propagation, and a wavelength λ. Somewhat strangely, the SI unit used for <a id="index_term1458"/>wavelength is <em>nanometer</em> (nm). This is mainly for historical reasons, and 1 nm = 1<sup>−9</sup>m. Another unit, the <em>angstrom</em>, is sometimes used, and one <a id="index_term771"/>nanometer is ten <a id="index_term28"/>angstroms. A photon also has a speed c that depends only on the refractive index n of the medium through which it propagates. Sometimes the frequency <em>f = c∕λ</em> is also used for light. This is convenient because unlike λ and <em>c, f</em> does not change when the photon refracts into a medium with a new refractive index. Another invariant measure is the amount of energy <em>q</em> carried by a photon, which is given by the following relationship:</p>
<div class="disp-formula" id="equ14_1">
<m:math alttext=""><m:mrow><m:mrow><m:mi>q</m:mi><m:mo>=</m:mo><m:mi>h</m:mi><m:mi>f</m:mi><m:mo>=</m:mo><m:mfrac><m:mrow><m:mi>h</m:mi><m:mi>f</m:mi></m:mrow><m:mrow><m:mi>λ</m:mi></m:mrow></m:mfrac><m:mo>,</m:mo></m:mrow></m:mrow><m:mspace width="3em"/><m:mo>(14.1)</m:mo></m:math>
</div>
<p>where <em>h</em> = 6.63 × 10<sup>−34</sup> J s is Plank’s Constant. Although these quantities can be measured in any unit system, we will use SI units whenever possible.</p>
</section>
<section>
<h2 id="sec14_2"><a epub:type="backlink" href="C02a_toc.xhtml#rsec14_2" role="doc-backlink"><span class="green">14.2 Smooth Metals</span></a></h2>
<p>For a <a id="index_term859"/>smooth metal, light either reflects specularly as described in <a href="C09_chapter4.xhtml#sec4_5_4">Section 4.5.4</a> or is refracted into the surface and then quickly absorbed (with very thin metal coats as sometimes done to glass, you can see light making it all the way through and that metals are not actually opaque). The amount of light reflected is determined by the <em>Fresnel equations</em>. These equations are straightforward, but cumbersome. In addition, their values vary with the polarization of the light, a characteristic usually ignored in graphics. The main visual effect of the Fresnel equations is that the reflectance increases with the incident angle, particularly near grazing angles where it goes to 100%.</p>
<p>Almost all graphics programs use a simple approximation for the Fresnel equations developed by Schlick (1994). For a metal, we typically specify the reflectance at normal incidence R<sub>0</sub>(λ). The reflectance should vary according to the <a id="index_term383"/>Fresnel equations, and a good approximation is given by <a id="index_term1021"/>Schlick (1994)</p>
<div class="disp-formula" id="equ14_2">
<m:math alttext=""><m:mrow><m:mrow><m:mi>R</m:mi><m:mo>(</m:mo><m:mi>θ</m:mi><m:mo>,</m:mo><m:mi>λ</m:mi><m:mo>)</m:mo><m:mo>=</m:mo><m:msub><m:mrow><m:mi>R</m:mi></m:mrow><m:mrow><m:mn>0</m:mn></m:mrow></m:msub><m:mo>(</m:mo><m:mi>λ</m:mi><m:mo>)</m:mo><m:mo>+</m:mo><m:mo>(</m:mo><m:mn>1</m:mn><m:mo>−</m:mo><m:msub><m:mrow><m:mi>R</m:mi></m:mrow><m:mrow><m:mn>0</m:mn></m:mrow></m:msub><m:mo>(</m:mo><m:mi>λ</m:mi><m:mo>)</m:mo><m:mo>)</m:mo><m:msup><m:mrow><m:mo>(</m:mo><m:mn>1</m:mn><m:mo>−</m:mo><m:mi>cos</m:mi><m:mo>⁡</m:mo><m:mi>θ</m:mi><m:mo>)</m:mo></m:mrow><m:mrow><m:mn>5</m:mn></m:mrow></m:msup><m:mo>,</m:mo></m:mrow></m:mrow><m:mspace width="3em"/><m:mo>(14.2)</m:mo></m:math>
</div>
<p>where <em>θ</em> is the angle between the direction of light propagation and the surface normal. Here, this approximation allows us to just set the normal <a id="index_term969"/>reflectance of the <a id="index_term737"/>metal either from data or by eye.</p>
</section>
<section>
<h2 id="sec14_3"><a id="index_term854"/><a id="term-609"/><span aria-label="359" epub:type="pagebreak" id="pg_359" role="doc-pagebreak"/><a epub:type="backlink" href="C02a_toc.xhtml#rsec14_3" role="doc-backlink"><span class="green">14.3 Smooth Dielectrics</span></a></h2>
<p>Dielectrics are clear materials that refract light, and it is not a bad heuristic that if they are not a metal, they are dielectrics. So skin, milk, hair, cloth, and almost all everyday materials are dielectrics, although that is not obvious as they tend to be opaque because they are a mixture of different refractive indices and light-absorbing impurities. But smooth homogeneous dielectrics are transparent, and examples are glass, water, and the lens in the eye. For a smooth dielectric, there are only three important properties:</p>
<ol class="list-order">
<li>
<p class="list">How much light is reflected at each incident angle and wavelength.</p>
</li>
<li>
<p class="list">What fraction of light is absorbed as it travels through the material for a given distance and wavelength.</p>
</li>
<li>
<p class="list">what are the directions of the reflected and refracted light.</p>
</li>
</ol>
<section>
<h3 id="sec14_3_1"><a id="index_term973"/><span class="green">14.3.1 Reflectivity of a Dielectric</span></h3>
<p>How light bends geometrically and what fraction is reflected/transmitted depends on the refractive index <em>n</em>(λ) of the material. For a dielectric, the same Schlick Equation 14.2 for reflectance works as does with metals. However, when one of the materials is air, we can set <em>R</em><sub>0</sub>(λ) in terms of the n(λ)</p>
<div class="disp-formula" id="uequ14_1">
<m:math alttext=""><m:mrow><m:mrow><m:msub><m:mrow><m:mi>R</m:mi></m:mrow><m:mrow><m:mn>0</m:mn></m:mrow></m:msub><m:mo>(</m:mo><m:mi>λ</m:mi><m:mo>)</m:mo><m:mo>=</m:mo><m:msup><m:mrow><m:mo>(</m:mo><m:mfrac><m:mrow><m:mi>n</m:mi><m:mo>(</m:mo><m:mi>λ</m:mi><m:mo>)</m:mo><m:mo>−</m:mo><m:mn>1</m:mn></m:mrow><m:mrow><m:mi>n</m:mi><m:mo>(</m:mo><m:mi>λ</m:mi><m:mo>)</m:mo><m:mo>+</m:mo><m:mn>1</m:mn></m:mrow></m:mfrac><m:mo>)</m:mo></m:mrow><m:mrow><m:mn>2</m:mn></m:mrow></m:msup><m:mn>.</m:mn></m:mrow></m:mrow></m:math>
</div>
<p>In the case where the refractive indices on either side of the equations are not 1.0 (like air or vacuum), then this formula applies:</p>
<div class="disp-formula" id="uequ14_2">
<m:math alttext=""><m:mrow><m:mrow><m:msub><m:mrow><m:mi>R</m:mi></m:mrow><m:mrow><m:mn>0</m:mn></m:mrow></m:msub><m:mo>(</m:mo><m:mi>λ</m:mi><m:mo>)</m:mo><m:mo>=</m:mo><m:msup><m:mrow><m:mo>(</m:mo><m:mfrac><m:mrow><m:msub><m:mrow><m:mi>n</m:mi></m:mrow><m:mrow><m:mi>t</m:mi></m:mrow></m:msub><m:mo>(</m:mo><m:mi>λ</m:mi><m:mo>)</m:mo><m:mo>−</m:mo><m:msub><m:mrow><m:mi>n</m:mi></m:mrow><m:mrow><m:mi>i</m:mi></m:mrow></m:msub><m:mo>(</m:mo><m:mi>λ</m:mi><m:mo>)</m:mo></m:mrow><m:mrow><m:msub><m:mrow><m:mi>n</m:mi></m:mrow><m:mrow><m:mi>t</m:mi></m:mrow></m:msub><m:mo>(</m:mo><m:mi>λ</m:mi><m:mo>)</m:mo><m:mo>+</m:mo><m:msub><m:mrow><m:mi>n</m:mi></m:mrow><m:mrow><m:mi>i</m:mi></m:mrow></m:msub><m:mo>(</m:mo><m:mi>λ</m:mi><m:mo>)</m:mo></m:mrow></m:mfrac><m:mo>)</m:mo></m:mrow><m:mrow><m:mn>2</m:mn></m:mrow></m:msup><m:mn>.</m:mn></m:mrow></m:mrow></m:math>
</div>
<p>Typically, <em>n</em> does not vary with wavelength, but for applications where dispersion (the different wavelengths disperse from each other and we get rainbows) is important, <em>n</em> can vary. The refractive indices that are often useful include water (<em>n</em> = 1.33), glass (<em>n</em> = 1.4 to <em>n</em> = 1.7), and diamond (<em>n</em> = 2.4).</p>
<p>The amount of light transmitted is whatever is not reflected (a result of energy conservation). So we don’t need to explicitly compute a formula for the transmitted fraction.</p>
</section>
<section>
<h3 id="sec14_3_2"><a id="index_term974"/><a id="index_term77"/><span aria-label="360" epub:type="pagebreak" id="pg_360" role="doc-pagebreak"/><span class="green">14.3.2 Refraction and Beer’s Law</span></h3>
<p>Dielectrics also filter and refract light; some glass filters out more red and blue light than green light, so the glass takes on a green tint. When a ray travels from a medium with refractive index <em>n</em> into one with a refractive index <em>n</em><sub>t</sub>, some of the light is transmitted, and it bends. This is shown for n<sub>t</sub> &gt; <em>n</em> in <a href="C19_chapter14.xhtml#f14_1">Figure 14.1</a>. Snell’s law tells us that</p>
<div class="disp-formula" id="uequ14_3">
<m:math alttext=""><m:mrow><m:mrow><m:mi>n</m:mi><m:mo>⁢</m:mo><m:mtext> </m:mtext><m:mi>sin</m:mi><m:mo>⁡</m:mo><m:mi>θ</m:mi><m:mo>=</m:mo><m:msub><m:mrow><m:mi>n</m:mi></m:mrow><m:mrow><m:mi>t</m:mi></m:mrow></m:msub><m:mtext> </m:mtext><m:mi>sin</m:mi><m:mo>⁡</m:mo><m:mi>φ</m:mi><m:mn>.</m:mn></m:mrow></m:mrow></m:math>
</div>
<figure id="f14_1" tabindex="0">
<img alt="" src="../images/fig14_2.jpg"/>
<figcaption><p><span class="blue">Figure 14.1.</span> Snell’s law describes how the angle <em>ϕ</em> depends on the angle <em>θ</em> and the refractive indices of the object and the surrounding medium.</p></figcaption>
</figure>
<aside class="boxed-text" epub:type="sidebar" id="c014_box1">
<p class="noindent">Example values of <em>n</em>: air: 1.00; water: 1.33–1.34; window glass: 1.51; optical glass: 1.49–1.92; diamond: 2.42.</p>
</aside>
<p class="noindent">Computing the sine of an angle between two vectors is usually not as convenient as computing the cosine, which is a simple dot product for the unit vectors such as we have here. Using the trigonometric identity sin<sup>2</sup><em>θ</em> + cos<sup>2</sup><em>θ</em> = 1, we can derive a refraction relationship for cosines:</p>
<div class="disp-formula" id="uequ14_4">
<m:math alttext=""><m:mrow><m:mrow><m:msup><m:mrow><m:mi>cos</m:mi><m:mo>⁡</m:mo></m:mrow><m:mrow><m:mn>2</m:mn></m:mrow></m:msup><m:mi>φ</m:mi><m:mo>=</m:mo><m:mn>1</m:mn><m:mo>−</m:mo><m:mfrac><m:mrow><m:msup><m:mrow><m:mi>n</m:mi></m:mrow><m:mrow><m:mn>2</m:mn></m:mrow></m:msup><m:mrow><m:mo>(</m:mo><m:mn>1</m:mn><m:mo>−</m:mo><m:msup><m:mrow><m:mi>cos</m:mi><m:mo>⁡</m:mo></m:mrow><m:mrow><m:mn>2</m:mn></m:mrow></m:msup><m:mi>φ</m:mi><m:mo>)</m:mo></m:mrow></m:mrow><m:mrow><m:msubsup><m:mrow><m:mi>n</m:mi></m:mrow><m:mrow><m:mi>t</m:mi></m:mrow><m:mrow><m:mn>2</m:mn></m:mrow></m:msubsup></m:mrow></m:mfrac><m:mn>.</m:mn></m:mrow></m:mrow></m:math>
</div>
<p>Note that if <em>n</em> and <em>n<sub>t</sub></em> are reversed, then so are θ and <em>ϕ</em> as shown in right of <a href="C19_chapter14.xhtml#f14_1">Figure 14.1</a>.</p>
<p>To convert sin<em>ϕ</em> and cos<em>ϕ</em> into a 3D vector, we can set up a 2D orthonormal basis in the plane of the surface normal, <strong>n</strong>, and the ray direction, <strong>d</strong>.</p>
<p>From <a href="C19_chapter14.xhtml#f14_2">Figure 14.2</a>, we can see that <strong>n</strong> and <strong>b</strong> form an orthonormal basis for the plane of refraction. By definition, we can describe the direction of the transformed ray, <strong>t</strong>, in terms of this basis:</p>
<div class="disp-formula" id="uequ14_5">
<m:math alttext=""><m:mrow><m:mrow><m:mi mathvariant="bold">t</m:mi><m:mo>=</m:mo><m:mi>sin</m:mi><m:mo>⁡</m:mo><m:mi>φ</m:mi><m:mi mathvariant="bold">b</m:mi><m:mo>−</m:mo><m:mi>cos</m:mi><m:mo>⁡</m:mo><m:mi>φ</m:mi><m:mi mathvariant="bold">n</m:mi><m:mn>.</m:mn></m:mrow></m:mrow></m:math>
</div>
<figure id="f14_2" tabindex="0">
<img alt="" src="../images/fig14_3.jpg"/>
<figcaption><p><span class="blue">Figure 14.2.</span> The vectors <strong>n</strong> and <strong>b</strong> form a 2D orthonormal basis that is parallel to the transmission vector <strong>t</strong>.</p></figcaption>
</figure>
<p><span aria-label="361" epub:type="pagebreak" id="pg_361" role="doc-pagebreak"/>Since we can describe <strong>d</strong> in the same basis, and <strong>d</strong> is known, we can solve for <strong>b</strong>:</p>
<div class="disp-formula" id="uequ14_6">
<m:math xmlns:mml="http://www.w3.org/1998/Math/MathML" alttext=""><m:mrow><m:mtable columnalign="left"><m:mtr><m:mtd><m:mi mathvariant="bold">d</m:mi><m:mo>=</m:mo><m:mi>sin</m:mi><m:mo>⁡</m:mo><m:mi>θ</m:mi><m:mi mathvariant="bold">b</m:mi><m:mo>−</m:mo><m:mi>cos</m:mi><m:mo>⁡</m:mo><m:mi>θ</m:mi><m:mi mathvariant="bold">n</m:mi><m:mo>,</m:mo></m:mtd></m:mtr><m:mtr><m:mtd><m:mi mathvariant="bold">b</m:mi><m:mo>=</m:mo><m:mfrac><m:mrow><m:mi mathvariant="bold">d</m:mi><m:mo>+</m:mo><m:mi mathvariant="bold">n</m:mi><m:mo>⁢</m:mo><m:mi>cos</m:mi><m:mo>⁡</m:mo><m:mi>θ</m:mi></m:mrow><m:mrow><m:mi>sin</m:mi><m:mo>⁡</m:mo><m:mi>θ</m:mi></m:mrow></m:mfrac><m:mn>.</m:mn></m:mtd></m:mtr></m:mtable></m:mrow></m:math>
</div>
<p>This means that we can solve for <strong>t</strong> with known variables:</p>
<div class="disp-formula" id="uequ14_7">
<m:math xmlns:mml="http://www.w3.org/1998/Math/MathML" alttext=""><m:mrow><m:mtable><m:mtr><m:mtd><m:mi mathvariant="bold">t</m:mi></m:mtd><m:mtd columnalign="left"><m:mo>=</m:mo><m:mfrac><m:mrow><m:mi>n</m:mi><m:mo>(</m:mo><m:mi mathvariant="bold">d</m:mi><m:mo>+</m:mo><m:mi mathvariant="bold">n</m:mi><m:mo>⁢</m:mo><m:mi>cos</m:mi><m:mo>⁡</m:mo><m:mi>θ</m:mi><m:mo>)</m:mo></m:mrow><m:mrow><m:msub><m:mrow><m:mi>n</m:mi></m:mrow><m:mrow><m:mi>t</m:mi></m:mrow></m:msub></m:mrow></m:mfrac><m:mo>−</m:mo><m:mi mathvariant="bold">n</m:mi><m:mtext> </m:mtext><m:mi>cos</m:mi><m:mo>⁡</m:mo><m:mi>φ</m:mi></m:mtd></m:mtr><m:mtr><m:mtd/><m:mtd columnalign="left"><m:mo>=</m:mo><m:mfrac><m:mrow><m:mi>n</m:mi><m:mo>(</m:mo><m:mi mathvariant="bold">d</m:mi><m:mo>−</m:mo><m:mi mathvariant="bold">n</m:mi><m:mo>(</m:mo><m:mi mathvariant="bold">d</m:mi><m:mo>⋅</m:mo><m:mi mathvariant="bold">n</m:mi><m:mo>)</m:mo><m:mo>)</m:mo></m:mrow><m:mrow><m:msub><m:mrow><m:mi>n</m:mi></m:mrow><m:mrow><m:mi>t</m:mi></m:mrow></m:msub></m:mrow></m:mfrac><m:mo>−</m:mo><m:mi mathvariant="bold">n</m:mi><m:msqrt><m:mrow><m:mn>1</m:mn><m:mo>−</m:mo><m:mfrac><m:mrow><m:msup><m:mrow><m:mi>n</m:mi></m:mrow><m:mrow><m:mn>2</m:mn></m:mrow></m:msup><m:mrow><m:mo>(</m:mo><m:mn>1</m:mn><m:mo>−</m:mo><m:mrow><m:mo>(</m:mo><m:mi mathvariant="bold">d</m:mi><m:mo>⋅</m:mo><m:mi mathvariant="bold">n</m:mi><m:msup><m:mrow><m:mo>)</m:mo></m:mrow><m:mrow><m:mn>2</m:mn></m:mrow></m:msup></m:mrow><m:mo>)</m:mo></m:mrow></m:mrow><m:mrow><m:msubsup><m:mrow><m:mi>n</m:mi></m:mrow><m:mrow><m:mi>t</m:mi></m:mrow><m:mrow><m:mn>2</m:mn></m:mrow></m:msubsup></m:mrow></m:mfrac><m:mn>.</m:mn></m:mrow></m:msqrt></m:mtd></m:mtr></m:mtable></m:mrow></m:math>
</div>
<p>Note that this equation works regardless of which of n and n<sub>t</sub> is larger. An immediate question is, “What should you do if the number under the square root is negative?” In this case, there is no refracted ray and all of the energy is reflected. This is known as <em>total internal reflection</em>,, and it is responsible for much of the rich appearance of glass objects.</p>
<p>For homogeneous impurities, as is found in typical colored glass, a light-carrying ray’s intensity will be attenuated according to <em>Beer’s Law</em>. As the ray travels through the medium, it loses intensity according to <em>dI</em> = −<em>CI dx</em>, where <em>dx</em> is distance. Thus, <em>dI∕dx = -CI</em>. We can solve this equation and get the exponential <em>I</em> = <em>k</em> exp(<em>-Cx</em>). The degree of attenuation is described by the RGB attenuation constant a, which is the amount of attenuation after one unit of distance. Putting in boundary conditions, we know that <em>I</em>(0) = <em>I</em><sub>0</sub>, and <em>I</em>(1) = <em>aI</em>(0). The former implies <em>I(x)</em> = <em>I</em><sub>0</sub> exp(-<em>Cx</em>). The latter implies <em>I</em><sub>0</sub><em>a</em> = <em>I</em><sub>0</sub> exp(-<em>C</em>), so - <em>C</em> = ln(<em>a</em>). Thus, the final formula is</p>
<div class="disp-formula" id="uequ14_8">
<m:math alttext=""><m:mrow><m:mrow><m:mi>I</m:mi><m:mrow><m:mo>(</m:mo><m:mi>s</m:mi><m:mo>)</m:mo><m:mo>=</m:mo><m:mi>I</m:mi><m:mrow><m:mo>(</m:mo><m:mn>0</m:mn><m:mo>)</m:mo></m:mrow><m:msup><m:mrow><m:mi>e</m:mi></m:mrow><m:mrow><m:mi>ln</m:mi><m:mo>⁡</m:mo><m:mrow><m:mo>(</m:mo><m:mi>a</m:mi><m:mo>)</m:mo><m:mi>s</m:mi></m:mrow></m:mrow></m:msup><m:mo>,</m:mo></m:mrow></m:mrow></m:mrow></m:math>
</div>
<p>where <em>I(s)</em> is the intensity of the beam at distance s from the interface. Because the exponential of the log is there, we can also write that as</p>
<div class="disp-formula" id="uequ14_9">
<m:math alttext=""><m:mrow><m:mrow><m:mi>I</m:mi><m:mrow><m:mo>(</m:mo><m:mi>s</m:mi><m:mo>)</m:mo><m:mo>=</m:mo><m:mi>I</m:mi><m:mrow><m:mo>(</m:mo><m:mn>0</m:mn><m:mo>)</m:mo></m:mrow><m:msup><m:mrow><m:mi>a</m:mi></m:mrow><m:mrow><m:mi>s</m:mi></m:mrow></m:msup><m:mn>.</m:mn></m:mrow></m:mrow></m:mrow></m:math>
</div>
<p>In practice, we reverse-engineer a by eye, because such data are rarely easy to find. The effect of Beer’s law can be seen in <a href="C19_chapter14.xhtml#f14_3">Figure 14.3</a>, where the glass takes on a green tint.</p>
<figure id="f14_3" tabindex="0">
<img alt="" src="../images/fig14_4.jpg"/>
<figcaption><p><span class="blue">Figure 14.3.</span> The color of the glass is affected by <a id="index_term1232"/>total internal reflection and Beer’s law. The amount of light transmitted and reflected is determined by the Fresnel equations. Note that when light comes in at normal incidence, more is transmitted.</p></figcaption>
</figure>
<p>This effect works for transmitted light as well. These ideas are shown diagrammatically in <a href="C19_chapter14.xhtml#f14_4">Figure 14.4</a>. Note that the light is repeatedly reflected and refracted as shown in <a href="C19_chapter14.xhtml#f14_5">Figure 14.5</a>. Usually, only one or two of the reflected images is easily visible.</p>
<figure id="f14_4" tabindex="0">
<img alt="" src="../images/fig14_1.jpg"/>
<figcaption><p><span class="blue">Figure 14.4.</span> The amount of light reflected and transmitted by glass varies with the angle.</p></figcaption>
</figure>
<figure id="f14_5" tabindex="0">
<img alt="" src="../images/fig14_5.jpg"/>
<figcaption><p><span class="blue">Figure 14.5.</span> Light is repeatedly reflected and refracted by glass, with the fractions of energy shown.</p></figcaption>
</figure>
</section>
</section>
<section>
<h2 id="sec14_4"><a id="index_term1135"/><span aria-label="362" epub:type="pagebreak" id="pg_362" role="doc-pagebreak"/><a epub:type="backlink" href="C02a_toc.xhtml#rsec14_4" role="doc-backlink"><span class="green">14.4 Dielectrics with Subsurface Scattering</span></a></h2>
<p>With just smooth dielectrics we can render a surprising array of materials. Many surfaces that look “matte” and opaque can be simulated as multiple dielectrics. Consider a perfect ice cube. It will look like a block of glass, just with less bend in its refraction (ice has a lower refractive index than glass does). Now place many small spherical air pockets inside that ice cube, and it will become increasingly opaque as more air bubbles are added.</p>
<p>This basic idea of scattering elements that could be air or other substances is responsible for much to the opacity we see. Another way to make the ice cube look opaque is to roughen the surface. This could be done on a computer graphics model by finely tessellating the surface and then doing a small random perturbation of the position of every triangle vertex. This would have an effect much like that of frosted glass (which is essentially that sort of surface) where opacity emerges the more rough the perturbation is.</p>
<p>Further complexity can be achieved by inserting particles that have a color and thus activate Beer’s law. This is a fairly easy and surprisingly accurate way to simulate paint.</p>
<p>There are a wealth of materials whose complexity can be simulated with explicit modeling of the microstructure. For example, human skin can modeled as a rough surface and layers of slightly different refractive index, pigment particles (obeying Beer’s law), and blood (obeying Beer’s law).</p>
</section>
<section>
<h2 id="sec14_5"><a id="index_term853"/><a id="index_term849"/><a id="term-608"/><span aria-label="363" epub:type="pagebreak" id="pg_363" role="doc-pagebreak"/><a epub:type="backlink" href="C02a_toc.xhtml#rsec14_5" role="doc-backlink"><span class="green">14.5 A Brute Force Photon Tracer</span></a></h2>
<p>Suppose we do model a scene as dielectrics with microstructure and one light-emitting object? How could we most simply render it and produce an image? In this section, we discuss how to just simulate the photons brute force, and then how to do that in reverse sending adjoint (backward) photons from the sensor. This can actually produce some of the best pictures possible in graphics, with very little code, but will be extremely slow.</p>
<section>
<h3 id="sec14_5_1"><span class="green">14.5.1 Sensor</span></h3>
<p>In order to produce an image, we must have some concept of an image capture device. A simple one would be a simple array of sensors (like a CCD) and a box with a small hole in it so it acts like a pinhole camera. Each sensor in the array essentially acts as a photon counter (with some wavelengths causing more of a response than others). After bombarding it with photons, the sensor array will have values that can be written out as an image. Sensors that receive few photons will be written to black, and those that receive a lot will be written to white, with various grayscales in between.</p>
<p>To produce a color image, we can put red green and blue filters in some pattern in front of the sensors. The simplest filters would be bandpass filters:</p>
<ul class="list-simple">
<li><p class="list-item"><strong>blue</strong> no response except for λ ∈ [400, 500 nm] which have full response.</p></li>
<li><p class="list-item"><strong>green</strong> no response except for λ ∈ [500, 600 nm] which have full response.</p></li>
<li><p class="list-item"><strong>red</strong> no response except for λ ∈ [600, 700 nm] which have full response.</p></li>
</ul>
<p>If you initialize all the sensors to zero, then full response just means to increment the number stored in the sensor when the photon hits it.</p>
</section>
<section>
<h3 id="sec14_5_2"><span class="green">14.5.2 Photon Tracer</span></h3>
<p>To trace the photons, pick a random point on the light source, and pick a random direction and a random wavelength between 400 and 700 nm (other wavelengths won’t influence the <a id="index_term1028"/>sensor array so don’t need to be computed). Now trace the ray in the same way as described in <a href="C09_chapter4.xhtml#c4">Chapter 4</a>. When it hits a surface, compute its reflectance and decide whether to reflect or refract. This decision is made by evaluating the <a id="index_term1020"/>Schlick approximation for that <a id="index_term1459"/>wavelength and incident angle and let’s call that <em>R</em>. Now generate a uniform random number ξ ∈ [0,1).</p>
<pre class="pre"><span aria-label="364" epub:type="pagebreak" id="pg_364" role="doc-pagebreak"/><br/>if (ξ &lt; R)<br/>     generate a reflection photon (ray) and trace it<br/>else<br/>     generate a refraction photon (ray) and trace it</pre>
<p class="noindent1">If the surface is metal, then this changes only in that the photon is absorbed in the refraction case and we start a new one at the light.</p>
<p>If the photon enters a dielectric and the Beer’s law coefficient is not one (meaning it absorbs light like the green glass), then the photon might probabilistically be absorbed (and thus die). We use the same basic technique as with deciding between reflection and refraction to decide:</p>
<pre class="pre">if (ξ &lt; probability of absorption)<br/>    absorb and start new photon<br/>else<br/>    allow this photon to exit medium at the next hit</pre>
<p class="noindent1">The procedure above is all that is needed to create great images! Just it will be slow.</p>
</section>
<section>
<h3 id="sec14_5_3"><a id="index_term756"/><a id="index_term313"/><span class="green">14.5.3 Motion and Defocus Blur</span></h3>
<p>The pinhole camera above will produce very sharp images just like a real pinhole camera will. But it will need long exposures because very few photons are lucky enough to make it through the pinhole before being absorbed.</p>
<p>We can solve this by adding a lens to the camera by making the pinhole bigger and placing the lens in that hole. We can model a real set of compound glass lens, or we can insert an ideal thin lens.</p>
<p>The simplest glass lens we could make it the intersection of two spheres (a “bi-convex spherical lens”). This has decent imaging properties (though not as good as the compound lenses in most real cameras) and is pretty easy to do ray intersection code for.</p>
<p>A thin lens is an idealized lens that is infinitely thin (so would be a disk in a ray tracing program) and is specified only with a radius (physical size of the lens) and a focal length f. The thin lens can be implemented by enforcing the following three properties:</p>
<ol class="list-order">
<li>
<p class="list">A ray leaving a 3D point <strong>p</strong> that goes to the lens center will not be bent (we call this line from that point through the center line of <strong>p</strong>).</p>
</li>
<li>
<p class="list"><span aria-label="365" epub:type="pagebreak" id="pg_365" role="doc-pagebreak"/>A all lines leaving <strong>p</strong> that hits the lens will converge at a point <strong>q</strong> on the center line.</p>
</li>
<li>
<p class="list">The distance a <em>along the lens optical axis</em> of the point <strong>p</strong> and the distance b of the point <strong>q</strong> along the lens optical axis obey the thin lens rule: 1∕<em>a</em> + 1∕<em>b</em> = 1∕<em>f</em>.</p>
</li>
</ol>
<p>By “along the optical axis,” we wean distance along the axis perpendicular to the lens (so “aiming” along the ray).</p>
<p>Note that having a real or ideal lens will automatically give the kind of blurring one gets in real photos, which is usually called <em>defocus blur</em> or <em>depth of</em> <em>field</em>.</p>
<p>To account for <em><a id="index_term759"/>motion blur</em>, where moving objects are blurred in a photo, or where a moving camera blurs objects not moving at the same speed as a camera (e.g., think of a photo taken from a train where the train interior is sharp and the scenery is blurry). This effect comes automatically if we support two features:</p>
<ul class="list-bullet">
<li>
<p class="list">Photons are emitted from light with a random time within the time interval where the camera is recording (or the camera shutter is open).</p>
</li>
<li>
<p class="list">The ray tracer has the concept of moving objects to the ray intersection code takes time as an argument.</p>
</li>
</ul>
<p>A simple example of a moving object would be a sphere whose center follows a line based on time:</p>
<div class="disp-formula" id="uequ14_10">
<m:math alttext=""><m:mrow><m:mrow><m:mi mathvariant="bold">c</m:mi><m:mrow><m:mo mathvariant="normal">(</m:mo><m:mi mathvariant="normal">t</m:mi><m:mi mathvariant="normal">i</m:mi><m:mi mathvariant="normal">m</m:mi><m:mi mathvariant="normal">e</m:mi><m:mo mathvariant="normal">)</m:mo><m:mo mathvariant="normal">=</m:mo><m:mi mathvariant="bold">g</m:mi><m:mo mathvariant="normal">+</m:mo><m:mi mathvariant="normal">t</m:mi><m:mi mathvariant="normal">i</m:mi><m:mi mathvariant="normal">m</m:mi><m:mi mathvariant="normal">e</m:mi><m:mo mathvariant="normal">*</m:mo><m:mrow><m:mo mathvariant="normal">(</m:mo><m:mi mathvariant="bold">h</m:mi><m:mo mathvariant="normal">−</m:mo><m:mi mathvariant="bold">g</m:mi><m:mo mathvariant="normal">)</m:mo><m:mn mathvariant="normal">.</m:mn></m:mrow></m:mrow></m:mrow></m:mrow></m:math>
</div>
</section>
<section>
<h3 id="sec14_5_4"><a id="index_term994"/><span class="green">14.5.4 Reversing Time</span></h3>
<p>The photon tracer above will work and work well, but will be very slow because even after you insert a lens, most photons will never hit the lens (if you simulate the sun as the light source, you will be lucky to have any of the photons make it to the camera).</p>
<p>Something usually done in graphics is to reverse time and send rays from the camera and record them when they hit the light. This is remarkably easy in the photon tracer we have made. Instead, we send photons (technically <em>adjoint</em> photons) from each pixel and see where they hit light sources. The <a id="index_term1460"/>wavelength of these photons is determined by treating the colored filters as light emission curves, and when we hit a light, we record the photon (on the pixel sensor array) with a weight of the emitted light.</p>
</section>
</section>
<section>
<h2 id="sec14_6"><a id="index_term927"/><a id="term-660"/><span aria-label="366" epub:type="pagebreak" id="pg_366" role="doc-pagebreak"/><a epub:type="backlink" href="C02a_toc.xhtml#rsec14_6" role="doc-backlink"><span class="green">14.6 Radiometry</span></a></h2>
<p>In practice, the brute force renderer of the last section is not feasible for applications. So rather than modeling microgeometry, we model bulk behavior. This is done using the the tools for the practical issues of measuring light, usually called <em>radiometry</em>. The terms that arise in radiometry may at first seem strange and have terminology and notation that may be hard to keep straight. The most important quantity of this section is <em>radiance</em>, but most graphics people if they do learn what radiance is map it to the intuitive concepts of brightness/color/intensity, and in practice, this works 99% of the time. But sometimes, the actual definitions are needed we provide them here.</p>
<p>Although we can define radiometric units in many systems, we use <em>SI</em> (International System of Units) units. Familiar SI units include the metric units of <em>meter</em> (<em>m</em>) and <em>gram</em> (<em>g</em>). Light is fundamentally a propagating form of energy, so it is useful to define the SI unit of energy, which is the <em>joule</em> (<em>J</em>).</p>
<section>
<h3 id="sec14_6_1"><a id="index_term1111"/><span class="green">14.6.1 Spectral Energy</span></h3>
<p>If we have a large collection of photons, their total energy <em>Q</em> can be computed by summing the energy <em>q</em><sub>i</sub> of each photon. A reasonable question to ask is “How is the energy distributed across wavelengths?” An easy way to answer this is to partition the photons into bins, essentially histogramming them. We then have an energy associated with an interval. For example, we can count all the energy between λ = 500 nm and λ = 600 nm and have it turn out to be 10.2 J, and this might be denoted <em>q</em>[500,600] = 10.2. If we divided the wavelength interval into two 50 nm intervals, we might find that <em>q</em>[500,550] = 5.2 and <em>q</em>[550,600] = 5.0. This tells us there was a little more energy in the short wavelength half of the interval [500,600]. If we divide into 25 nm bins, we might find <em>q</em>[500,525] = 2.5, and so on. The nice thing about the system is that it is straightforward. The bad thing about it is that the choice of the interval size determines the number.</p>
<p>A more commonly used system is to divide the energy by the size of the interval. So instead of <em>q</em>[500,600] = 10.2, we would have</p>
<div class="disp-formula" id="uequ14_11">
<m:math alttext=""><m:mrow><m:mrow><m:msub><m:mrow><m:mi>Q</m:mi></m:mrow><m:mrow><m:mi>λ</m:mi><m:mo>[</m:mo><m:mn>500</m:mn><m:mo>,</m:mo><m:mn>600</m:mn><m:mo>]</m:mo></m:mrow></m:msub><m:mo>=</m:mo><m:mfrac><m:mrow><m:mn>10.2</m:mn></m:mrow><m:mrow><m:mn>100</m:mn></m:mrow></m:mfrac><m:mo>=</m:mo><m:mn>0.12</m:mn><m:msup><m:mrow><m:mtext>J(nm)</m:mtext></m:mrow><m:mrow><m:mo>−</m:mo><m:mn>1</m:mn></m:mrow></m:msup><m:mn>.</m:mn></m:mrow></m:mrow></m:math>
</div>
<p>This approach is nice, because the size of the interval has much less impact on the overall size of the numbers. An immediate idea would be to drive the interval size Δλ to zero. This could be awkward, because for a sufficiently small Δλ, Q<sub>λ</sub> will either be zero or huge depending on whether there is a single photon or no <span aria-label="367" epub:type="pagebreak" id="pg_367" role="doc-pagebreak"/>photon in the interval. There are two schools of thought to solve that dilemma. The first is to assume that Δλ is small, but not so small that the quantum nature of light comes into play. The second is to assume that the light is a continuum rather than individual photons, so a true derivative dQ∕dλ is appropriate. Both ways of thinking about it are appropriate and lead to the same computational machinery. In practice, it seems that most people who measure light prefer small, but finite, intervals, because that is what they can measure in the lab. Most people who do theory or computation prefer infinitesimal intervals, because that makes the machinery of calculus available.</p>
<p>The quantity <em>Q</em><sub>λ</sub> is called <em>spectral energy</em>, and it is an <em>intensive</em> quantity as opposed to an <em>extensive</em> quantity such as energy, length, or mass. Intensive quantities can be thought of as density functions that tell the density of an extensive quantity at an infinitesimal point. For example, the energy <em>Q</em> at a specific wavelength is probably zero, but the spectral energy (energy density) <em>Q</em><sub>λ</sub> is a meaningful quantity. A probably more familiar example is that the population of a country may be 25 million, but the population at a point in that country is meaningless. However, the population <em>density</em> measured in people per square meter is meaningful, provided it is measured over large enough areas. Much like with photons, population density works best if we pretend that we can view population as a continuum where population density never becomes granular even when the area is small.</p>
<p>We will follow the convention of graphics where spectral energy is almost always used, and energy is rarely used. This results in a proliferation of λ subscripts if “proper” notation is used. Instead, we will drop the subscript and use <em>Q</em> to denote spectral energy. This can result in some confusion when people outside of graphics read graphics papers, so be aware of this standards issue. Your intuition about spectral energy might be aided by imagining a measurement device with a sensor that measures light energy Δ<em>q</em>. If you place a colored filter in front of the sensor that allows only light in the interval [λ - Δλ∕2,λ + Δλ∕2], then the spectral energy at λ is <em>Q</em> = Δ<em>q</em>∕Δλ.</p>
</section>
<section>
<h3 id="sec14_6_2"><a id="index_term890"/><span class="green">14.6.2 Power</span></h3>
<p>It is useful to estimate a rate of energy production for light sources. This rate is called <em>power</em>, and it is measured in <em>Watts</em>, <em>W</em>, which is another name for <em>joules per second</em>. This is easiest to understand in a <em>steady</em> <em>state</em>, but because power is an intensive quantity (a density over time), it is well defined even when energy production is varying over time. The units of power may be more familiar, e.g., a 100-watt light bulb. Such bulbs draw approximately 100 J of energy each second. The power of the light produced will actually be less than 100 W because of <span aria-label="368" epub:type="pagebreak" id="pg_368" role="doc-pagebreak"/>heat loss, etc., but we can still use this example to help understand more about photons. For example, we can get a feel for how many photons are produced in a second by a 100 W light. Suppose the average photon produced has the energy of a λ = 500 nm photon. The frequency of such a photon is</p>
<div class="disp-formula" id="uequ14_12">
<m:math alttext=""><m:mrow><m:mrow><m:mi>f</m:mi><m:mo>=</m:mo><m:mfrac><m:mrow><m:mi>c</m:mi></m:mrow><m:mrow><m:mi>λ</m:mi></m:mrow></m:mfrac><m:mo>=</m:mo><m:mfrac><m:mrow><m:mn>3</m:mn><m:mo>×</m:mo><m:msup><m:mrow><m:mn>10</m:mn></m:mrow><m:mrow><m:mn>8</m:mn></m:mrow></m:msup><m:msup><m:mrow><m:mtext>ms</m:mtext></m:mrow><m:mrow><m:mo>−</m:mo><m:mn>1</m:mn></m:mrow></m:msup></m:mrow><m:mrow><m:mn>500</m:mn><m:mo>×</m:mo><m:msup><m:mrow><m:mn>10</m:mn></m:mrow><m:mrow><m:mo>−</m:mo><m:mn>9</m:mn></m:mrow></m:msup><m:mtext>m</m:mtext></m:mrow></m:mfrac><m:mo>=</m:mo><m:mn>6</m:mn><m:mo>×</m:mo><m:msup><m:mrow><m:mn>10</m:mn></m:mrow><m:mrow><m:mn>14</m:mn></m:mrow></m:msup><m:msup><m:mrow><m:mtext>s</m:mtext></m:mrow><m:mrow><m:mo>−</m:mo><m:mn>1</m:mn></m:mrow></m:msup><m:mn>.</m:mn></m:mrow></m:mrow></m:math>
</div>
<p>The energy of that photon is <em>hf</em> ≈ 4 × 10<sup>-19</sup> J. That means a staggering 10<sup>20</sup> photons are produced each second, even if the bulb is not very efficient. This explains why simulating a camera with a fast shutter speed and directly simulated photons is an inefficient choice for producing images.</p>
<p>As with energy, we are really interested in <em>spectral power</em> measured in W(nm)<sup>-1</sup>. Again, although the formal standard symbol for spectral power is Φ<sub>λ</sub>, we will use Φ with no subscript for convenience and consistency with most of the graphics literature. One thing to note is that the spectral power for a light source is usually a smaller number than the power. For example, if a light emits a power of 100 W evenly distributed over wavelengths 400–800 nm, then the spectral power will be 100 W/400 nm = 0.25 W(nm)<sup>-1</sup>. This is something to keep in mind if you set the spectral power of light sources by hand for debugging purposes.</p>
<p>The measurement device for spectral energy in the last section could be modified by taking a reading with a shutter that is open for a time interval Δt centered at time t. The spectral power would then be Φ = Δq∕(ΔtΔλ).</p>
</section>
<section>
<h3 id="sec14_6_3"><a id="index_term642"/><span class="green">14.6.3 Irradiance</span></h3>
<p>The quantity <em>irradiance</em> arises naturally if you ask the question “How much light hits this point?” Of course, the answer is “none,” and again, we must use a density function. If the point is on a surface, it is natural to use area to define our density function. We modify the device from the last section to have a finite Δ<em>A</em> area sensor that is smaller than the light field being measured. The spectral irradiance H is just the power per unit area ΔΦ∕Δ<em>A</em>. Fully expanded this is</p>
<div class="disp-formula" id="equ14_3">
<m:math alttext=""><m:mrow><m:mrow><m:mi>H</m:mi><m:mo>=</m:mo><m:mfrac><m:mrow><m:mi mathvariant="normal">Δ</m:mi><m:mi>q</m:mi></m:mrow><m:mrow><m:mi mathvariant="normal">Δ</m:mi><m:mi>A</m:mi><m:mi mathvariant="normal">Δ</m:mi><m:mi>t</m:mi><m:mi mathvariant="normal">Δ</m:mi><m:mi>λ</m:mi></m:mrow></m:mfrac><m:mn>.</m:mn></m:mrow></m:mrow><m:mspace width="3em"/><m:mo>(14.3)</m:mo></m:math>
</div>
<p>Thus, the full units of irradiance are J m<sup>-2</sup>s<sup>-1</sup>(nm)<sup>-1</sup>. Note that the SI units for radiance include inverse-meter-squared for area and inverse-nanometer for wavelength. This seeming inconsistency (using both nanometer and meter) arises because of the natural units for area and visible light wavelengths.</p>
<p><span aria-label="369" epub:type="pagebreak" id="pg_369" role="doc-pagebreak"/>When the light is leaving a surface, e.g., when it is reflected, the same quantity as ir<a id="index_term922"/>radiance is called <em>radiant exitance</em>, E. It is useful to have different words for incident and exitant light, because the same point has potentially different irradiance and <a id="index_term924"/>radiant exitance.</p>
</section>
<section>
<h3 id="sec14_6_4"><span class="green">14.6.4 Radiance</span></h3>
<p>Although irradiance tells us how much light is arriving at a point, it tells us little about the direction that light comes from. To measure something analogous to what we see with our eyes, we need to be able to associate “how much light” with a specific direction. We can imagine a simple device to measure such a quantity (<a href="C19_chapter14.xhtml#f14_6">Figure 14.6</a>). We use a small irradiance meter and add a conical “baffler” which limits light hitting the counter to a range of angles with solid angle Δσ. The response of the detector is as follows:</p>
<figure id="f14_6" tabindex="0">
<img alt="" src="../images/fig14_6.jpg"/>
<figcaption><p><span class="blue">Figure 14.6.</span> By adding a blinder that shows only a small solid angle Δσ to the irradiance detector, we measure radiance.</p></figcaption>
</figure>
<div class="disp-formula" id="uequ14_13">
<m:math alttext=""><m:mrow><m:mrow><m:mtable><m:mtr><m:mtd><m:mtext>response</m:mtext></m:mtd><m:mtd columnalign="left"><m:mo>=</m:mo><m:mfrac><m:mrow><m:mi mathvariant="normal">Δ</m:mi><m:mi>H</m:mi></m:mrow><m:mrow><m:mi mathvariant="normal">Δ</m:mi><m:mi>σ</m:mi></m:mrow></m:mfrac></m:mtd></m:mtr><m:mtr><m:mtd/><m:mtd columnalign="left"><m:mo>=</m:mo><m:mfrac><m:mrow><m:mi mathvariant="normal">Δ</m:mi><m:mi>q</m:mi></m:mrow><m:mrow><m:mi mathvariant="normal">Δ</m:mi><m:mi>A</m:mi><m:mi mathvariant="normal">Δ</m:mi><m:mi>σ</m:mi><m:mi mathvariant="normal">Δ</m:mi><m:mi>t</m:mi><m:mi mathvariant="normal">Δ</m:mi><m:mi>λ</m:mi></m:mrow></m:mfrac><m:mn>.</m:mn></m:mtd></m:mtr></m:mtable></m:mrow></m:mrow></m:math>
</div>
<p>This is the spectral <em>radiance</em> of light traveling in space. Again, we will drop the “spectral” in our discussion and assume that it is implicit.</p>
<p>Radiance is what we are usually computing in graphics programs. A wonderful property of radiance is that it does not vary along a line in space. To see why this is true, examine the two radiance detectors both looking at a surface as shown in <a href="C19_chapter14.xhtml#f14_7">Figure 14.7</a>. Assume the lines the detectors are looking along are close enough together that the surface is emitting/reflecting light “the same” in both of the areas being measured. Because the area of the surface being sampled is proportional to squared distance, and because the light reaching the detector is <em>inversely</em> proportional to squared distance, the two detectors should have the same reading.</p>
<figure id="f14_7" tabindex="0">
<img alt="" src="../images/fig14_7.jpg"/>
<figcaption><p><span class="blue">Figure 14.7.</span> The signal a radiance detector receives does not depend on the distance to the surface being measured. This figure assumes the detectors are pointing at areas on the surface that are emitting light in the same way.</p></figcaption>
</figure>
<p>It is useful to measure the radiance hitting a surface. We can think of placing the cone baffler from the radiance detector at a point on the surface and measuring the irradiance <em>H</em> on the surface originating from directions within the cone (<a href="C19_chapter14.xhtml#f14_8">Figure 14.8</a>). Note that the surface “detector” is not aligned with the cone. For this reason, we need to add a cosine correction term to our definition of radiance:</p>
<div class="disp-formula" id="uequ14_14">
<m:math alttext=""><m:mrow><m:mrow><m:mtable><m:mtr><m:mtd><m:mtext>response</m:mtext></m:mtd><m:mtd columnalign="left"><m:mo>=</m:mo><m:mfrac><m:mrow><m:mi mathvariant="normal">Δ</m:mi><m:mi>H</m:mi></m:mrow><m:mrow><m:mi mathvariant="normal">Δ</m:mi><m:mi>σ</m:mi><m:mtext>cos</m:mtext><m:mi>θ</m:mi></m:mrow></m:mfrac></m:mtd></m:mtr><m:mtr><m:mtd/><m:mtd columnalign="left"><m:mo>=</m:mo><m:mfrac><m:mrow><m:mi mathvariant="normal">Δ</m:mi><m:mi>q</m:mi></m:mrow><m:mrow><m:mi mathvariant="normal">Δ</m:mi><m:mi>A</m:mi><m:mtext>cos</m:mtext><m:mi>θ</m:mi><m:mtext> </m:mtext><m:mi mathvariant="normal">Δ</m:mi><m:mi>σ</m:mi><m:mtext> </m:mtext><m:mi mathvariant="normal">Δ</m:mi><m:mi>t</m:mi><m:mtext> </m:mtext><m:mi mathvariant="normal">Δ</m:mi><m:mi>λ</m:mi></m:mrow></m:mfrac><m:mn>.</m:mn></m:mtd></m:mtr></m:mtable></m:mrow></m:mrow></m:math>
</div>
<figure id="f14_8" tabindex="0">
<img alt="" src="../images/fig14_8.jpg"/>
<figcaption><p><span class="blue">Figure 14.8.</span> <a id="term-659"/><span aria-label="370" epub:type="pagebreak" id="pg_370" role="doc-pagebreak"/>The irradiance at the surface as masked by the cone is smaller than that measured at the detector by a cosine factor.</p></figcaption>
</figure>
<p class="noindent1">As with irradiance and radiant exitance, it is useful to distinguish between radiance incident at a point on a surface and exitant from that point. Terms for these concepts sometimes used in the graphics literature are <em>surface</em> <em>radiance</em> <em>L<sub>s</sub></em> for the radiance of (leaving) a surface, and <em>field radiance</em> <em>L<sub>f</sub></em> for the radiance incident at a surface. Both require the cosine term, because they both correspond to the configuration in <a href="C19_chapter14.xhtml#f14_8">Figure 14.8</a>:</p>
<div class="disp-formula" id="uequ14_15">
<m:math alttext=""><m:mrow><m:mrow><m:mtable><m:mtr><m:mtd><m:msub><m:mrow><m:mi>L</m:mi></m:mrow><m:mrow><m:mi>s</m:mi></m:mrow></m:msub></m:mtd><m:mtd columnalign="left"><m:mo>=</m:mo><m:mfrac><m:mrow><m:mi mathvariant="normal">Δ</m:mi><m:mi>E</m:mi></m:mrow><m:mrow><m:mi mathvariant="normal">Δ</m:mi><m:mi>σ</m:mi><m:mtext>cos</m:mtext><m:mi>θ</m:mi></m:mrow></m:mfrac></m:mtd></m:mtr><m:mtr><m:mtd><m:msub><m:mrow><m:mi>L</m:mi></m:mrow><m:mrow><m:mi>f</m:mi></m:mrow></m:msub></m:mtd><m:mtd columnalign="left"><m:mo>=</m:mo><m:mfrac><m:mrow><m:mi mathvariant="normal">Δ</m:mi><m:mi>H</m:mi></m:mrow><m:mrow><m:mi mathvariant="normal">Δ</m:mi><m:mi>σ</m:mi><m:mtext>cos</m:mtext><m:mtext> </m:mtext><m:mi>θ</m:mi></m:mrow></m:mfrac><m:mn>.</m:mn></m:mtd></m:mtr></m:mtable></m:mrow></m:mrow></m:math>
</div>
<section>
<h4 id="sec14_6_4_1"><a id="index_term926"/><span class="blue">Other Radiometric Quantities in Terms of Radiance</span></h4>
<p>If we have a surface whose field radiance is <em>L<sub>f</sub></em>, then we can derive all of the other radiometric quantities from it. This is one reason radiance is considered the “fundamental” radiometric quantity. For example, the irradiance can be expressed as</p>
<div class="disp-formula" id="uequ14_16">
<m:math alttext=""><m:mrow><m:mrow><m:mi>H</m:mi><m:mo>=</m:mo><m:mrow><m:msub><m:mrow><m:mo>∫</m:mo></m:mrow><m:mrow><m:mtext>all</m:mtext><m:mtext> </m:mtext><m:mi mathvariant="bold">k</m:mi></m:mrow></m:msub><m:mrow><m:msub><m:mrow><m:mi>L</m:mi></m:mrow><m:mrow><m:mi>f</m:mi></m:mrow></m:msub><m:mrow><m:mo>(</m:mo><m:mi mathvariant="bold">k</m:mi><m:mo>)</m:mo><m:mtext>cos</m:mtext><m:mtext> </m:mtext><m:mi>θ</m:mi><m:mtext mathvariant="italic">d</m:mtext><m:mi>σ</m:mi></m:mrow></m:mrow></m:mrow><m:mn>.</m:mn></m:mrow></m:mrow></m:math>
</div>
<p>This formula has several notational conventions that are common in graphics that make such formulae opaque to readers not familiar with them (<a href="C19_chapter14.xhtml#f14_9">Figure 14.9</a>). First, <strong>k</strong> is an incident direction and can be thought of as a unit vector, a direction, or a (<em>θ</em>,<em>ϕ</em>) pair in spherical coordinates with respect to the surface normal. The <span aria-label="371" epub:type="pagebreak" id="pg_371" role="doc-pagebreak"/>direction has a differential solid angle dσ associated with it. The field radiance is potentially different for every direction, so we write it as a function L(<strong>k</strong>).</p>
<figure id="f14_9" tabindex="0">
<img alt="" src="../images/fig14_9.jpg"/>
<figcaption><p><span class="blue">Figure 14.9.</span> The direction <strong>k</strong> has a differential solid angle <em>d</em>σ associated with it.</p></figcaption>
</figure>
<p>As an example, we can compute the irradiance H at a surface that has constant field radiance <em>L<sub>f</sub></em> in all directions. To integrate, we use a classic spherical coordinate system and recall that the differential solid angle is</p>
<div class="disp-formula" id="uequ14_17">
<m:math alttext=""><m:mrow><m:mrow><m:mi>d</m:mi><m:mi>σ</m:mi><m:mo>≡</m:mo><m:mi>sin</m:mi><m:mo>⁡</m:mo><m:mi>θ</m:mi><m:mtext> </m:mtext><m:mi>d</m:mi><m:mi>θ</m:mi><m:mtext> </m:mtext><m:mi>d</m:mi><m:mi>φ</m:mi><m:mo>,</m:mo></m:mrow></m:mrow></m:math>
</div>
<p>so the irradiance is</p>
<div class="disp-formula" id="uequ14_18">
<m:math alttext=""><m:mrow><m:mrow><m:mtable><m:mtr><m:mtd><m:mi>H</m:mi></m:mtd><m:mtd columnalign="left"><m:mo>=</m:mo><m:mrow><m:msubsup><m:mo>∫</m:mo><m:mrow><m:mi>φ</m:mi><m:mo>=</m:mo><m:mn>0</m:mn></m:mrow><m:mrow><m:mn>2</m:mn><m:mi>π</m:mi></m:mrow></m:msubsup><m:msubsup><m:mo>∫</m:mo><m:mrow><m:mi>θ</m:mi><m:mo>=</m:mo><m:mn>0</m:mn></m:mrow><m:mrow><m:mfrac><m:mrow><m:mi>π</m:mi></m:mrow><m:mrow><m:mn>2</m:mn></m:mrow></m:mfrac></m:mrow></m:msubsup><m:mrow><m:msub><m:mrow><m:mi>L</m:mi></m:mrow><m:mrow><m:mi>f</m:mi></m:mrow></m:msub></m:mrow></m:mrow></m:mtd></m:mtr><m:mtr><m:mtd/><m:mtd columnalign="left"><m:mo>=</m:mo><m:mi>π</m:mi><m:msub><m:mrow><m:mi>L</m:mi></m:mrow><m:mrow><m:mi>f</m:mi></m:mrow></m:msub><m:mn>.</m:mn></m:mtd></m:mtr></m:mtable><m:mtext>cos</m:mtext><m:mtext> </m:mtext><m:mi>θ</m:mi><m:mtext>sin</m:mtext><m:mtext> </m:mtext><m:mi>θ</m:mi><m:mtext mathvariant="italic">d</m:mtext><m:mi>θ</m:mi><m:mtext mathvariant="italic">d</m:mtext><m:mi>φ</m:mi></m:mrow></m:mrow></m:math>
</div>
<p>This relation shows us our first occurrence of a potentially surprising constant π. These factors of π occur frequently in radiometry and are an artifact of how we chose to measure solid angles; i.e., the area of a unit sphere is a multiple of π rather than a multiple of one.</p>
<p>Similarly, we can find the power hitting a surface by integrating the irradiance across the surface area:</p>
<div class="disp-formula" id="uequ14_19">
<m:math alttext=""><m:mrow><m:mrow><m:mi mathvariant="normal">Φ</m:mi><m:mo>=</m:mo><m:mrow><m:msub><m:mrow><m:mo>∫</m:mo></m:mrow><m:mrow><m:mtext>all</m:mtext><m:mtext>x</m:mtext></m:mrow></m:msub><m:mi>H</m:mi><m:mrow><m:mo>(</m:mo><m:mtext>x</m:mtext><m:mo>)</m:mo><m:mi>d</m:mi><m:mi>A</m:mi><m:mo>,</m:mo></m:mrow></m:mrow></m:mrow></m:mrow></m:math>
</div>
<p>where <strong>x</strong> is a point on the surface, and <em>dA</em> is the differential area associated with that point. Note that we don’t have special terms or symbols for incoming versus outgoing power. That distinction does not seem to come up enough to have encouraged the distinction.</p>
</section>
</section>
</section>
<section>
<h2 id="sec14_7"><a id="index_term928"/><a epub:type="backlink" href="C02a_toc.xhtml#rsec14_7" role="doc-backlink"><span class="green">14.7 Radiometry of Scattering</span></a></h2>
<p>The photon tracing of <a href="C19_chapter14.xhtml#sec14_5">Section 14.5</a> assumed all surfaces are smooth at the level of ray interactions, and we assume potentially complex geometry with very fine geometric details. In practice, the bulk properties of a region are averaged to make an area behave like the fine geometry but without storing it. The most important concept of this section is that for a rough surface (e.g., brushed steel), rather than representing all the tiny scratches with actual geometry, we statistically characterize the scratches and make the smooth surface randomly reflect light in multiple directions as if there were invisibly small details in the surface. This function is called the <em><a id="index_term81"/>bidirectional reflectance distribution function</em> (<a id="index_term108"/>BRDF). The second important concept is a very similar idea for how light is scattered in a volume (e.g., the bubbles in an ice cube or the water droplets in a cloud). Rather <span aria-label="372" epub:type="pagebreak" id="pg_372" role="doc-pagebreak"/>than representing all the little particles/bubbles/droplets in the volume, we just make a statistical model of how likely light is to scatter in any given 3D location, how likely it is to be absorbed, and what is the directional distribution of the scattered light. That directional distribution is just a PDF and is called the <em>phase function</em> of the volume. We don’t discuss phase functions or volume transport further; see the chapter notes for more information on those subjects.</p>
<section>
<h3 id="sec14_7_1"><span class="green">14.7.1 BRDF</span></h3>
<p>Because we are interested in surface appearance, we would like to characterize how a surface reflects light. At an intuitive level, for any incident light coming from direction <strong>k</strong><sub><em>i</em></sub>, there is some fraction scattered in a small solid angle near the outgoing direction <strong>k</strong><sub><em>o</em></sub>. There are many ways we could formalize such a concept, and not surprisingly, the standard way to do so is inspired by building a simple measurement device. Such a device is shown in <a href="C19_chapter14.xhtml#f14_10">Figure 14.10</a>, where a small light source is positioned in direction <strong>k</strong><sub><em>i</em></sub> as seen from a point on a surface, and a detector is placed in direction <strong>k</strong><sub><em>o</em></sub>. For every directional pair (<strong>k</strong><sub><em>i</em></sub>,<strong>k</strong><sub><em>o</em></sub>), we take a reading with the detector.</p>
<figure id="f14_10" tabindex="0">
<img alt="" src="../images/fig14_10.jpg"/>
<figcaption><p><span class="blue">Figure 14.10.</span> A simple measurement device for directional reflectance. The positions of light and detector are moved to each possible pair of directions. Note that both <strong>k</strong><sub>i</sub> and <strong>k</strong><sub>o</sub> point away from the surface to allow reciprocity.</p></figcaption>
</figure>
<p>Now we just have to decide how to measure the strength of the light source and make our reflection function independent of this strength. For example, if we replaced the light with a brighter light, we would not want to think of the surface as reflecting light differently. We could place a radiance meter at the point being illuminated to measure the light. However, for this to get an accurate reading that <span aria-label="373" epub:type="pagebreak" id="pg_373" role="doc-pagebreak"/>would not depend on the Δσ of the detector, we would need the light to subtend a solid angle bigger than Δσ. Unfortunately, the measurement taken by our roving radiance detector in direction <strong>k</strong><sub>o</sub> will also count light that comes from points outside the new detector’s cone. So this does not seem like a practical solution.</p>
<p>Alternatively, we can place an irradiance meter at the point on the surface being measured. This will take a reading that does not depend strongly on subtleties of the light source geometry. This suggests characterizing reflectance as a ratio:</p>
<div class="disp-formula" id="uequ14_20">
<m:math alttext=""><m:mrow><m:mrow><m:mi>ρ</m:mi><m:mo>=</m:mo><m:mfrac><m:mrow><m:msub><m:mrow><m:mi>L</m:mi></m:mrow><m:mrow><m:mi>s</m:mi></m:mrow></m:msub></m:mrow><m:mrow><m:mi>H</m:mi></m:mrow></m:mfrac><m:mo>,</m:mo></m:mrow></m:mrow></m:math>
</div>
<p>where this fraction ρ will vary with incident and exitant directions <strong>k</strong><sub>i</sub> and <strong>k</strong><sub>o</sub>, H is the irradiance for light position <strong>k</strong><sub>i</sub>, and L<sub>s</sub> is the surface radiance measured in direction <strong>k</strong><sub>o</sub>. If we take such a measurement for all direction pairs, we end up with a 4D function ρ(<strong>k</strong><sub>i</sub>,<strong>k</strong><sub>o</sub>). This function is called the <em>bidirectional reflectance distribution function</em> (BRDF). The BRDF is all we need to know to characterize the directional properties of how a surface reflects light.</p>
<section>
<h4 id="sec14_7_1_1"><a id="index_term331"/><span class="blue">Directional Hemispherical Reflectance</span></h4>
<p>Given a BRDF, it is straightforward to ask, “What fraction of incident light is reflected?” However, the answer is not so easy; the fraction reflected depends on the directional distribution of incoming light. For this reason, we typically only set a fraction reflected for a fixed incident direction <strong>k</strong><sub>i</sub>. This fraction is called the <em>directional hemispherical reflectance</em>. This fraction, <em>R</em>(<strong>k</strong><sub><em>i</em></sub>), is defined by</p>
<div class="disp-formula" id="uequ14_21">
<m:math alttext=""><m:mrow><m:mrow><m:mi>R</m:mi><m:mrow><m:mo>(</m:mo><m:msub><m:mrow><m:mtext mathvariant="bold">k</m:mtext></m:mrow><m:mrow><m:mi>i</m:mi></m:mrow></m:msub><m:mo>)</m:mo><m:mo>=</m:mo><m:mfrac><m:mrow><m:mtext>Power</m:mtext><m:mtext>in</m:mtext><m:mtext>all</m:mtext><m:mtext>outgoing</m:mtext><m:mtext>directions</m:mtext><m:msub><m:mrow><m:mtext mathvariant="bold">k</m:mtext></m:mrow><m:mrow><m:mi>o</m:mi></m:mrow></m:msub></m:mrow><m:mrow><m:mtext>Power</m:mtext><m:mtext>in a beam</m:mtext><m:mtext>from</m:mtext><m:mtext> </m:mtext><m:mtext>direction</m:mtext><m:mtext> </m:mtext><m:msub><m:mrow><m:mtext>k</m:mtext></m:mrow><m:mrow><m:mi>i</m:mi></m:mrow></m:msub></m:mrow></m:mfrac><m:mn>.</m:mn></m:mrow></m:mrow></m:mrow></m:math>
</div>
<p>Note that this quantity is between zero and one for reasons of energy conservation. If we allow the incident power Φ<sub><em>i</em></sub> to hit on a small area Δ<em>A</em>, then the irradiance is Φ<sub><em>i</em></sub>∕Δ<em>A</em>. Also, the ratio of the incoming power is just the ratio of the radiant exitance to irradiance:</p>
<div class="disp-formula" id="uequ14_22">
<m:math alttext=""><m:mrow><m:mrow><m:mi>R</m:mi><m:mrow><m:mo>(</m:mo><m:msub><m:mrow><m:mi mathvariant="bold">k</m:mi></m:mrow><m:mrow><m:mi>i</m:mi></m:mrow></m:msub><m:mo>)</m:mo><m:mo>=</m:mo><m:mfrac><m:mrow><m:mi>E</m:mi></m:mrow><m:mrow><m:mi>H</m:mi></m:mrow></m:mfrac><m:mn>.</m:mn></m:mrow></m:mrow></m:mrow></m:math>
</div>
<p>The radiance in a particular direction resulting from this power is by the definition of BRDF:</p>
<div class="disp-formula" id="uequ14_23">
<m:math alttext=""><m:mrow><m:mrow><m:mtable><m:mtr><m:mtd><m:mi>L</m:mi><m:mrow><m:mo>(</m:mo><m:msub><m:mrow><m:mi mathvariant="bold">k</m:mi></m:mrow><m:mrow><m:mi>o</m:mi></m:mrow></m:msub><m:mo>)</m:mo></m:mrow></m:mtd><m:mtd><m:mo>=</m:mo><m:mi>H</m:mi><m:mi>ρ</m:mi><m:mrow><m:mo>(</m:mo><m:msub><m:mrow><m:mi mathvariant="bold">k</m:mi></m:mrow><m:mrow><m:mi>i</m:mi></m:mrow></m:msub><m:mo>,</m:mo><m:msub><m:mrow><m:mi mathvariant="bold">k</m:mi></m:mrow><m:mrow><m:mi>o</m:mi></m:mrow></m:msub><m:mo>)</m:mo></m:mrow></m:mtd></m:mtr><m:mtr><m:mtd/><m:mtd columnalign="left"><m:mo>=</m:mo><m:mfrac><m:mrow><m:msub><m:mrow><m:mi mathvariant="normal">Φ</m:mi></m:mrow><m:mrow><m:mi>i</m:mi></m:mrow></m:msub></m:mrow><m:mrow><m:mi mathvariant="normal">Δ</m:mi><m:mi>A</m:mi></m:mrow></m:mfrac><m:mn>.</m:mn></m:mtd></m:mtr></m:mtable></m:mrow></m:mrow></m:math>
</div>
<p>And from the definition of radiance, we also have</p>
<div class="disp-formula" id="uequ14_24">
<m:math alttext=""><m:mrow><m:mi>L</m:mi><m:mo stretchy="false">(</m:mo><m:msub><m:mrow><m:mi mathvariant="bold">k</m:mi></m:mrow><m:mrow><m:mi>o</m:mi></m:mrow></m:msub><m:mo stretchy="false">)</m:mo><m:mo>=</m:mo><m:mfrac><m:mrow><m:mi>Δ</m:mi><m:mi>E</m:mi></m:mrow><m:mrow><m:mi>Δ</m:mi><m:msub><m:mrow><m:mi>σ</m:mi></m:mrow><m:mrow><m:mi>o</m:mi></m:mrow></m:msub><m:mi>cos</m:mi><m:msub><m:mrow><m:mi>θ</m:mi></m:mrow><m:mrow><m:mi>o</m:mi></m:mrow></m:msub></m:mrow></m:mfrac><m:mo>,</m:mo></m:mrow></m:math>
</div>
<p><a id="term-963"/><span aria-label="374" epub:type="pagebreak" id="pg_374" role="doc-pagebreak"/>where <em>E</em> is the radiant exitance of the small patch in direction <strong>k</strong><sub>o</sub>. Using these two definitions for radiance, we get</p>
<div class="disp-formula" id="uequ14_25">
<m:math alttext=""><m:mrow><m:mi>H</m:mi><m:mi>ρ</m:mi><m:mo stretchy="false">(</m:mo><m:msub><m:mrow><m:mi mathvariant="bold">k</m:mi></m:mrow><m:mrow><m:mi>i</m:mi></m:mrow></m:msub><m:mo>,</m:mo><m:msub><m:mrow><m:mi mathvariant="bold">k</m:mi></m:mrow><m:mrow><m:mi>o</m:mi></m:mrow></m:msub><m:mo stretchy="false">)</m:mo><m:mo>=</m:mo><m:mfrac><m:mrow><m:mi>Δ</m:mi><m:mi>E</m:mi></m:mrow><m:mrow><m:mi>Δ</m:mi><m:msub><m:mrow><m:mi>σ</m:mi></m:mrow><m:mrow><m:mi>o</m:mi></m:mrow></m:msub><m:mi>cos</m:mi><m:msub><m:mrow><m:mi>θ</m:mi></m:mrow><m:mrow><m:mi>o</m:mi></m:mrow></m:msub></m:mrow></m:mfrac><m:mo>.</m:mo></m:mrow></m:math>
</div>
<p>Rearranging terms, we get</p>
<div class="disp-formula" id="uequ14_26">
<m:math alttext=""><m:mrow><m:mfrac><m:mrow><m:mi>Δ</m:mi><m:mi>E</m:mi></m:mrow><m:mrow><m:mi>H</m:mi></m:mrow></m:mfrac><m:mo>=</m:mo><m:mi>ρ</m:mi><m:mo stretchy="false">(</m:mo><m:msub><m:mrow><m:mi mathvariant="bold">k</m:mi></m:mrow><m:mrow><m:mi>i</m:mi></m:mrow></m:msub><m:mo>,</m:mo><m:msub><m:mrow><m:mi mathvariant="bold">k</m:mi></m:mrow><m:mrow><m:mi>o</m:mi></m:mrow></m:msub><m:mo stretchy="false">)</m:mo><m:mi>Δ</m:mi><m:msub><m:mrow><m:mi>σ</m:mi></m:mrow><m:mrow><m:mi>o</m:mi></m:mrow></m:msub><m:mi>cos</m:mi><m:msub><m:mrow><m:mi>θ</m:mi></m:mrow><m:mrow><m:mi>o</m:mi></m:mrow></m:msub><m:mo>.</m:mo></m:mrow></m:math>
</div>
<p>This is just the small contribution to <em>E∕H</em> that is reflected near the particular <strong>k</strong><sub><em>o</em></sub>. To find the total <em>R</em>(<strong>k</strong><sub><em>i</em></sub>), we sum over all outgoing <strong>k</strong><sub><em>o</em></sub>. In integral form, this is</p>
<div class="disp-formula" id="uequ14_27">
<m:math alttext=""><m:mrow><m:mi>R</m:mi><m:mo stretchy="false">(</m:mo><m:msub><m:mrow><m:mi mathvariant="bold">k</m:mi></m:mrow><m:mrow><m:mi>i</m:mi></m:mrow></m:msub><m:mo stretchy="false">)</m:mo><m:mo>=</m:mo><m:mstyle displaystyle="true"><m:mrow><m:msub><m:mrow><m:mo>∫</m:mo></m:mrow><m:mrow><m:msub><m:mrow><m:mtext>all</m:mtext><m:mi mathvariant="bold">k</m:mi></m:mrow><m:mrow><m:mtext>o</m:mtext></m:mrow></m:msub></m:mrow></m:msub><m:mi>ρ</m:mi></m:mrow></m:mstyle><m:mo stretchy="false">(</m:mo><m:msub><m:mrow><m:mi mathvariant="bold">k</m:mi></m:mrow><m:mrow><m:mi>i</m:mi></m:mrow></m:msub><m:mo>,</m:mo><m:msub><m:mrow><m:mi mathvariant="bold">k</m:mi></m:mrow><m:mrow><m:mi>o</m:mi></m:mrow></m:msub><m:mo stretchy="false">)</m:mo><m:mi>cos</m:mi><m:msub><m:mrow><m:mi>θ</m:mi></m:mrow><m:mrow><m:mi>o</m:mi></m:mrow></m:msub><m:mtext> </m:mtext><m:mi>d</m:mi><m:msub><m:mrow><m:mi>σ</m:mi></m:mrow><m:mrow><m:mi>o</m:mi></m:mrow></m:msub><m:mo>.</m:mo></m:mrow></m:math>
</div>
</section>
<section>
<h4 id="sec14_7_1_2"><a id="index_term537"/><span class="blue">Ideal Diffuse BRDF</span></h4>
<p>An idealized diffuse surface is called <em>Lambertian</em>. Such surfaces are impossible in nature for thermodynamic reasons, but mathematically, they do conserve energy. The Lambertian BRDF has ρ equal to a constant for all angles. This means the surface will have the same radiance for all viewing angles, and this radiance will be proportional to the irradiance.</p>
<p>If we compute <em>R</em>(<strong>k</strong><sub><em>i</em></sub>) for a Lambertian surface with <em>ρ = C</em>, we get</p>
<div class="disp-formula" id="uequ14_28">
<m:math xmlns:mml="http://www.w3.org/1998/Math/MathML" alttext=""><m:mrow><m:mtable><m:mtr><m:mtd><m:mi>R</m:mi><m:mo stretchy="false">(</m:mo><m:msub><m:mrow><m:mi mathvariant="bold">k</m:mi></m:mrow><m:mrow><m:mi>i</m:mi></m:mrow></m:msub><m:mo stretchy="false">)</m:mo><m:mtext> </m:mtext><m:mtext> </m:mtext><m:mspace linebreak="newline"/><m:mtext> </m:mtext><m:mtext> </m:mtext><m:mtext> </m:mtext><m:mtext> </m:mtext><m:mtext> </m:mtext><m:mtext> </m:mtext><m:mtext> </m:mtext><m:mtext> </m:mtext><m:mtext> </m:mtext><m:mtext> </m:mtext><m:mtext> </m:mtext><m:mtext> </m:mtext><m:mtext> </m:mtext><m:mtext> </m:mtext><m:mtext> </m:mtext><m:mtext> </m:mtext><m:mtext> </m:mtext><m:mtext> </m:mtext><m:mtext> </m:mtext><m:mtext> </m:mtext><m:mtext> </m:mtext><m:mtext> </m:mtext><m:mtext> </m:mtext><m:mtext> </m:mtext><m:mtext> </m:mtext><m:mtext> </m:mtext><m:mtext> </m:mtext><m:mtext> </m:mtext><m:mspace linebreak="newline"/><m:mtext> </m:mtext><m:mtext> </m:mtext><m:mtext> </m:mtext><m:mtext> </m:mtext><m:mtext> </m:mtext><m:mtext> </m:mtext><m:mtext> </m:mtext><m:mtext> </m:mtext><m:mtext> </m:mtext><m:mtext> </m:mtext><m:mtext> </m:mtext><m:mtext> </m:mtext><m:mtext> </m:mtext><m:mtext> </m:mtext><m:mtext> </m:mtext><m:mtext> </m:mtext><m:mtext> </m:mtext><m:mtext> </m:mtext><m:mtext> </m:mtext><m:mtext> </m:mtext></m:mtd><m:mtd><m:mo>=</m:mo></m:mtd><m:mtd columnalign="left"><m:mstyle displaystyle="true"><m:mrow><m:msub><m:mrow><m:mo>∫</m:mo></m:mrow><m:mrow><m:msub><m:mrow><m:mtext>all</m:mtext><m:mtext> </m:mtext><m:mtext>k</m:mtext></m:mrow><m:mrow><m:mtext>o</m:mtext></m:mrow></m:msub></m:mrow></m:msub><m:mi>C</m:mi></m:mrow></m:mstyle><m:mi>cos</m:mi><m:msub><m:mrow><m:mi>θ</m:mi></m:mrow><m:mrow><m:mi>o</m:mi></m:mrow></m:msub><m:mtext> </m:mtext><m:mi>d</m:mi><m:msub><m:mrow><m:mi>σ</m:mi></m:mrow><m:mrow><m:mi>o</m:mi></m:mrow></m:msub></m:mtd></m:mtr><m:mtr><m:mtd/><m:mtd><m:mo>=</m:mo></m:mtd><m:mtd columnalign="left"><m:mstyle displaystyle="true"><m:mrow><m:msubsup><m:mrow><m:mo>∫</m:mo></m:mrow><m:mrow><m:msub><m:mrow><m:mi>ϕ</m:mi></m:mrow><m:mrow><m:mi>o</m:mi></m:mrow></m:msub><m:mo>=</m:mo><m:mn>0</m:mn></m:mrow><m:mrow><m:mn>2</m:mn><m:mi>π</m:mi></m:mrow></m:msubsup><m:mrow><m:mstyle displaystyle="true"><m:mrow><m:msubsup><m:mrow><m:mo>∫</m:mo></m:mrow><m:mrow><m:msub><m:mrow><m:mi>θ</m:mi></m:mrow><m:mrow><m:mi>o</m:mi></m:mrow></m:msub><m:mo>=</m:mo><m:mn>0</m:mn></m:mrow><m:mrow><m:mi>π</m:mi><m:mo>/</m:mo><m:mn>2</m:mn></m:mrow></m:msubsup><m:mi>C</m:mi></m:mrow></m:mstyle></m:mrow></m:mrow></m:mstyle><m:mi>cos</m:mi><m:msub><m:mrow><m:mi>θ</m:mi></m:mrow><m:mrow><m:mi>o</m:mi></m:mrow></m:msub><m:mi>sin</m:mi><m:msub><m:mrow><m:mi>θ</m:mi></m:mrow><m:mrow><m:mi>o</m:mi></m:mrow></m:msub><m:mtext> </m:mtext><m:mi>d</m:mi><m:msub><m:mrow><m:mi>θ</m:mi></m:mrow><m:mrow><m:mi>o</m:mi></m:mrow></m:msub><m:mtext> </m:mtext><m:mi>d</m:mi><m:msub><m:mrow><m:mi>ϕ</m:mi></m:mrow><m:mrow><m:mi>o</m:mi></m:mrow></m:msub></m:mtd></m:mtr><m:mtr><m:mtd/><m:mtd><m:mo>=</m:mo></m:mtd><m:mtd columnalign="left"><m:mi>π</m:mi><m:mi>C</m:mi><m:mo>.</m:mo></m:mtd></m:mtr></m:mtable></m:mrow></m:math>
</div>
<p>Thus, for a perfectly reflecting Lambertian surface (<em>R</em> = 1), we have ρ = 1∕π, and for a Lambertian surface where <em>R</em>(<strong>k</strong><sub><em>i</em></sub>) = <em>r</em>, we have</p>
<div class="disp-formula" id="uequ14_29">
<m:math alttext=""><m:mrow><m:mi>ρ</m:mi><m:mo stretchy="false">(</m:mo><m:msub><m:mrow><m:mi mathvariant="bold">k</m:mi></m:mrow><m:mrow><m:mi>i</m:mi></m:mrow></m:msub><m:mo>,</m:mo><m:msub><m:mrow><m:mi mathvariant="bold">k</m:mi></m:mrow><m:mrow><m:mi>o</m:mi></m:mrow></m:msub><m:mo stretchy="false">)</m:mo><m:mo>=</m:mo><m:mfrac><m:mrow><m:mi>r</m:mi></m:mrow><m:mrow><m:mi>π</m:mi></m:mrow></m:mfrac><m:mo>.</m:mo></m:mrow></m:math>
</div>
<p>This is another example where the use of a steradian for the solid angle determines the normalizing constant and thus introduces factors of π.</p>
</section>
</section>
</section>
<section>
<h2 id="sec14_8"><a id="index_term1271"/><a epub:type="backlink" href="C02a_toc.xhtml#rsec14_8" role="doc-backlink"><span class="green">14.8 Transport Equation</span></a></h2>
<p>With the definition of BRDF, we can describe the radiance of a surface in terms of the incoming radiance from all different directions. Because in computer graphics, we can use idealized mathematics that might be impractical to instantiate in <a id="term-614"/><a id="term-964"/><span aria-label="375" epub:type="pagebreak" id="pg_375" role="doc-pagebreak"/>the lab, we can also write the BRDF in terms of radiance only. If we take a small part of the light with solid angle Δσ<sub>i</sub> with radiance L<sub>i</sub> and “measure” the reflected radiance in direction <strong>k</strong><sub>o</sub> due to this small piece of the light, we can compute a BRDF (<a href="C19_chapter14.xhtml#f14_11">Figure 14.11</a>). The irradiance due to the small piece of light is H = L<sub>i</sub> cosθ<sub>i</sub>Δσ<sub>i</sub>. Thus, the BRDF is</p>
<figure id="f14_11" tabindex="0">
<img alt="" src="../images/fig14_11.jpg"/>
<figcaption><p><span class="blue">Figure 14.11.</span> The geometry for the transport equation in its directional form.</p></figcaption>
</figure>
<div class="disp-formula" id="uequ14_30">
<m:math alttext=""><m:mrow><m:mi>ρ</m:mi><m:mo>=</m:mo><m:mfrac><m:mrow><m:msub><m:mrow><m:mi>L</m:mi></m:mrow><m:mrow><m:mi>o</m:mi></m:mrow></m:msub></m:mrow><m:mrow><m:msub><m:mrow><m:mi>L</m:mi></m:mrow><m:mrow><m:mi>i</m:mi></m:mrow></m:msub><m:mi>cos</m:mi><m:msub><m:mrow><m:mi>θ</m:mi></m:mrow><m:mrow><m:mi>i</m:mi></m:mrow></m:msub><m:mi>Δ</m:mi><m:msub><m:mrow><m:mi>σ</m:mi></m:mrow><m:mrow><m:mi>i</m:mi></m:mrow></m:msub></m:mrow></m:mfrac><m:mo>.</m:mo></m:mrow></m:math>
</div>
<p>This form can be useful in some situations. Rearranging terms, we can write down the part of the radiance that is due to light coming from direction <strong>k</strong><sub>i</sub>:</p>
<div class="disp-formula" id="uequ14_31">
<m:math alttext=""><m:mrow><m:mi>Δ</m:mi><m:msub><m:mrow><m:mi>L</m:mi></m:mrow><m:mrow><m:mi>o</m:mi></m:mrow></m:msub><m:mo>=</m:mo><m:mi>ρ</m:mi><m:mo stretchy="false">(</m:mo><m:msub><m:mrow><m:mi mathvariant="bold">k</m:mi></m:mrow><m:mrow><m:mi>i</m:mi></m:mrow></m:msub><m:mo>,</m:mo><m:mtext> </m:mtext><m:msub><m:mrow><m:mi mathvariant="bold">k</m:mi></m:mrow><m:mrow><m:mi>o</m:mi></m:mrow></m:msub><m:mo stretchy="false">)</m:mo><m:msub><m:mrow><m:mi>L</m:mi></m:mrow><m:mrow><m:mi>i</m:mi></m:mrow></m:msub><m:mi>cos</m:mi><m:msub><m:mrow><m:mi>θ</m:mi></m:mrow><m:mrow><m:mi>i</m:mi></m:mrow></m:msub><m:mi>Δ</m:mi><m:msub><m:mrow><m:mi>σ</m:mi></m:mrow><m:mrow><m:mi>i</m:mi></m:mrow></m:msub><m:mo>.</m:mo></m:mrow></m:math>
</div>
<p>If there is light coming from many directions L<sub>i</sub>(<strong>k</strong><sub>i</sub>), we can sum all of them. In integral form, with notation for surface and field radiance, this is</p>
<div class="disp-formula" id="equ14_4">
<m:math alttext=""><m:mrow><m:msub><m:mrow><m:mi>L</m:mi></m:mrow><m:mrow><m:mi>s</m:mi></m:mrow></m:msub><m:mo stretchy="false">(</m:mo><m:msub><m:mrow><m:mi mathvariant="bold">k</m:mi></m:mrow><m:mrow><m:mi>o</m:mi></m:mrow></m:msub><m:mo stretchy="false">)</m:mo><m:mo>=</m:mo><m:mstyle displaystyle="true"><m:mrow><m:msub><m:mrow><m:mo>∫</m:mo></m:mrow><m:mrow><m:msub><m:mrow><m:mtext>all</m:mtext><m:mi mathvariant="bold">k</m:mi></m:mrow><m:mrow><m:mtext>i</m:mtext></m:mrow></m:msub></m:mrow></m:msub><m:mi>ρ</m:mi></m:mrow></m:mstyle><m:mo stretchy="false">(</m:mo><m:msub><m:mrow><m:mi mathvariant="bold">k</m:mi></m:mrow><m:mrow><m:mi>i</m:mi></m:mrow></m:msub><m:mo>,</m:mo><m:msub><m:mrow><m:mi mathvariant="bold">k</m:mi></m:mrow><m:mrow><m:mi>o</m:mi></m:mrow></m:msub><m:mo stretchy="false">)</m:mo><m:msub><m:mrow><m:mi>L</m:mi></m:mrow><m:mrow><m:mi>f</m:mi></m:mrow></m:msub><m:mo stretchy="false">(</m:mo><m:msub><m:mrow><m:mi mathvariant="bold">k</m:mi></m:mrow><m:mrow><m:mi>i</m:mi></m:mrow></m:msub><m:mo stretchy="false">)</m:mo><m:mi>cos</m:mi><m:msub><m:mrow><m:mi>θ</m:mi></m:mrow><m:mrow><m:mi>i</m:mi></m:mrow></m:msub><m:mi>d</m:mi><m:msub><m:mrow><m:mi>σ</m:mi></m:mrow><m:mrow><m:mi>i</m:mi></m:mrow></m:msub><m:mo>.</m:mo></m:mrow><m:mspace width="3em"/><m:mo>(14.4)</m:mo></m:math>
</div>
<p>This is often called the <em><a id="index_term988"/>rendering equation</em> (Kajiya, 1986) in computer graphics and was first written in the form by (Immel, Cohen, &amp; Greenberg, 1986).</p>
<p>Sometimes, it is useful to write the transport equation in terms of surface radiances only. Note, that in a closed environment, the field radiance L<sub>f</sub>(<strong>k</strong><sub>i</sub>) comes from some surface with surface radiance L<sub>s</sub>(-<strong>k</strong><sub>i</sub>) = L<sub>f</sub>(<strong>k</strong><sub>i</sub>) (<a href="C19_chapter14.xhtml#f14_12">Figure 14.12</a>). The solid angle subtended by the point <strong>x</strong>′ in the figure is given by</p>
<div class="disp-formula" id="equ14_5">
<m:math alttext=""><m:mrow><m:mi>Δ</m:mi><m:msub><m:mrow><m:mi>σ</m:mi></m:mrow><m:mrow><m:mi>i</m:mi></m:mrow></m:msub><m:mo>=</m:mo><m:mfrac><m:mrow><m:mi>Δ</m:mi><m:msup><m:mrow><m:mi>A</m:mi></m:mrow><m:mrow><m:mo>′</m:mo></m:mrow></m:msup><m:mi>cos</m:mi><m:msup><m:mrow><m:mi>θ</m:mi></m:mrow><m:mrow><m:mo>′</m:mo></m:mrow></m:msup></m:mrow><m:mrow><m:msup><m:mrow><m:mo>|</m:mo><m:mo>|</m:mo><m:mi>x</m:mi><m:mo>−</m:mo><m:msup><m:mrow><m:msup><m:mrow><m:mi>x</m:mi></m:mrow><m:mrow><m:mo>′</m:mo></m:mrow></m:msup></m:mrow><m:mrow/></m:msup><m:mo>|</m:mo><m:mo>|</m:mo></m:mrow><m:mrow><m:mn>2</m:mn></m:mrow></m:msup></m:mrow></m:mfrac><m:mo>,</m:mo></m:mrow><m:mspace width="3em"/><m:mo>(14.5)</m:mo></m:math>
</div>
<figure id="f14_12" tabindex="0">
<img alt="" src="../images/fig14_12.jpg"/>
<figcaption><p><span class="blue">Figure 14.12.</span> The light coming into one point comes from another point.</p></figcaption>
</figure>
<p class="noindent1">where Δ<em>A</em>′ is the area we associate with <strong>x</strong>′. Substituting for Δσ<sub>i</sub> in terms of ΔA′ suggests the following transport equation:</p>
<div class="disp-formula" id="uequ14_32">
<m:math xmlns:mml="http://www.w3.org/1998/Math/MathML" alttext=""><m:mrow><m:msub><m:mrow><m:mi>L</m:mi></m:mrow><m:mrow><m:mi>s</m:mi></m:mrow></m:msub><m:mo stretchy="false">(</m:mo><m:mi mathvariant="bold">x</m:mi><m:mo>,</m:mo><m:mtext> </m:mtext><m:msub><m:mrow><m:mi mathvariant="bold">k</m:mi></m:mrow><m:mrow><m:mi>o</m:mi></m:mrow></m:msub><m:mo stretchy="false">)</m:mo><m:mo>=</m:mo><m:mrow><m:msub><m:mrow><m:mo>∫</m:mo></m:mrow><m:mrow><m:msup><m:mrow><m:mtext>all x</m:mtext></m:mrow><m:mrow><m:mo>′</m:mo></m:mrow></m:msup><m:mtext>visible to x</m:mtext></m:mrow></m:msub><m:mrow><m:mfrac><m:mrow><m:mi>ρ</m:mi><m:mo stretchy="false">(</m:mo><m:msub><m:mrow><m:mi mathvariant="bold">k</m:mi></m:mrow><m:mrow><m:mi>i</m:mi></m:mrow></m:msub><m:mo>,</m:mo><m:msub><m:mrow><m:mi mathvariant="bold">k</m:mi></m:mrow><m:mrow><m:mi>o</m:mi></m:mrow></m:msub><m:mo stretchy="false">)</m:mo><m:msub><m:mrow><m:mi>L</m:mi></m:mrow><m:mrow><m:mi>s</m:mi></m:mrow></m:msub><m:mo stretchy="false">(</m:mo><m:msup><m:mrow><m:mi mathvariant="bold">x</m:mi></m:mrow><m:mrow><m:mo>′</m:mo></m:mrow></m:msup><m:mo>,</m:mo><m:mtext> </m:mtext><m:mi mathvariant="bold">x</m:mi><m:mo>−</m:mo><m:msup><m:mrow><m:mi mathvariant="bold">x</m:mi></m:mrow><m:mrow><m:mo>′</m:mo></m:mrow></m:msup><m:mo stretchy="false">)</m:mo><m:mi>cos</m:mi><m:msub><m:mrow><m:mi>θ</m:mi></m:mrow><m:mrow><m:mi>i</m:mi></m:mrow></m:msub><m:mi>cos</m:mi><m:msup><m:mrow><m:mi>θ</m:mi></m:mrow><m:mrow><m:mo>′</m:mo></m:mrow></m:msup></m:mrow><m:mrow><m:mo>|</m:mo><m:mo>|</m:mo><m:mi>x</m:mi><m:mo>−</m:mo><m:msup><m:mrow><m:msup><m:mrow><m:mi mathvariant="bold">x</m:mi></m:mrow><m:mrow><m:mo>′</m:mo></m:mrow></m:msup></m:mrow><m:mrow><m:mn>2</m:mn></m:mrow></m:msup><m:mo>|</m:mo><m:mo>|</m:mo></m:mrow></m:mfrac></m:mrow><m:mrow><m:mi>d</m:mi><m:msup><m:mrow><m:mi>A</m:mi></m:mrow><m:mrow><m:mo>′</m:mo></m:mrow></m:msup><m:mtext> </m:mtext><m:mo>.</m:mo></m:mrow></m:mrow></m:mrow></m:math>
</div>
<p><span aria-label="376" epub:type="pagebreak" id="pg_376" role="doc-pagebreak"/>Note that we are using a non-normalized vector <strong>x</strong> -<strong>x</strong>′ to indicate the direction from <strong>x</strong>′ to <strong>x</strong>. Also note that we are writing L<sub>s</sub> as a function of position and direction.</p>
<p>The only problem with this new transport equation is that the domain of integration is awkward. If we introduce a visibility function, we can trade off complexity in the domain with complexity in the integrand:</p>
<div class="disp-formula" id="uequ14_33">
<m:math alttext=""><m:mrow><m:msub><m:mrow><m:mi>L</m:mi></m:mrow><m:mrow><m:mi>s</m:mi></m:mrow></m:msub><m:mo stretchy="false">(</m:mo><m:mi mathvariant="bold">x</m:mi><m:mo>,</m:mo><m:mtext> </m:mtext><m:msub><m:mrow><m:mi mathvariant="bold">k</m:mi></m:mrow><m:mrow><m:mi>o</m:mi></m:mrow></m:msub><m:mo stretchy="false">)</m:mo><m:mo>=</m:mo><m:mrow><m:msub><m:mrow><m:mo>∫</m:mo></m:mrow><m:mrow><m:msup><m:mrow><m:mtext>all x</m:mtext></m:mrow><m:mrow><m:mo>′</m:mo></m:mrow></m:msup></m:mrow></m:msub><m:mrow><m:mfrac><m:mrow><m:mi>ρ</m:mi><m:mo stretchy="false">(</m:mo><m:msub><m:mrow><m:mi mathvariant="bold">k</m:mi></m:mrow><m:mrow><m:mi>i</m:mi></m:mrow></m:msub><m:mo>,</m:mo><m:msub><m:mrow><m:mi mathvariant="bold">k</m:mi></m:mrow><m:mrow><m:mi>o</m:mi></m:mrow></m:msub><m:mo stretchy="false">)</m:mo><m:msub><m:mrow><m:mi>L</m:mi></m:mrow><m:mrow><m:mi>s</m:mi></m:mrow></m:msub><m:mo stretchy="false">(</m:mo><m:msup><m:mrow><m:mi mathvariant="bold">x</m:mi></m:mrow><m:mrow><m:mo>′</m:mo></m:mrow></m:msup><m:mo>,</m:mo><m:mtext> </m:mtext><m:mi mathvariant="bold">x</m:mi><m:mo>−</m:mo><m:msup><m:mrow><m:mi mathvariant="bold">x</m:mi></m:mrow><m:mrow><m:mo>′</m:mo></m:mrow></m:msup><m:mo stretchy="false">)</m:mo><m:mi>v</m:mi><m:mo stretchy="false">(</m:mo><m:mi mathvariant="bold">x</m:mi><m:mo>,</m:mo><m:msup><m:mrow><m:mi mathvariant="bold">x</m:mi></m:mrow><m:mrow><m:mo>′</m:mo></m:mrow></m:msup><m:mo stretchy="false">)</m:mo><m:mi>cos</m:mi><m:msub><m:mrow><m:mi>θ</m:mi></m:mrow><m:mrow><m:mi>i</m:mi></m:mrow></m:msub><m:mi>cos</m:mi><m:msup><m:mrow><m:mi>θ</m:mi></m:mrow><m:mrow><m:mo>′</m:mo></m:mrow></m:msup></m:mrow><m:mrow><m:msup><m:mrow><m:mo>|</m:mo><m:mo>|</m:mo><m:mi mathvariant="bold">x</m:mi><m:mo>−</m:mo><m:msup><m:mrow><m:msup><m:mrow><m:mi mathvariant="bold">x</m:mi></m:mrow><m:mrow><m:mo>′</m:mo></m:mrow></m:msup></m:mrow><m:mrow/></m:msup><m:mo>|</m:mo><m:mo>|</m:mo></m:mrow><m:mrow><m:mn>2</m:mn></m:mrow></m:msup></m:mrow></m:mfrac></m:mrow></m:mrow><m:mrow><m:mi>d</m:mi><m:msup><m:mrow><m:mi>A</m:mi></m:mrow><m:mrow><m:mo>′</m:mo></m:mrow></m:msup><m:mo>,</m:mo></m:mrow></m:mrow></m:math>
</div>
<p>where</p>
<div class="disp-formula" id="uequ14_34">
<m:math alttext=""><m:mrow><m:mrow><m:mi>v</m:mi><m:mrow><m:mo>(</m:mo><m:msup><m:mrow><m:mi mathvariant="bold">x</m:mi><m:mo mathvariant="bold">,</m:mo><m:mi mathvariant="bold">x</m:mi></m:mrow><m:mrow><m:mo mathvariant="bold">′</m:mo></m:mrow></m:msup><m:mo>)</m:mo><m:mo>=</m:mo><m:mo>{</m:mo><m:mtable><m:mtr><m:mtd><m:mn>1</m:mn></m:mtd><m:mtd><m:mtext>if</m:mtext><m:mtext mathvariant="bold">X</m:mtext><m:mtext>and</m:mtext><m:mtext> </m:mtext><m:msup><m:mrow><m:mtext mathvariant="bold">X</m:mtext></m:mrow><m:mrow><m:mo>′</m:mo></m:mrow></m:msup><m:mtext>are mutually</m:mtext><m:mtext>visible,</m:mtext></m:mtd></m:mtr><m:mtr><m:mtd columnalign="left"><m:mn>0</m:mn></m:mtd><m:mtd columnalign="left"><m:mtext>otherwise.</m:mtext></m:mtd></m:mtr></m:mtable></m:mrow></m:mrow></m:mrow></m:math>
</div>
</section>
<section>
<h2 id="sec14_9"><a id="index_term855"/><a epub:type="backlink" href="C02a_toc.xhtml#rsec14_9" role="doc-backlink"><span class="green">14.9 Materials in Practice</span></a></h2>
<p>Many real materials have a visible structure at normal viewing distances. For example, most carpets have easily visible pile that contributes to appearance. For our purposes, such structure is not part of the material property but is, instead, part of the geometric model. Structure whose details are invisible at normal viewing distances, but which do determine macroscopic material appearance, is part of the material property. For example, the fibers in paper have a complex appearance under magnification, but they are blurred together into an homogeneous appearance when viewed at arm’s length. This distinction between microstructure that is folded into BRDF is somewhat arbitrary and depends on what one defines as “normal” viewing distance and visual acuity, but the distinction has proven quite useful in practice.</p>
<p>There are many BRDF models in the literature and used in the industry. There are many fields that use BRDF models including remote sensing, heat transfer, materials science, and of course, computer graphics. Unfortunately, there not a standard set of terms across these fields but also not even within graphics. However, these are some terms most people agree on and those are shown in <a href="C19_chapter14.xhtml#f14_13">Figure 14.13</a>.</p>
<figure id="f14_13" tabindex="0">
<img alt="" src="../images/fig14_13.jpg"/>
<figcaption><p><span class="blue">Figure 14.13.</span> A taxonomy of material terms advocated by McGuire et al. (2020)</p></figcaption>
</figure>
<p>Practice in the industry has been to classify materials into these categories and has a different BRDF model for each term. These models terms are then combined with either constants or simple weights determined by Fresnel (Schlick) variation. A key question is then what terms to use. Increasingly practice has settled on variations of the Burley/Disney model developed for computer-generated animation (Burley, 2012), but it is widely adopted now in games and product design as well. It includes terms for each of the major categories in <a href="C19_chapter14.xhtml#f14_13">Figure 14.13</a>, <a id="term-340"/><a id="term-523"/><a id="term-539"/><a id="term-610"/><a id="term-611"/><a id="term-612"/><span aria-label="377" epub:type="pagebreak" id="pg_377" role="doc-pagebreak"/>as well as an additional lobe: <em>sheen</em>. That was not included in the taxonomy of <a href="C19_chapter14.xhtml#f14_13">Figure 14.13</a> because it is not a term that is yet widely used inside graphics, and not used as a technical term outside of graphics. The sheen term is used to account for grazing angle effects such as <em>rim lighting</em> that can be seen especially on skin and fabrics, and more information can be found in <a id="index_term349"/>Estevez, <a id="index_term565"/>Imageworks, and <a id="index_term653"/>Kulla (n.d.). The retro-reflective terms are very important in some circumstances, but is not very commonly used in graphics.</p>
<p>The two most universal terms used in BRDF models in practice are the diffuse and glossy lobes. A constant is often used for diffuse, but there are other variations that get darker at grazing angles where the glossy lobe takes over. The most dominant form of glossy lobe at present is the <em>GGX microfacet</em> lobe (Walter et al., 2007). The microfacet lobes are very closely related to our brute force representation of a rough surface, but just find the statistical distribution of surface normals of the microfacets. Note that these microfacet methods are an approximation to an actual surface with microfacets. This subject is discussed in depth with an eye toward implementation by <a id="index_term518"/>Heitz (2014).</p>
</section>
<section>
<h2 id="sec14_10"><a id="index_term856"/><a epub:type="backlink" href="C02a_toc.xhtml#rsec14_10" role="doc-backlink"><span class="green">14.10 Monte Carlo Ray Tracing</span></a></h2>
<p>Once we have expressed lighting as an integral, we can solve it using <em>Monte Carlo Integration</em> (see <a href="C07_chapter2.xhtml#sec2_12">Section 2.12</a>). Recall that for an integral of f(x), the Monte Carlo <span aria-label="378" epub:type="pagebreak" id="pg_378" role="doc-pagebreak"/>integral is just the average from many random samples:</p>
<div class="disp-formula" id="uequ14_35">
<m:math alttext=""><m:mrow><m:mstyle displaystyle="true"><m:mrow><m:msub><m:mrow><m:mo>∫</m:mo></m:mrow><m:mrow><m:mi>S</m:mi></m:mrow></m:msub><m:mi>f</m:mi></m:mrow></m:mstyle><m:mo stretchy="false">(</m:mo><m:mi>x</m:mi><m:mo stretchy="false">)</m:mo><m:mi>d</m:mi><m:mi>μ</m:mi><m:mo stretchy="false">(</m:mo><m:mi>x</m:mi><m:mo stretchy="false">)</m:mo><m:mo>≈</m:mo><m:mtext>average</m:mtext><m:mrow><m:mo>(</m:mo><m:mfrac><m:mrow><m:mi>f</m:mi><m:mo stretchy="false">(</m:mo><m:msub><m:mrow><m:mi>x</m:mi></m:mrow><m:mrow><m:mtext>random</m:mtext></m:mrow></m:msub><m:mo stretchy="false">)</m:mo></m:mrow><m:mrow><m:mi>p</m:mi><m:mo stretchy="false">(</m:mo><m:msub><m:mrow><m:mi>x</m:mi></m:mrow><m:mrow><m:mtext>random</m:mtext></m:mrow></m:msub><m:mo stretchy="false">)</m:mo></m:mrow></m:mfrac><m:mo>,</m:mo><m:mo>)</m:mo></m:mrow></m:mrow></m:math>
</div>
<p>where <em>p</em> is a probability density function over the domain <em>S</em>. If we apply that to Equation 14.4, then for one random sample direction <strong>q</strong>, we get</p>
<div class="disp-formula" id="uequ14_36">
<m:math alttext=""><m:mrow><m:msub><m:mrow><m:mi>L</m:mi></m:mrow><m:mrow><m:mi>s</m:mi></m:mrow></m:msub><m:mo stretchy="false">(</m:mo><m:msub><m:mrow><m:mi mathvariant="bold">k</m:mi></m:mrow><m:mrow><m:mi>o</m:mi></m:mrow></m:msub><m:mo stretchy="false">)</m:mo><m:mo>≈</m:mo><m:mfrac><m:mrow><m:mi>ρ</m:mi><m:mo stretchy="false">(</m:mo><m:mi mathvariant="bold">q</m:mi><m:mo>,</m:mo><m:msub><m:mrow><m:mi mathvariant="bold">k</m:mi></m:mrow><m:mrow><m:mi>o</m:mi></m:mrow></m:msub><m:mo stretchy="false">)</m:mo><m:msub><m:mrow><m:mi>L</m:mi></m:mrow><m:mrow><m:mi>f</m:mi></m:mrow></m:msub><m:mo stretchy="false">(</m:mo><m:mi mathvariant="bold">q</m:mi><m:mo stretchy="false">)</m:mo><m:mi>cos</m:mi><m:msub><m:mrow><m:mi>θ</m:mi></m:mrow><m:mrow><m:mi>i</m:mi></m:mrow></m:msub></m:mrow><m:mrow><m:mi>p</m:mi><m:mo stretchy="false">(</m:mo><m:mi mathvariant="bold">q</m:mi><m:mo stretchy="false">)</m:mo></m:mrow></m:mfrac></m:mrow></m:math>
</div>
<p>Note for a less noisy image, we would average over many noisy samples. So how do we do that? First, we need a way to generate random directions for some PDF <em>p</em>. Remember <em>p</em> can be any valid PDF, so let’s do uniform: <em>p</em> = 1∕(2π∕). That is the value because the integral is over “the solid angle of all incoming directions above the surface” and the solid angle is the area of the projection onto the unit sphere, and the directions “above” the surface are half the sphere, which has an area of 2π.</p>
<p class="indentb">In code, this would look something like this for an incident ray direction <strong>a</strong>:</p>
<p class="indent1">pick random direction <strong>q</strong><br/>color = ρ(<strong>q</strong>,<strong>a</strong>)<em>L<sub>f</sub></em>(<strong>q</strong>)cosθ<sub>i</sub>∕<em>p</em>(<strong>q</strong>)</p>
<p class="noindent1">But what is <em>L<sub>f</sub></em>, the color coming from direction <strong>q</strong>? We can in fact apply Monte Carlo integration recursively (this is not obvious, but can be shown using the property of random variables that expected values sum even when the terms of the sum are not independent). If we write a function <em>L</em>(<strong>o</strong>,<strong>d</strong>) that returns the color at a point <strong>p</strong> coming from the direction <strong>d</strong>, and add emitted light so there is something to see, then we can write a recursive function:</p>
<p class="noindent1"><strong>function</strong> rgb radiance(<strong>o</strong>, <strong>d</strong>)<br/>  <strong>if</strong> ray <strong>o</strong> + t<strong>d</strong> hits something <strong>then</strong><br/>     <strong>p</strong> = hit point<br/>     <strong>q</strong> = random direction<br/>      return emitted(<strong>p</strong>) + (ρ(<strong>q</strong>,<strong>–d</strong>)cosθ<sub>i</sub>∕p(<strong>q</strong>))* radiance(<strong>p</strong>, <strong>q</strong>)<br/><strong>else</strong><br/>     return background(<strong>o</strong>, <strong>d</strong>)</p>
<p class="noindent1">Note that if the environment is closed that function never terminates, so some termination bailout should be added for closed environments. The background function could either return a constant or look up into an environment map or other function that varies with direction. Finally, there don’t need to be lights other than the background to get good pictures.</p>
<p><span aria-label="379" epub:type="pagebreak" id="pg_379" role="doc-pagebreak"/>You may note this is very similar to the adjoint photon tracer developed earlier in this chapter. The method of derivation is different, taking an explicit radiometric integration approach, but it does reach a similar conclusion.</p>
<p class="indentb">In practice, that algorithm will be very noisy when the lights are small because the values of <em>emitted()</em> can be large and for small lights rare. Instead, people often break out <em>direct lighting</em> by computing the contribution of light emitting objects separately. For example,</p>
<p class="indent1"><strong>function</strong> rgb radiance(<strong>o</strong>, <strong>d</strong>)</p>
<p class="indent1">    <strong>if</strong> ray <strong>o</strong> + t<strong>d</strong> hits something <strong>then</strong></p>
<p class="indent1">        <strong>p</strong> = hit point</p>
<p class="indent1">        <strong>q</strong> = random direction</p>
<p class="indent1">         return directLightAt(<strong>p</strong>) + (ρ(<strong>q</strong>,<strong>–d</strong>)cosθ<sub>i</sub>∕p(<strong>q</strong>))* radiance(<strong>p</strong>, <strong>q</strong>)</p>
<p class="indent1"><strong>else</strong></p>
<p class="indent1">        return background(<strong>o</strong>, <strong>d</strong>)</p>
<p class="noindent1">Here, directLightAt(<strong>p</strong>) computes the <em>direct lighting</em>, i.e., the color due to photons that leave the lights and get to <strong>p</strong> without any intervening surfaces. This code has the idiosyncrasy that lights seen directly will look black (there is no explicit emitted term in the code) so there in practice real codes need to deal with this somehow.</p>
<p><a id="index_term330"/>Direct lighting is often also computed using Monte Carlo, but usually using an area measure to pick samples only on lights sources and thus evaluate Equation 14.5.</p>
<p>Note that the above method works well as long as the material are not perfectly smooth, i.e., impulses in <a href="C19_chapter14.xhtml#f14_13">Figure 14.13</a>. Technically for those materials, the BRDF is a <em>delta function</em> with infinite value at exactly one direction so it works formally but not with computer floating point arithmetic. There we need an “if” for such materials which we handle just like in <a href="C09_chapter4.xhtml#c4">Chapter 4</a> for rays.</p>
</section>
<section>
<h2 id="sec14_11"><span class="green">Frequently Asked Questions</span></h2>
<ul class="list-bullet">
<li>
<p class="list"><span class="green">What is “intensity”?</span></p>
</li>
</ul>
<p class="noindent1b">The term <em>intensity</em> is used in a variety of contexts and its use varies with both era and discipline. In practice, it is no longer meaningful as a specific radiometric quantity, but it is useful for intuitive discussion. Most papers that use it do so in place of radiance.</p>
<ul>
<li>
<p class="list"><span class="green">What is “radiosity”?</span></p>
</li>
</ul>
<p class="noindent1b">The term <em>radiosity</em> is used in place of radiant exitance in some fields. It is also sometimes used to describe world-space light transport algorithms.</p>
<ul>
<li>
<p class="list"><span class="green">My images look too smooth, even with a complex BRDF. What am I doing wrong?</span></p>
</li></ul>
<p class="noindent1b">BRDFs only capture subpixel detail that is too small to be resolved by the eye. Most real surfaces also have some small variations, such as the wrinkles in skin, that can be seen. If you want true realism, some sort of texture or displacement map is needed.</p>
<ul>
<li>
<p class="list"><span class="green">How do I integrate the BRDF with texture mapping?</span></p>
</li>
</ul>
<p class="noindent1b">Texture mapping can be used to control any parameter on a surface. So any kinds of colors or control parameters used by a BRDF should be programmable.</p>
<ul>
<li>
<p class="list"><span class="green">I have very pretty code except for my material class. What am I doing wrong?</span></p>
</li>
</ul>
<p class="noindent1b">You are probably doing nothing wrong. Material classes tend to be the ugly thing in everybody’s programs. If you find a nice way to deal with it, please let us know! Our own codes uses a shader architecture (Hanrahan &amp; Lawson, 1990) which makes the material include much of the rendering algorithm.</p>
<ul>
<li>
<p class="list"><span class="green">What models do people use for phase functions?</span></p>
</li>
</ul>
<p class="noindent1b">Almost the only model used is the Henyey–Greenstein function which has a single parameter that controls how “stretched” it is.</p>
<ul>
<li>
<p class="list"><span class="green">The BRDF and the phase function seem pretty similar so why are they treated so differently?</span></p>
</li>
</ul>
<p class="noindent1b">The BRDF actually can be treated as a phase function and scattering albedo, but for historical and practical measurement reasons, they are usually treated differently. Giving them a unified representation in code works fine, but will need some explanation to people used to BRDFs for surfaces.</p>
</section>
<section>
<h2 id="sec14_11a"><span class="green">Notes</span></h2>
<p>There are many, many other advanced methods that can be implemented in the ray-tracing framework. Some resources for further information are Glassner’s <em>An <span aria-label="381" epub:type="pagebreak" id="pg_381" role="doc-pagebreak"/>Introduction to Ray Tracing</em> and <em>Principles of Digital Image Synthesis</em>, Shirley’s <em>Ray Tracing in One Weekend</em> series, and <a id="index_term844"/>Pharr et al.’s <em>Physically Based</em> <em>Rendering: From Theory to Implementation</em>, <a id="index_term6"/>Akenine-Möller et al.’s <em>Real Time</em> <em>Rendering</em>, the two <em>Ray Tracing Gems</em> collections, and McGuire’s <em>Graphics</em> <em>Codex</em>.</p>
<p>A common radiometric quantity not described in this chapter is <em>radiant intensity</em> (I), which is the spectral power per steradian emitted from an infinitesimal point source. It should usually be avoided in graphics programs because point sources cause implementation problems. A more rigorous treatment of radiometry can be found in <em>Analytic Methods for Simulated Light Transport</em> (Arvo, 1995a). The radiometric and photometric terms in this chapter are from the <em>Illumination Engineering Society’s</em> standard that is increasingly used by all fields of science and engineering (American National Standard Institute, 1986). A broader discussion of radiometric and appearance standards can be found in <em>Principles of Digital Image Synthesis</em> (Glassner, 1995).</p>
<p>There are many BRDF models described in the literature, and only a few of them have been described here. Others include (Cook &amp; Torrance, 1982; He et al., 1992; Oren &amp; Nayar, 1994; Schlick, 1994; Lafortune, Foo, Torrance, &amp; Greenberg, 1997; Stam, 1999; Ashikhmin, Premože, &amp; Shirley, 2000; Ershov, Kolchin, &amp; Myszkowski, 2001; Matusik, Pfister, Brand, &amp; McMillan, 2003; Lawrence, Rusinkiewicz, &amp; Ramamoorthi, 2004; Stark, Arvo, &amp; Smits, 2005). The desired characteristics of BRDF models are discussed in <em>Making Shaders More Physically</em> <em>Plausible</em> (Lewis, 1994). The activity at modern film and games studios is very much paying attention to as material models are still advancing, with Unity, Solid Angle, Disney, and Sony being interesting examples. For the glossy term the dominant model, by far, is the <em>GGX</em> model, which is covered extensively in the PBRT book and many papers co-authored by Eric Heitz, notably (Heitz &amp; d’Eon, 2014).</p>
</section>
<section>
<h2 id="sec14_13"><span class="green">Exercises</span></h2>
<p class="qpara"><span class="green">1.</span> Suppose that instead of the Lambertian BRDF, we used a BRDF of the form Ccos<sup>a</sup>θ<sub>i</sub>. What must C be to conserve energy?</p>
<p class="qpara"><span class="green">2.</span> The BRDF in Exercise 1 is not reciprocal. Can you modify it to be reciprocal?</p>
<p class="qpara"><span class="green">3.</span> Something like a highway sign is a <em>retroreflector</em>. This means that the BRDF is large when <strong>k</strong><sub>i</sub> and <strong>k</strong><sub>o</sub> are near each other. Make a model inspired <span aria-label="382" epub:type="pagebreak" id="pg_382" role="doc-pagebreak"/>by the Phong model that captures retroreflection behavior while being reciprocal and conserving energy.</p>
<p class="qpara"><span class="green">4.</span> For a diffuse surface with outgoing radiance <em>L</em>, what is the radiant exitance?</p>
<p class="qpara"><span class="green">5.</span> What is the total power exiting a diffuse surface with an area of 4 m<sup>2</sup> and a radiance of <em>L</em>?</p>
<p class="qpara"><span class="green">6.</span> If a fluorescent light and an incandescent light both consume 20 Watts of power, why is the fluorescent light usually preferred?</p>
</section>
</section>
</body>
</html>