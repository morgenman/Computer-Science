<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xmlns:m="http://www.w3.org/1998/Math/MathML" xmlns:svg="http://www.w3.org/2000/svg" dir="ltr" lang="en" xml:lang="en">
<head>
<meta charset="UTF-8"/>
<title>8 Viewing</title>
<link href="../styles/9781000426359.css" rel="stylesheet" type="text/css"/>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
jax: ["input/TeX","input/MathML","output/SVG"],
extensions: ["tex2jax.js","mml2jax.js","MathEvents.js"],
TeX: {
extensions: ["noErrors.js","noUndefined.js","autoload-all.js"]
},
MathMenu: {
showRenderer: false
},
menuSettings: {
zoom: "Click"
},
messageStyle: "none"
});
</script>
<script src="../mathjax/MathJax.js" type="text/javascript"/>
<meta content="urn:uuid:e0000000-0000-0000-0000-000006665500" name="Adept.expected.resource"/>
</head>
<body epub:type="bodymatter">
<section epub:type="chapter" role="doc-chapter">
<h1 class="chapz" id="c8"><a id="index_term1265"/><a id="term-705"/><a id="term-1139"/><span aria-label="157" epub:type="pagebreak" id="pg_157" role="doc-pagebreak"/><a epub:type="backlink" href="C02a_toc.xhtml#rc8" role="doc-backlink"><span class="green"><span class="big1">8</span><br/>Viewing</span></a></h1>
<p>In the previous chapter, we saw how to use matrix transformations as a tool for arranging geometric objects in 2D or 3D space. A second important use of geometric transformations is in moving objects between their 3D locations and their positions in a 2D view of the 3D world. This 3D to 2D mapping is called a <em><a id="index_term1317"/>viewing transformation</em>, and it plays an important role in object-order rendering, in which we need to rapidly find the image-space location of each object in the scene.</p>
<p>When we studied ray tracing in <a href="C09_chapter4.xhtml#c4">Chapter 4</a>, we covered the different types of perspective and orthographic views and how to generate viewing rays according to any given view. This chapter is about the inverse of that process. Here, we explain how to use matrix transformations to express any parallel or perspective view. The transformations in this chapter project 3D points in the scene (world space) to 2D points in the image (image space), and they will project any point on a given pixel’s viewing ray back to that pixel’s position in image space.</p>
<p>If you have not looked at it recently, it is advisable to review the discussion of perspective and ray generation in <a href="C09_chapter4.xhtml#c4">Chapter 4</a> before reading this chapter.</p>
<p>By itself, the ability to project points from the world to the image is only good for producing <em>wireframe</em> renderings—renderings in which only the edges of objects are drawn, and closer surfaces do not occlude more distant surfaces (<a href="C13_chapter8.xhtml#f8_1">Figure 8.1</a>). Just as a ray tracer needs to find the closest surface intersection along each viewing ray, an object-order renderer displaying solid-looking objects has to work out which of the (possibly many) surfaces drawn at any given point on the screen is closest and display only that one. In this chapter, we assume we <a id="term-647"/><a id="term-706"/><a id="term-1140"/><span aria-label="158" epub:type="pagebreak" id="pg_158" role="doc-pagebreak"/>are drawing a model consisting only of 3D line segments that are specified by the (<em>x, y, z</em>) coordinates of their two endpoints. Later chapters will discuss the machinery needed to produce renderings of solid surfaces.</p>
<figure id="f8_1" tabindex="0">
<img alt="" src="../images/fig8_1.jpg"/>
<figcaption><p><span class="blue">Figure 8.1.</span> (a) Wireframe cube in orthographic projection. (b) Wireframe cube in perspective projection. (c) Perspective projection with hidden lines removed.</p></figcaption>
</figure>
<section>
<h2 id="sec8_1"><a epub:type="backlink" href="C02a_toc.xhtml#rsec8_1" role="doc-backlink"><span class="green">8.1 Viewing Transformations</span></a></h2>
<p>The viewing transformation has the job of mapping 3D locations, represented as (<em>x, y, z</em>) coordinates in the canonical coordinate system, to coordinates in the image, expressed in units of pixels. It is a complicated beast that depends on many different things, including the camera position and orientation, the type of projection, the field of view, and the resolution of the image. As with all complicated transformations, it is best approached by breaking it up into a product of several simpler transformations. Most graphics systems do this by using a sequence of three transformations:</p>
<ul class="list-bullet">
<li>
<p class="list">A <em>camera transformation</em> or <em><a id="index_term1260"/><a id="index_term354"/>eye transformation</em>, which is a rigid body transformation that places the camera at the origin in a convenient orientation. It depends only on the position and orientation, or <em>pose</em>, of the camera.</p>
</li>
<li>
<p class="list">A <em>projection transformation</em>, which projects points from camera space so that all visible points fall in the range <em>–</em>1 to 1 in <em>x</em> and <em>y</em>. It depends only on the type of <a id="index_term1263"/>projection desired.</p>
</li>
<li>
<p class="list">A <em><a id="index_term1266"/><a id="index_term1320"/>viewport transformation</em> or <em><a id="index_term1268"/>windowing transformation</em>, which maps this unit image rectangle to the desired rectangle in pixel coordinates. It depends only on the size and position of the output image.</p>
</li>
</ul>
<aside class="boxed-text" epub:type="sidebar">
<p class="noindent">Some APIs use “viewing transformation” for just the piece of our viewing transformation that we call the <a id="index_term119"/><a id="index_term1256"/>camera transformation.</p>
</aside>
<p class="noindent">To make it easy to describe the stages of the process (<a href="C13_chapter8.xhtml#f8_2">Figure 8.2</a>), we give names to the coordinate systems that are the inputs and output of these transformations.</p>
<figure id="f8_2" tabindex="0">
<img alt="" src="../images/fig8_2.jpg"/>
<figcaption><p><span class="blue">Figure 8.2.</span> <a id="term-960"/><a id="term-997"/><span aria-label="159" epub:type="pagebreak" id="pg_159" role="doc-pagebreak"/>The sequence of spaces and transformations that gets objects from their original coordinates into screen space.</p></figcaption>
</figure>
<p class="noindent">The camera transformation converts points in canonical coordinates (or world space) to <em><a id="index_term116"/>camera coordinates</em> or places them in <em>camera space</em>. The projection transformation moves points from camera space to the <em>canonical view volume</em>. Finally, the viewport transformation maps the canonical view volume to <em>screen space</em>.</p>
<p>Each of these transformations is individually quite simple. We’ll discuss them in detail for the orthographic case beginning with the viewport transformation and then cover the changes required to support perspective projection.</p>
<aside class="boxed-text" epub:type="sidebar">
<p class="noindent">Other names: <a id="index_term118"/>camera space is also “eye space,” and the camera transformation is sometimes the “viewing transformation;” the canonical view volume is also “clip space” or “normalized device coordinates;” <a id="index_term1024"/>screen space is also “pixel coordinates.”</p>
</aside>
<section>
<h3 id="sec8_1_1"><span class="green">8.1.1 The Viewport Transformation</span></h3>
<p>We begin with a problem whose solution will be reused for any viewing condition. We assume that the geometry we want to view is in the <em>canonical view volume</em>, and we wish to view it with an orthographic camera looking in the <em>– z</em> direction. The <a id="index_term123"/>canonical view volume is the cube containing all 3D points whose Cartesian coordinates are between <em>–</em>1 and +1—that is, (<em>x, y, z</em>) ∈ [<em>–</em>1, 1]<sup>3</sup> (<a href="C13_chapter8.xhtml#f8_3">Figure 8.3</a>). We project <em>x</em> = <em>–</em>1 to the left side of the screen, <em>x</em> = +1 to the right side of the screen, <em>y</em> = <em>–</em>1 to the bottom of the screen, and <em>y</em> = +1 to the top of the screen.</p>
<aside class="boxed-text" epub:type="sidebar">
<p class="noindent">The word “canonical” crops up again—it means something arbitrarily chosen for convenience. For instance, the unit circle could be called the “canonical circle.”</p>
</aside>
<p class="indent">Recall the conventions for pixel coordinates from <a href="C08_chapter3.xhtml#c3">Chapter 3</a>: each pixel “owns” a unit square centered at integer coordinates; the image boundaries have a half-unit <span aria-label="160" epub:type="pagebreak" id="pg_160" role="doc-pagebreak"/>overshoot from the pixel centers; and the smallest pixel center coordinates are (0, 0) . If we are drawing into an image (or window on the screen) that has <em>n<sub>x</sub></em> by <em>n<sub>y</sub></em> pixels, we need to map the square [<em>–</em>1, 1]<sup>2</sup> to the rectangle [<em>–</em>0.5<em>,n<sub>x</sub> –</em> 0.5] × [<em>–</em>0.5<em>,n<sub>y</sub> –</em> 0.5].</p>
<aside class="boxed-text" epub:type="sidebar">
<p class="noindent">Mapping a square to a potentially non-square rectangle is not a problem; <em>x</em> and <em>y</em> just end up with different scale factors going from canonical to pixel coordinates.</p>
</aside>
<p class="indent">For now, we will assume that all line segments to be drawn are completely inside the canonical view volume. Later, we will relax that assumption when we discuss <em><a id="index_term148"/>clipping</em>.</p>
<p>Since the viewport transformation maps one axis-aligned rectangle to another, it is a case of the windowing transform given by Equation (7.6):</p>
<div class="disp-formula" id="equ8_1">
<m:math alttext=""><m:mrow><m:mrow><m:mo>[</m:mo><m:mtable><m:mtr><m:mtd><m:mtable><m:mtr><m:mtd><m:msub><m:mrow><m:mi>x</m:mi></m:mrow><m:mrow><m:mtext>screen</m:mtext></m:mrow></m:msub></m:mtd></m:mtr><m:mtr><m:mtd><m:msub><m:mrow><m:mi>y</m:mi></m:mrow><m:mrow><m:mtext>screen</m:mtext></m:mrow></m:msub></m:mtd></m:mtr></m:mtable></m:mtd></m:mtr><m:mtr><m:mtd><m:mn>1</m:mn></m:mtd></m:mtr></m:mtable><m:mo>]</m:mo><m:mo>=</m:mo><m:mrow><m:mo>[</m:mo><m:mtable><m:mtr><m:mtd><m:mfrac><m:mrow><m:msub><m:mrow><m:mi>n</m:mi></m:mrow><m:mrow><m:mi>x</m:mi></m:mrow></m:msub></m:mrow><m:mrow><m:mn>2</m:mn></m:mrow></m:mfrac></m:mtd><m:mtd><m:mn>0</m:mn></m:mtd><m:mtd><m:mfrac><m:mrow><m:msub><m:mrow><m:mi>n</m:mi></m:mrow><m:mrow><m:mi>x</m:mi></m:mrow></m:msub><m:mo>−</m:mo><m:mn>1</m:mn></m:mrow><m:mrow><m:mn>2</m:mn></m:mrow></m:mfrac></m:mtd></m:mtr><m:mtr><m:mtd><m:mn>0</m:mn></m:mtd><m:mtd><m:mfrac><m:mrow><m:msub><m:mrow><m:mi>n</m:mi></m:mrow><m:mrow><m:mi>y</m:mi></m:mrow></m:msub></m:mrow><m:mrow><m:mn>2</m:mn></m:mrow></m:mfrac></m:mtd><m:mtd><m:mfrac><m:mrow><m:msub><m:mrow><m:mi>n</m:mi></m:mrow><m:mrow><m:mi>y</m:mi></m:mrow></m:msub><m:mo>−</m:mo><m:mn>1</m:mn></m:mrow><m:mrow><m:mn>2</m:mn></m:mrow></m:mfrac></m:mtd></m:mtr><m:mtr><m:mtd><m:mn>0</m:mn></m:mtd><m:mtd><m:mn>0</m:mn></m:mtd><m:mtd><m:mn>1</m:mn></m:mtd></m:mtr></m:mtable><m:mo>]</m:mo><m:mrow><m:mo>[</m:mo><m:mtable><m:mtr><m:mtd><m:mtable><m:mtr><m:mtd><m:msub><m:mrow><m:mi>x</m:mi></m:mrow><m:mrow><m:mtext>canonical</m:mtext></m:mrow></m:msub></m:mtd></m:mtr><m:mtr><m:mtd><m:msub><m:mrow><m:mi>y</m:mi></m:mrow><m:mrow><m:mtext>canonical</m:mtext></m:mrow></m:msub></m:mtd></m:mtr><m:mtr><m:mtd><m:mn>1</m:mn></m:mtd></m:mtr></m:mtable></m:mtd></m:mtr><m:mtr><m:mtd/></m:mtr></m:mtable><m:mo>]</m:mo><m:mn>.</m:mn></m:mrow></m:mrow></m:mrow></m:mrow><m:mspace width="3em"/><m:mo>(8.1)</m:mo></m:math>
</div>
<p>Note that this matrix ignores the <em>z</em>-coordinate of the points in the canonical view volume, because a point’s distance along the projection direction doesn’t affect where that point projects in the image. But before we officially call this the <em>view-port matrix</em>, we add a row and column to carry along the <em>z</em>-coordinate without changing it. We don’t need it in this chapter, but eventually, we will need the <em>z</em> values because they can be used to make closer surfaces hide more distant surfaces (see <a href="C14_chapter9.xhtml#sec9_2_3">Section 9.2.3</a>).</p>
<figure id="f8_3" tabindex="0">
<img alt="" src="../images/fig8_3.jpg"/>
<figcaption><p><span class="blue">Figure 8.3.</span> The canonical view volume is a cube with side of length two centered at the origin.</p></figcaption>
</figure>
<div class="disp-formula" id="equ8_2">
<m:math alttext=""><m:mrow><m:msub><m:mrow><m:mi>M</m:mi></m:mrow><m:mrow><m:mtext>vp</m:mtext></m:mrow></m:msub><m:mo>=</m:mo><m:mrow><m:mo>[</m:mo><m:mtable><m:mtr><m:mtd><m:mfrac><m:mrow><m:msub><m:mrow><m:mi>n</m:mi></m:mrow><m:mrow><m:mi>x</m:mi></m:mrow></m:msub></m:mrow><m:mrow><m:mn>2</m:mn></m:mrow></m:mfrac></m:mtd><m:mtd><m:mn>0</m:mn></m:mtd><m:mtd><m:mn>0</m:mn></m:mtd><m:mtd><m:mfrac><m:mrow><m:msub><m:mrow><m:mi>n</m:mi></m:mrow><m:mrow><m:mi>x</m:mi></m:mrow></m:msub><m:mo>−</m:mo><m:mn>1</m:mn></m:mrow><m:mrow><m:mn>2</m:mn></m:mrow></m:mfrac></m:mtd></m:mtr><m:mtr><m:mtd><m:mn>0</m:mn></m:mtd><m:mtd><m:mfrac><m:mrow><m:msub><m:mrow><m:mi>n</m:mi></m:mrow><m:mrow><m:mi>y</m:mi></m:mrow></m:msub></m:mrow><m:mrow><m:mn>2</m:mn></m:mrow></m:mfrac></m:mtd><m:mtd><m:mn>0</m:mn></m:mtd><m:mtd><m:mfrac><m:mrow><m:msub><m:mrow><m:mi>n</m:mi></m:mrow><m:mrow><m:mi>y</m:mi></m:mrow></m:msub><m:mo>−</m:mo><m:mn>1</m:mn></m:mrow><m:mrow><m:mn>2</m:mn></m:mrow></m:mfrac></m:mtd></m:mtr><m:mtr><m:mtd><m:mn>0</m:mn></m:mtd><m:mtd><m:mn>0</m:mn></m:mtd><m:mtd><m:mn>1</m:mn></m:mtd><m:mtd><m:mn>0</m:mn></m:mtd></m:mtr><m:mtr><m:mtd><m:mn>0</m:mn></m:mtd><m:mtd><m:mn>0</m:mn></m:mtd><m:mtd><m:mn>0</m:mn></m:mtd><m:mtd><m:mn>1</m:mn></m:mtd></m:mtr></m:mtable><m:mo>]</m:mo><m:mn>.</m:mn></m:mrow></m:mrow><m:mspace width="3em"/><m:mo>(8.2)</m:mo></m:math>
</div>
</section>
<section>
<h3 id="sec8_1_2"><a id="index_term810"/><span class="green">8.1.2 The Orthographic Projection Transformation</span></h3>
<p>Of course, we usually want to render geometry in some region of space other than the canonical view volume. Our first step in generalizing the view will keep the view direction and orientation fixed looking along <em>– z</em> with +<em>y</em> up, but will allow arbitrary rectangles to be viewed. Rather than replacing the <a id="index_term1319"/>viewport matrix, we’ll augment it by multiplying it with another matrix on the right.</p>
<figure id="f8_4" tabindex="0">
<img alt="" src="../images/fig8_4.jpg"/>
<figcaption><p><span class="blue">Figure 8.4.</span> The ortho-graphic view volume.</p></figcaption>
</figure>
<p>Under these constraints, the view volume is an axis-aligned box, and we’ll name the coordinates of its sides so that the view volume is [<em>l, r</em>] × [<em>b, t</em>] × [<em>f, n</em>] shown in <a href="C13_chapter8.xhtml#f8_4">Figure 8.4</a>. We call this box the <em><a id="index_term813"/>orthographic view volume</em> and refer to <a id="term-576"/><span aria-label="161" epub:type="pagebreak" id="pg_161" role="doc-pagebreak"/>the bounding planes as follows:</p>
<figure id="f8_5" tabindex="0">
<img alt="" src="../images/fig8_5.jpg"/>
<figcaption><p><span class="blue">Figure 8.5.</span> The orthographic view volume is along the negative <em>z</em>-axis, so <em>f</em> is a more negative number than <em>n</em>; thus, <em>n &gt; f</em>.</p></figcaption>
</figure>
<div class="disp-formula">
<m:math alttext=""><m:mrow><m:mtable><m:mtr><m:mtd><m:mi>x</m:mi><m:mo>=</m:mo><m:mi>l</m:mi><m:mo>≡</m:mo><m:mtext>left plane,</m:mtext></m:mtd></m:mtr><m:mtr><m:mtd><m:mi>x</m:mi><m:mo>=</m:mo><m:mi>r</m:mi><m:mo>≡</m:mo><m:mtext>right plane,</m:mtext></m:mtd></m:mtr><m:mtr><m:mtd><m:mi>y</m:mi><m:mo>=</m:mo><m:mi>b</m:mi><m:mo>≡</m:mo><m:mtext>bottom plane,</m:mtext></m:mtd></m:mtr><m:mtr><m:mtd><m:mi>y</m:mi><m:mo>=</m:mo><m:mi>t</m:mi><m:mo>≡</m:mo><m:mtext>top plane,</m:mtext></m:mtd></m:mtr><m:mtr><m:mtd><m:mi>z</m:mi><m:mo>=</m:mo><m:mi>n</m:mi><m:mo>≡</m:mo><m:mtext>near plane</m:mtext></m:mtd></m:mtr><m:mtr><m:mtd><m:mi>z</m:mi><m:mo>=</m:mo><m:mi>f</m:mi><m:mo>≡</m:mo><m:mtext>far plane.</m:mtext></m:mtd></m:mtr></m:mtable></m:mrow></m:math>
</div>
<p>That vocabulary assumes a viewer who is looking along the <em>minus z</em>-axis with his head pointing in the <em>y</em>-direction.<a epub:type="noteref" href="C13_chapter8.xhtml#fn8_1" id="rfn8_1" role="doc-noteref"><sup>1</sup></a> This implies that <em>n &gt; f</em>, which may be unintuitive, but if you assume the entire orthographic view volume has negative <em>z</em> values, then the <em>z</em> = <em>n</em> “near” plane is closer to the viewer if and only if <em>n &gt; f</em> ; here, <em>f</em> is a smaller number than <em>n</em>, i.e., a negative number of larger absolute value than <em>n</em>.</p>
<p>This concept is shown in <a href="C13_chapter8.xhtml#f8_5">Figure 8.5</a>. The transform from orthographic view volume to the canonical view volume is another windowing transform, so we can simply substitute the bounds of the orthographic and canonical view volumes into Equation (7.7) to obtain the matrix for this transformation:</p>
<aside class="boxed-text" epub:type="sidebar">
<p class="noindent">This matrix is very close to the one used traditionally in OpenGL, except that <em>n</em>, <em>f</em>, and <em>z</em>canonical all have the opposite sign.</p>
</aside>
<div class="disp-formula" id="equ8_3">
<m:math alttext=""><m:mrow><m:msub><m:mrow><m:mtext>M</m:mtext></m:mrow><m:mrow><m:mtext>orth</m:mtext></m:mrow></m:msub><m:mo>=</m:mo><m:mrow><m:mo>[</m:mo><m:mtable><m:mtr><m:mtd><m:mfrac><m:mrow><m:mn>2</m:mn></m:mrow><m:mrow><m:mi>r</m:mi><m:mo>−</m:mo><m:mi>l</m:mi></m:mrow></m:mfrac></m:mtd><m:mtd><m:mn>0</m:mn></m:mtd><m:mtd><m:mn>0</m:mn></m:mtd><m:mtd><m:mo>−</m:mo><m:mfrac><m:mrow><m:mi>r</m:mi><m:mo>+</m:mo><m:mi>l</m:mi></m:mrow><m:mrow><m:mi>r</m:mi><m:mo>−</m:mo><m:mi>l</m:mi></m:mrow></m:mfrac></m:mtd></m:mtr><m:mtr><m:mtd><m:mn>0</m:mn></m:mtd><m:mtd><m:mfrac><m:mrow><m:mn>2</m:mn></m:mrow><m:mrow><m:mi>t</m:mi><m:mo>−</m:mo><m:mi>b</m:mi></m:mrow></m:mfrac></m:mtd><m:mtd><m:mn>0</m:mn></m:mtd><m:mtd><m:mo>−</m:mo><m:mfrac><m:mrow><m:mi>t</m:mi><m:mo>+</m:mo><m:mi>b</m:mi></m:mrow><m:mrow><m:mi>t</m:mi><m:mo>−</m:mo><m:mi>b</m:mi></m:mrow></m:mfrac></m:mtd></m:mtr><m:mtr><m:mtd><m:mn>0</m:mn></m:mtd><m:mtd><m:mn>0</m:mn></m:mtd><m:mtd><m:mfrac><m:mrow><m:mn>2</m:mn></m:mrow><m:mrow><m:mi>n</m:mi><m:mo>−</m:mo><m:mi>f</m:mi></m:mrow></m:mfrac></m:mtd><m:mtd><m:mo>−</m:mo><m:mfrac><m:mrow><m:mi>n</m:mi><m:mo>+</m:mo><m:mi>f</m:mi></m:mrow><m:mrow><m:mi>n</m:mi><m:mo>−</m:mo><m:mi>f</m:mi></m:mrow></m:mfrac></m:mtd></m:mtr><m:mtr><m:mtd><m:mn>0</m:mn></m:mtd><m:mtd><m:mn>0</m:mn></m:mtd><m:mtd><m:mn>0</m:mn></m:mtd><m:mtd><m:mn>1</m:mn></m:mtd></m:mtr></m:mtable><m:mo>]</m:mo><m:mn>.</m:mn></m:mrow></m:mrow><m:mspace width="3em"/><m:mo>(8.3)</m:mo></m:math>
</div>
<aside class="footnote" epub:type="footnote" role="doc-footnote"><p><a href="#rfn8_1" id="fn8_1"><sup>1</sup></a> Most programmers find it intuitive to have the <em>x</em>-axis pointing right and the <em>y</em>-axis pointing up. In a right-handed coordinate system, this implies that we are looking in the –<em>z</em> direction. Some systems use a left-handed coordinate system for viewing so that the gaze direction is along +<em>z</em>. Which is best is a matter of taste, and this text assumes a right-handed coordinate system. A reference that argues for the left-handed system instead is given in the notes at the end of this chapter.</p></aside>
<p class="indent"><a id="term-77"/><a id="term-949"/><span aria-label="162" epub:type="pagebreak" id="pg_162" role="doc-pagebreak"/>To draw 3D line segments in the orthographic view volume, we project them into screen <em>x</em>-and <em>y</em>-coordinates and ignore <em>z</em>-coordinates. We do this by combining Equations (8.2) and (8.3). Note that in a program, we multiply the matrices together to form one matrix and then manipulate points as follows:</p>
<div class="disp-formula">
<m:math alttext=""><m:mrow><m:mrow><m:mo>[</m:mo><m:mtable><m:mtr><m:mtd><m:mtable><m:mtr><m:mtd><m:mtable><m:mtr><m:mtd><m:msub><m:mrow><m:mi>x</m:mi></m:mrow><m:mrow><m:mtext>pixel</m:mtext></m:mrow></m:msub></m:mtd></m:mtr><m:mtr><m:mtd><m:msub><m:mrow><m:mi>y</m:mi></m:mrow><m:mrow><m:mtext>pixel</m:mtext></m:mrow></m:msub></m:mtd></m:mtr></m:mtable></m:mtd></m:mtr><m:mtr><m:mtd><m:msub><m:mrow><m:mi>z</m:mi></m:mrow><m:mrow><m:mtext>canonical</m:mtext></m:mrow></m:msub></m:mtd></m:mtr></m:mtable></m:mtd></m:mtr><m:mtr><m:mtd><m:mn>1</m:mn></m:mtd></m:mtr></m:mtable><m:mo>]</m:mo><m:mo>=</m:mo><m:mrow><m:mo>(</m:mo><m:msub><m:mrow><m:mtext>M</m:mtext></m:mrow><m:mrow><m:mtext>vp</m:mtext></m:mrow></m:msub><m:msub><m:mrow><m:mtext>M</m:mtext></m:mrow><m:mrow><m:mtext>orth</m:mtext></m:mrow></m:msub><m:mo>)</m:mo></m:mrow><m:mrow><m:mo>[</m:mo><m:mtable><m:mtr><m:mtd><m:mtable><m:mtr><m:mtd><m:mtable><m:mtr><m:mtd><m:mi>x</m:mi></m:mtd></m:mtr><m:mtr><m:mtd><m:mi>y</m:mi></m:mtd></m:mtr></m:mtable></m:mtd></m:mtr><m:mtr><m:mtd><m:mi>z</m:mi></m:mtd></m:mtr></m:mtable></m:mtd></m:mtr><m:mtr><m:mtd><m:mn>1</m:mn></m:mtd></m:mtr></m:mtable><m:mo>]</m:mo><m:mn>.</m:mn></m:mrow></m:mrow></m:mrow></m:math>
</div>
<p>The <em>z</em>-coordinate will now be in [<em>–</em>1, 1]. We don’t take advantage of this now, but it will be useful when we examine z-buffer algorithms.</p>
<p>The code to draw many 3D lines with endpoints <strong>a</strong><em><sub>i</sub></em> and <strong>b</strong><em><sub>i</sub></em> thus becomes both simple and efficient:</p>
<aside class="boxed-text" epub:type="sidebar">
<p class="noindent">This is a first example of how matrix transformation machinery makes graphics programs clean and efficient.</p>
</aside>
<pre class="pre">construct <strong>M</strong><sub>vp</sub><br/>construct <strong>M</strong><sub>orth</sub><br/><strong>M</strong> = <strong>M</strong><sub>vp</sub><strong>M</strong><sub>orth</sub><br/><strong>for</strong> each line segment (<strong>a</strong><em><sub>i</sub></em>, <strong>b</strong><em><sub>i</sub></em>) <strong>do</strong><br/>  <strong>p</strong> = <strong>Ma</strong><em><sub>i</sub></em><br/>  <strong>q</strong> = <strong>Mb</strong><em><sub>i</sub></em><br/>  drawline(<em>x<sub>p</sub>, y<sub>p</sub>, x<sub>q</sub>, y<sub>q</sub></em>)</pre>
</section>
<section>
<h3 id="sec8_1_3"><a id="index_term120"/><a id="index_term1257"/><span class="green">8.1.3 The Camera Transformation</span></h3>
<p>We’d like to be able to change the viewpoint in 3D and look in any direction. There are a multitude of conventions for specifying viewer position and orientation. We will use the following one (see <a href="C13_chapter8.xhtml#f8_6">Figure 8.6</a>):</p>
<figure id="f8_6" tabindex="0">
<img alt="" src="../images/fig8_6.jpg"/>
<figcaption><p><span class="blue">Figure 8.6.</span> The user spec-ifies viewing as an eye position <strong>e</strong>, a gaze direction <strong>g</strong>, and an up vector <strong>t</strong>. We construct a right-handed basis with <strong>w</strong> pointing opposite to the gaze and <strong>v</strong> being in the same plane as <strong>g</strong> and <strong>t</strong>.</p></figcaption>
</figure>
<ul class="list-bullet">
<li>
<p class="list">the eye position <strong>e</strong>,</p>
</li>
<li>
<p class="list">the gaze direction <strong>g</strong>,</p>
</li>
<li>
<p class="list">the view-up vector <strong>t</strong>.</p>
</li>
</ul>
<p>The eye position is a location that the eye “sees from.” If you think of graphics as a photographic process, it is the center of the lens. The gaze direction is any vector in the direction that the viewer is looking. The view-up vector is any vector in the plane that both bisects the viewer’s head into right and left halves and points “to the sky” for a person standing on the ground. These vectors provide us with enough information to set up a coordinate system with origin <strong>e</strong> and a <strong>uvw</strong> basis, <a id="term-78"/><a id="term-950"/><span aria-label="163" epub:type="pagebreak" id="pg_163" role="doc-pagebreak"/>using the construction of <a href="C07_chapter2.xhtml#sec2_4_7">Section 2.4.7</a>:</p>
<figure id="f8_7" tabindex="0">
<img alt="" src="../images/fig8_7.jpg"/>
<figcaption><p><span class="blue">Figure 8.7.</span> For arbitrary viewing, we need to change the points to be stored in the “appropriate” coordinate system. In this case, it has origin <strong>e</strong> and offset coordinates in terms of <strong>uvw</strong>.</p></figcaption>
</figure>
<div class="disp-formula">
<m:math alttext=""><m:mrow><m:mtable><m:mtr><m:mtd><m:mtext>w</m:mtext></m:mtd><m:mtd><m:mo>=</m:mo></m:mtd><m:mtd><m:mo>−</m:mo><m:mfrac><m:mrow><m:mtext>g</m:mtext></m:mrow><m:mrow><m:mrow><m:mo>‖</m:mo><m:mtext>g</m:mtext><m:mo>‖</m:mo></m:mrow></m:mrow></m:mfrac><m:mo>,</m:mo></m:mtd></m:mtr><m:mtr><m:mtd><m:mtext>u</m:mtext></m:mtd><m:mtd><m:mo>=</m:mo></m:mtd><m:mtd><m:mfrac><m:mrow><m:mtext>t</m:mtext><m:mo>×</m:mo><m:mtext>w</m:mtext></m:mrow><m:mrow><m:mrow><m:mo>‖</m:mo><m:mtext>t</m:mtext><m:mo>×</m:mo><m:mtext>w</m:mtext><m:mo>‖</m:mo></m:mrow></m:mrow></m:mfrac><m:mo>,</m:mo></m:mtd></m:mtr><m:mtr><m:mtd><m:mtext>v</m:mtext></m:mtd><m:mtd><m:mo>=</m:mo></m:mtd><m:mtd><m:mtext>w</m:mtext><m:mo>×</m:mo><m:mtext>u.</m:mtext></m:mtd></m:mtr></m:mtable></m:mrow></m:math>
</div>
<p>Our job would be done if all points we wished to transform were stored in coordinates with origin <strong>e</strong> and basis vectors <strong>u</strong>, <strong>v</strong>,and <strong>w</strong>. But as shown in <a href="C13_chapter8.xhtml#f8_7">Figure 8.7</a>, the coordinates of the model are stored in terms of the canonical (or world) origin <strong>o</strong> and the <strong>x</strong>-, <strong>y</strong>-, and <strong>z</strong>-axes. To use the machinery we have already developed, we just need to convert the coordinates of the line segment endpoints we wish to draw from <em>xyz</em>-coordinates into <em>uvw</em>-coordinates. This kind of transformation was discussed in <a href="C12_chapter7.xhtml#sec7_5">Section 7.5</a>, and the matrix that enacts this transformation is the canonical-to-basis matrix of the camera’s coordinate frame:</p>
<div class="disp-formula" id="equ8_4">
<m:math alttext=""><m:mrow><m:msub><m:mrow><m:mtext>M</m:mtext></m:mrow><m:mrow><m:mtext>cam</m:mtext></m:mrow></m:msub><m:mo>=</m:mo><m:msup><m:mrow><m:mo>[</m:mo><m:mtable><m:mtr><m:mtd><m:mtext>u</m:mtext></m:mtd><m:mtd><m:mtext>v</m:mtext></m:mtd><m:mtd><m:mtext>w</m:mtext></m:mtd><m:mtd><m:mtext>e</m:mtext></m:mtd></m:mtr><m:mtr><m:mtd><m:mn>0</m:mn></m:mtd><m:mtd><m:mn>0</m:mn></m:mtd><m:mtd><m:mn>0</m:mn></m:mtd><m:mtd><m:mn>1</m:mn></m:mtd></m:mtr></m:mtable><m:mo>]</m:mo></m:mrow><m:mrow><m:mo>−</m:mo><m:mn>1</m:mn></m:mrow></m:msup><m:mo>=</m:mo><m:mrow><m:mo>[</m:mo><m:mtable><m:mtr><m:mtd><m:msub><m:mrow><m:mi>x</m:mi></m:mrow><m:mrow><m:mi>u</m:mi></m:mrow></m:msub></m:mtd><m:mtd><m:msub><m:mrow><m:mi>y</m:mi></m:mrow><m:mrow><m:mi>u</m:mi></m:mrow></m:msub></m:mtd><m:mtd><m:msub><m:mrow><m:mi>z</m:mi></m:mrow><m:mrow><m:mi>u</m:mi></m:mrow></m:msub></m:mtd><m:mtd><m:mn>0</m:mn></m:mtd></m:mtr><m:mtr><m:mtd><m:msub><m:mrow><m:mi>x</m:mi></m:mrow><m:mrow><m:mi>v</m:mi></m:mrow></m:msub></m:mtd><m:mtd><m:msub><m:mrow><m:mi>y</m:mi></m:mrow><m:mrow><m:mi>v</m:mi></m:mrow></m:msub></m:mtd><m:mtd><m:msub><m:mrow><m:mi>z</m:mi></m:mrow><m:mrow><m:mi>v</m:mi></m:mrow></m:msub></m:mtd><m:mtd><m:mn>0</m:mn></m:mtd></m:mtr><m:mtr><m:mtd><m:msub><m:mrow><m:mi>x</m:mi></m:mrow><m:mrow><m:mi>w</m:mi></m:mrow></m:msub></m:mtd><m:mtd><m:msub><m:mrow><m:mi>y</m:mi></m:mrow><m:mrow><m:mi>w</m:mi></m:mrow></m:msub></m:mtd><m:mtd><m:msub><m:mrow><m:mi>z</m:mi></m:mrow><m:mrow><m:mi>w</m:mi></m:mrow></m:msub></m:mtd><m:mtd><m:mn>0</m:mn></m:mtd></m:mtr><m:mtr><m:mtd><m:mn>0</m:mn></m:mtd><m:mtd><m:mn>0</m:mn></m:mtd><m:mtd><m:mn>0</m:mn></m:mtd><m:mtd><m:mn>1</m:mn></m:mtd></m:mtr></m:mtable><m:mo>]</m:mo></m:mrow><m:mrow><m:mo>[</m:mo><m:mtable><m:mtr><m:mtd><m:mn>1</m:mn></m:mtd><m:mtd><m:mn>0</m:mn></m:mtd><m:mtd><m:mn>0</m:mn></m:mtd><m:mtd><m:msub><m:mrow><m:mtable><m:mtr><m:mtd><m:mo>−</m:mo><m:mi>x</m:mi></m:mtd></m:mtr></m:mtable></m:mrow><m:mrow><m:mi>e</m:mi></m:mrow></m:msub></m:mtd></m:mtr><m:mtr><m:mtd><m:mn>0</m:mn></m:mtd><m:mtd><m:mn>1</m:mn></m:mtd><m:mtd><m:mn>0</m:mn></m:mtd><m:mtd><m:msub><m:mrow><m:mtable><m:mtr><m:mtd><m:mo>−</m:mo><m:mi>y</m:mi></m:mtd></m:mtr></m:mtable></m:mrow><m:mrow><m:mi>e</m:mi></m:mrow></m:msub></m:mtd></m:mtr><m:mtr><m:mtd><m:mn>0</m:mn></m:mtd><m:mtd><m:mn>0</m:mn></m:mtd><m:mtd><m:mn>1</m:mn></m:mtd><m:mtd><m:msub><m:mrow><m:mtable><m:mtr><m:mtd><m:mo>−</m:mo><m:mi>z</m:mi></m:mtd></m:mtr></m:mtable></m:mrow><m:mrow><m:mi>e</m:mi></m:mrow></m:msub></m:mtd></m:mtr><m:mtr><m:mtd><m:mn>0</m:mn></m:mtd><m:mtd><m:mn>0</m:mn></m:mtd><m:mtd><m:mn>0</m:mn></m:mtd><m:mtd><m:mn>1</m:mn></m:mtd></m:mtr></m:mtable><m:mo>]</m:mo><m:mn>.</m:mn></m:mrow></m:mrow><m:mspace width="3em"/><m:mo>(8.4)</m:mo></m:math>
</div>
<p>Alternatively, we can think of this same transformation as first moving <strong>e</strong> to the origin, then aligning <strong>u</strong>, <strong>v</strong>, <strong>w</strong> to <strong>x</strong>, <strong>y</strong>, <strong>z</strong>.</p>
<p>To make our previously <em>z</em>-axis-only viewing algorithm work for cameras with any location and orientation, we just need to add this camera transformation to <a id="term-648"/><a id="term-957"/><span aria-label="164" epub:type="pagebreak" id="pg_164" role="doc-pagebreak"/>the product of the viewport and projection transformations, so that it converts the incoming points from world to camera coordinates before they are projected:</p>
<pre class="pre">construct <strong>M</strong><sub>vp</sub><br/>construct <strong>M</strong><sub>orth</sub><br/>construct <strong>M</strong><sub>cam</sub><br/><strong>M</strong> = <strong>M</strong><sub>vp</sub><strong>M</strong><sub>orth</sub><strong>M</strong><sub>cam</sub><br/><strong>for</strong> each line segment (<strong>a</strong><em><sub>i</sub></em>, <strong>b</strong><em><sub>i</sub></em>) <strong>do</strong><br/>  <strong>p</strong> = <strong>Ma</strong><em><sub>i</sub></em><br/>  <strong>q</strong> = <strong>Mb</strong><em><sub>i</sub></em><br/>  drawline(<em>x<sub>p</sub>, y<sub>p</sub>, x<sub>q</sub>, y<sub>q</sub></em>)</pre>
<p class="noindent1">Again, almost no code is needed once the matrix infrastructure is in place.</p>
</section>
</section>
<section>
<h2 id="sec8_2"><a id="index_term909"/><a id="index_term1264"/><a epub:type="backlink" href="C02a_toc.xhtml#rsec8_2" role="doc-backlink"><span class="green">8.2 Projective Transformations</span></a></h2>
<p>We have left perspective for last because it takes a little bit of cleverness to make it fit into the system of vectors and matrix transformations that has served us so well up to now. To see what we need to do, let’s look at what the perspective projection transformation needs to do with points in camera space. Recall that the viewpoint is positioned at the origin and the camera is looking along the <em>z</em>-axis.</p>
<aside class="boxed-text" epub:type="sidebar">
<p class="noindent">For the moment, we will ignore the sign of <em>z</em> to keep the equations simpler, but it will return on page 168.</p>
</aside>
<p class="indent">The key property of perspective is that the size of an object on the screen is proportional to 1<em>/z</em> for an eye at the origin looking up the negative z-axis. This can be expressed more precisely in an equation for the geometry in <a href="C13_chapter8.xhtml#f8_8">Figure 8.8</a>:</p>
<div class="disp-formula" id="equ8_5">
<m:math alttext=""><m:mrow><m:msub><m:mrow><m:mi>y</m:mi></m:mrow><m:mrow><m:mi>s</m:mi></m:mrow></m:msub><m:mo>=</m:mo><m:mfrac><m:mrow><m:mi>d</m:mi></m:mrow><m:mrow><m:mi>z</m:mi></m:mrow></m:mfrac><m:mi>y</m:mi><m:mo>,</m:mo></m:mrow><m:mspace width="3em"/><m:mo>(8.5)</m:mo></m:math>
</div>
<figure id="f8_8" tabindex="0">
<img alt="" src="../images/fig8_8.jpg"/>
<figcaption><p><span class="blue">Figure 8.8.</span> The geometry for Equation (8.5). The viewer’s eye is at <strong>e</strong>, and the gaze direction is <strong>g</strong> (the minus <em>z</em>-axis). The view plane is a distance <em>d</em> from the eye. A point is projected toward <strong>e</strong> and where it intersects the view plane is where it is drawn.</p></figcaption>
</figure>
<p class="noindent1"><span aria-label="165" epub:type="pagebreak" id="pg_165" role="doc-pagebreak"/>where <em>y</em> is the distance of the point along the <em>y</em>-axis, and <em>y<sub>s</sub></em> is where the point should be drawn on the screen.</p>
<p>We would really like to use the matrix machinery we developed for ortho-graphic projection to draw perspective images; we could then just multiply another matrix into our composite matrix and use the algorithm we already have. However, this type of transformation, in which one of the coordinates of the input vector appears in the denominator, can’t be achieved using affine transformations.</p>
<p>We can allow for division with a simple generalization of the mechanism of <a id="index_term529"/>homogeneous coordinates that we have been using for affine transformations. We have agreed to represent the point (<em>x, y, z</em>) using the homogeneous vector [<em>x y z</em> 1]<sup>T</sup>; the extra coordinate, <em>w</em>, is always equal to 1, and this is ensured by always using [0 0 0 1]<sup>T</sup> as the fourth row of an affine transformation matrix.</p>
<p>Rather than just thinking of the 1 as an extra piece bolted on to coerce matrix multiplication to implement translation, we now define it to be the denominator of the <em>x</em>-, <em>y</em>-, and <em>z</em>-coordinates: the homogeneous vector [<em>x y z w</em>]<sup>T</sup> represents the point (<em>x/w, y/w, z/w</em>) . This makes no difference when <em>w</em> = 1, but it allows a broader range of transformations to be implemented if we allow any values in the bottom row of a transformation matrix, causing <em>w</em> to take on values other than 1.</p>
<p>Concretely, linear transformations allow us to compute expressions like</p>
<div class="disp-formula">
<m:math alttext=""><m:mrow><m:mi>x</m:mi><m:mo>′</m:mo><m:mo>=</m:mo><m:mi>a</m:mi><m:mi>x</m:mi><m:mo>+</m:mo><m:mi>b</m:mi><m:mi>y</m:mi><m:mo>+</m:mo><m:mi>c</m:mi><m:mi>z</m:mi></m:mrow></m:math>
</div>
<p>and affine transformations extend this to</p>
<div class="disp-formula">
<m:math alttext=""><m:mrow><m:mi>x</m:mi><m:mo>′</m:mo><m:mo>=</m:mo><m:mi>a</m:mi><m:mi>x</m:mi><m:mo>+</m:mo><m:mi>b</m:mi><m:mi>y</m:mi><m:mo>+</m:mo><m:mi>c</m:mi><m:mi>z</m:mi><m:mo>+</m:mo><m:mi>d</m:mi><m:mn>.</m:mn></m:mrow></m:math>
</div>
<p>Treating <em>w</em> as the denominator further expands the possibilities, allowing us to compute functions like</p>
<div class="disp-formula">
<m:math alttext=""><m:mrow><m:mi>x</m:mi><m:mo>′</m:mo><m:mo>=</m:mo><m:mfrac><m:mrow><m:mi>a</m:mi><m:mi>x</m:mi><m:mo>+</m:mo><m:mi>b</m:mi><m:mi>y</m:mi><m:mo>+</m:mo><m:mi>c</m:mi><m:mi>z</m:mi><m:mo>+</m:mo><m:mi>d</m:mi></m:mrow><m:mrow><m:mi>e</m:mi><m:mi>x</m:mi><m:mo>+</m:mo><m:mi>f</m:mi><m:mi>y</m:mi><m:mo>+</m:mo><m:mi>g</m:mi><m:mi>z</m:mi><m:mo>+</m:mo><m:mi>h</m:mi></m:mrow></m:mfrac><m:mo>;</m:mo></m:mrow></m:math>
</div>
<p>this could be called a “linear rational function” of <em>x</em>, <em>y</em>,and <em>z</em>. But there is an extra constraint—the denominators are the same for all coordinates of the transformed point:</p>
<div class="disp-formula">
<m:math alttext=""><m:mrow><m:mtable><m:mtr><m:mtd><m:mi>x</m:mi><m:mo>′</m:mo></m:mtd><m:mtd><m:mo>=</m:mo></m:mtd><m:mtd><m:mfrac><m:mrow><m:msub><m:mrow><m:mi>a</m:mi></m:mrow><m:mrow><m:mn>1</m:mn></m:mrow></m:msub><m:mi>x</m:mi><m:mo>+</m:mo><m:msub><m:mrow><m:mi>b</m:mi></m:mrow><m:mrow><m:mn>1</m:mn></m:mrow></m:msub><m:mi>y</m:mi><m:mo>+</m:mo><m:msub><m:mrow><m:mi>c</m:mi></m:mrow><m:mrow><m:mn>1</m:mn></m:mrow></m:msub><m:mi>z</m:mi><m:mo>+</m:mo><m:msub><m:mrow><m:mi>d</m:mi></m:mrow><m:mrow><m:mn>1</m:mn></m:mrow></m:msub></m:mrow><m:mrow><m:mi>e</m:mi><m:mi>x</m:mi><m:mo>+</m:mo><m:mi>f</m:mi><m:mi>y</m:mi><m:mo>+</m:mo><m:mi>g</m:mi><m:mi>z</m:mi><m:mo>+</m:mo><m:mi>h</m:mi></m:mrow></m:mfrac><m:mo>,</m:mo></m:mtd></m:mtr><m:mtr><m:mtd><m:mi>y</m:mi><m:mo>′</m:mo></m:mtd><m:mtd><m:mo>=</m:mo></m:mtd><m:mtd><m:mfrac><m:mrow><m:msub><m:mrow><m:mi>a</m:mi></m:mrow><m:mrow><m:mn>2</m:mn></m:mrow></m:msub><m:mi>x</m:mi><m:mo>+</m:mo><m:msub><m:mrow><m:mi>b</m:mi></m:mrow><m:mrow><m:mn>2</m:mn></m:mrow></m:msub><m:mi>y</m:mi><m:mo>+</m:mo><m:msub><m:mrow><m:mi>c</m:mi></m:mrow><m:mrow><m:mn>2</m:mn></m:mrow></m:msub><m:mi>z</m:mi><m:mo>+</m:mo><m:msub><m:mrow><m:mi>d</m:mi></m:mrow><m:mrow><m:mn>2</m:mn></m:mrow></m:msub></m:mrow><m:mrow><m:mi>e</m:mi><m:mi>x</m:mi><m:mo>+</m:mo><m:mi>f</m:mi><m:mi>y</m:mi><m:mo>+</m:mo><m:mi>g</m:mi><m:mi>z</m:mi><m:mo>+</m:mo><m:mi>h</m:mi></m:mrow></m:mfrac><m:mo>,</m:mo></m:mtd></m:mtr><m:mtr><m:mtd><m:mi>z</m:mi><m:mo>′</m:mo></m:mtd><m:mtd><m:mo>=</m:mo></m:mtd><m:mtd><m:mfrac><m:mrow><m:msub><m:mrow><m:mi>a</m:mi></m:mrow><m:mrow><m:mn>3</m:mn></m:mrow></m:msub><m:mi>x</m:mi><m:mo>+</m:mo><m:msub><m:mrow><m:mi>b</m:mi></m:mrow><m:mrow><m:mn>3</m:mn></m:mrow></m:msub><m:mi>y</m:mi><m:mo>+</m:mo><m:msub><m:mrow><m:mi>c</m:mi></m:mrow><m:mrow><m:mn>3</m:mn></m:mrow></m:msub><m:mi>z</m:mi><m:mo>+</m:mo><m:msub><m:mrow><m:mi>d</m:mi></m:mrow><m:mrow><m:mn>3</m:mn></m:mrow></m:msub></m:mrow><m:mrow><m:mi>e</m:mi><m:mi>x</m:mi><m:mo>+</m:mo><m:mi>f</m:mi><m:mi>y</m:mi><m:mo>+</m:mo><m:mi>g</m:mi><m:mi>z</m:mi><m:mo>+</m:mo><m:mi>h</m:mi></m:mrow></m:mfrac><m:mn>.</m:mn></m:mtd></m:mtr></m:mtable></m:mrow></m:math>
</div>
<p><a id="term-649"/><a id="term-958"/><span aria-label="166" epub:type="pagebreak" id="pg_166" role="doc-pagebreak"/>Expressed as a matrix transformation,</p>
<div class="disp-formula">
<m:math alttext=""><m:mrow><m:mrow><m:mo>[</m:mo><m:mtable><m:mtr><m:mtd><m:mtable><m:mtr><m:mtd><m:mtable><m:mtr><m:mtd><m:mover><m:mrow><m:mi>x</m:mi></m:mrow><m:mrow><m:mo>˜</m:mo></m:mrow></m:mover></m:mtd></m:mtr><m:mtr><m:mtd><m:mover><m:mrow><m:mi>y</m:mi></m:mrow><m:mrow><m:mo>˜</m:mo></m:mrow></m:mover></m:mtd></m:mtr></m:mtable></m:mtd></m:mtr><m:mtr><m:mtd><m:mover><m:mrow><m:mi>z</m:mi></m:mrow><m:mrow><m:mo>˜</m:mo></m:mrow></m:mover></m:mtd></m:mtr></m:mtable></m:mtd></m:mtr><m:mtr><m:mtd><m:mover><m:mrow><m:mi>w</m:mi></m:mrow><m:mrow><m:mo>˜</m:mo></m:mrow></m:mover></m:mtd></m:mtr></m:mtable><m:mo>]</m:mo></m:mrow><m:mo>=</m:mo><m:mrow><m:mo>[</m:mo><m:mtable><m:mtr><m:mtd><m:msub><m:mrow><m:mi>a</m:mi></m:mrow><m:mrow><m:mn>1</m:mn></m:mrow></m:msub></m:mtd><m:mtd><m:msub><m:mrow><m:mi>b</m:mi></m:mrow><m:mrow><m:mn>1</m:mn></m:mrow></m:msub></m:mtd><m:mtd><m:msub><m:mrow><m:mi>c</m:mi></m:mrow><m:mrow><m:mn>1</m:mn></m:mrow></m:msub></m:mtd><m:mtd><m:msub><m:mrow><m:mi>d</m:mi></m:mrow><m:mrow><m:mn>1</m:mn></m:mrow></m:msub></m:mtd></m:mtr><m:mtr><m:mtd><m:msub><m:mrow><m:mi>a</m:mi></m:mrow><m:mrow><m:mn>2</m:mn></m:mrow></m:msub></m:mtd><m:mtd><m:msub><m:mrow><m:mi>b</m:mi></m:mrow><m:mrow><m:mn>2</m:mn></m:mrow></m:msub></m:mtd><m:mtd><m:msub><m:mrow><m:mi>c</m:mi></m:mrow><m:mrow><m:mn>2</m:mn></m:mrow></m:msub></m:mtd><m:mtd><m:msub><m:mrow><m:mi>d</m:mi></m:mrow><m:mrow><m:mn>2</m:mn></m:mrow></m:msub></m:mtd></m:mtr><m:mtr><m:mtd><m:msub><m:mrow><m:mi>a</m:mi></m:mrow><m:mrow><m:mn>3</m:mn></m:mrow></m:msub></m:mtd><m:mtd><m:msub><m:mrow><m:mi>b</m:mi></m:mrow><m:mrow><m:mn>3</m:mn></m:mrow></m:msub></m:mtd><m:mtd><m:msub><m:mrow><m:mi>c</m:mi></m:mrow><m:mrow><m:mn>3</m:mn></m:mrow></m:msub></m:mtd><m:mtd><m:msub><m:mrow><m:mi>d</m:mi></m:mrow><m:mrow><m:mn>3</m:mn></m:mrow></m:msub></m:mtd></m:mtr><m:mtr><m:mtd><m:mi>e</m:mi></m:mtd><m:mtd><m:mi>f</m:mi></m:mtd><m:mtd><m:mi>g</m:mi></m:mtd><m:mtd><m:mi>h</m:mi></m:mtd></m:mtr></m:mtable><m:mo>]</m:mo></m:mrow><m:mrow><m:mo>[</m:mo><m:mtable><m:mtr><m:mtd><m:mtable><m:mtr><m:mtd><m:mtable><m:mtr><m:mtd><m:mi>x</m:mi></m:mtd></m:mtr><m:mtr><m:mtd><m:mi>y</m:mi></m:mtd></m:mtr></m:mtable></m:mtd></m:mtr><m:mtr><m:mtd><m:mi>z</m:mi></m:mtd></m:mtr></m:mtable></m:mtd></m:mtr><m:mtr><m:mtd><m:mn>1</m:mn></m:mtd></m:mtr></m:mtable><m:mo>]</m:mo></m:mrow></m:mrow></m:math>
</div>
<p>and</p>
<div class="disp-formula">
<m:math alttext=""><m:mrow><m:mrow><m:mo>(</m:mo><m:mi>x</m:mi><m:mo>′</m:mo><m:mo>,</m:mo><m:mi>y</m:mi><m:mo>′</m:mo><m:mo>,</m:mo><m:mi>z</m:mi><m:mo>′</m:mo><m:mo>)</m:mo><m:mo>=</m:mo><m:mrow><m:mo>(</m:mo><m:mover><m:mrow><m:mi>x</m:mi></m:mrow><m:mrow><m:mo>˜</m:mo></m:mrow></m:mover><m:mo>/</m:mo><m:mover><m:mrow><m:mi>w</m:mi></m:mrow><m:mrow><m:mo>˜</m:mo></m:mrow></m:mover><m:mo>,</m:mo><m:mover><m:mrow><m:mi>y</m:mi></m:mrow><m:mrow><m:mo>˜</m:mo></m:mrow></m:mover><m:mo>/</m:mo><m:mover><m:mrow><m:mi>w</m:mi></m:mrow><m:mrow><m:mo>˜</m:mo></m:mrow></m:mover><m:mo>,</m:mo><m:mover><m:mrow><m:mi>z</m:mi></m:mrow><m:mrow><m:mo>˜</m:mo></m:mrow></m:mover><m:mo>/</m:mo><m:mover><m:mrow><m:mi>w</m:mi></m:mrow><m:mrow><m:mo>˜</m:mo></m:mrow></m:mover><m:mo>)</m:mo></m:mrow></m:mrow><m:mn>.</m:mn></m:mrow></m:math>
</div>
<p>A transformation like this is known as a <em>projective transformation</em> or a <em>homography</em>.</p>
<aside class="boxed-text-e" epub:type="sidebar">
<p class="noindent1"><span class="blue">Example 17</span> The matrix</p>
<div class="disp-formula">
<m:math alttext=""><m:mrow><m:mtext>M</m:mtext><m:mo>=</m:mo><m:mrow><m:mo>[</m:mo><m:mtable><m:mtr><m:mtd><m:mn>2</m:mn></m:mtd><m:mtd><m:mn>0</m:mn></m:mtd><m:mtd><m:mo>−</m:mo><m:mn>1</m:mn></m:mtd></m:mtr><m:mtr><m:mtd><m:mn>0</m:mn></m:mtd><m:mtd><m:mn>3</m:mn></m:mtd><m:mtd><m:mn>0</m:mn></m:mtd></m:mtr><m:mtr><m:mtd><m:mn>0</m:mn></m:mtd><m:mtd><m:mfrac><m:mrow><m:mn>2</m:mn></m:mrow><m:mrow><m:mn>3</m:mn></m:mrow></m:mfrac></m:mtd><m:mtd><m:mfrac><m:mrow><m:mn>1</m:mn></m:mrow><m:mrow><m:mn>3</m:mn></m:mrow></m:mfrac></m:mtd></m:mtr></m:mtable><m:mo>]</m:mo></m:mrow></m:mrow></m:math>
</div>
<p>represents a 2D projective transformation that transforms the unit square ([0, 1] × [0, 1]) to the quadrilateral shown in <a href="C13_chapter8.xhtml#f8_9">Figure 8.9</a>.</p>
<p>For instance, the lower-right corner of the square at (1, 0) is represented by the homogeneous vector [1 0 1]<sup>T</sup> and transforms as follows:</p>
<div class="disp-formula">
<m:math alttext=""><m:mrow><m:mrow><m:mo>[</m:mo><m:mtable><m:mtr><m:mtd><m:mn>2</m:mn></m:mtd><m:mtd><m:mn>0</m:mn></m:mtd><m:mtd><m:mo>−</m:mo><m:mn>1</m:mn></m:mtd></m:mtr><m:mtr><m:mtd><m:mn>0</m:mn></m:mtd><m:mtd><m:mn>3</m:mn></m:mtd><m:mtd><m:mn>0</m:mn></m:mtd></m:mtr><m:mtr><m:mtd><m:mn>0</m:mn></m:mtd><m:mtd><m:mfrac><m:mrow><m:mn>2</m:mn></m:mrow><m:mrow><m:mn>3</m:mn></m:mrow></m:mfrac></m:mtd><m:mtd><m:mfrac><m:mrow><m:mn>1</m:mn></m:mrow><m:mrow><m:mn>3</m:mn></m:mrow></m:mfrac></m:mtd></m:mtr></m:mtable><m:mo>]</m:mo><m:mrow><m:mo>[</m:mo><m:mtable><m:mtr><m:mtd><m:mtable><m:mtr><m:mtd><m:mn>1</m:mn></m:mtd></m:mtr><m:mtr><m:mtd><m:mn>0</m:mn></m:mtd></m:mtr></m:mtable></m:mtd></m:mtr><m:mtr><m:mtd><m:mn>1</m:mn></m:mtd></m:mtr></m:mtable><m:mo>]</m:mo><m:mo>=</m:mo><m:mrow><m:mo>[</m:mo><m:mtable><m:mtr><m:mtd><m:mtable><m:mtr><m:mtd><m:mn>1</m:mn></m:mtd></m:mtr><m:mtr><m:mtd><m:mn>0</m:mn></m:mtd></m:mtr></m:mtable></m:mtd></m:mtr><m:mtr><m:mtd><m:mfrac><m:mrow><m:mn>1</m:mn></m:mrow><m:mrow><m:mn>3</m:mn></m:mrow></m:mfrac></m:mtd></m:mtr></m:mtable><m:mo>]</m:mo></m:mrow><m:mo>,</m:mo></m:mrow></m:mrow></m:mrow></m:math>
</div>
<figure id="f8_9" tabindex="0">
<img alt="" src="../images/fig8_9.jpg"/>
<figcaption><p><span class="blue">Figure 8.9.</span> A projective transformation maps a square to a quadrilateral, preserving straight lines but not parallel lines.</p></figcaption>
</figure>
<p class="noindent1">which represents the point <span class="inline-formula"><m:math alttext=""><m:mrow><m:mrow><m:mo>(</m:mo><m:mn>1</m:mn><m:mo>/</m:mo><m:mfrac><m:mrow><m:mn>1</m:mn></m:mrow><m:mrow><m:mn>3</m:mn></m:mrow></m:mfrac><m:mo>,</m:mo><m:mn>0</m:mn><m:mo>/</m:mo><m:mfrac><m:mrow><m:mn>1</m:mn></m:mrow><m:mrow><m:mn>3</m:mn></m:mrow></m:mfrac><m:mo>)</m:mo></m:mrow></m:mrow></m:math></span>, or (3, 0). Note that if we use the matrix</p>
<div class="disp-formula">
<m:math alttext=""><m:mrow><m:mtext>3</m:mtext><m:mtext>M</m:mtext><m:mo>=</m:mo><m:mrow><m:mo>[</m:mo><m:mtable><m:mtr><m:mtd><m:mn>6</m:mn></m:mtd><m:mtd><m:mn>0</m:mn></m:mtd><m:mtd><m:mo>−</m:mo><m:mn>3</m:mn></m:mtd></m:mtr><m:mtr><m:mtd><m:mn>0</m:mn></m:mtd><m:mtd><m:mn>9</m:mn></m:mtd><m:mtd><m:mn>0</m:mn></m:mtd></m:mtr><m:mtr><m:mtd><m:mn>0</m:mn></m:mtd><m:mtd><m:mn>2</m:mn></m:mtd><m:mtd><m:mn>1</m:mn></m:mtd></m:mtr></m:mtable><m:mo>]</m:mo></m:mrow></m:mrow></m:math>
</div>
<p>instead, the result is [3 0 1]<sup>T</sup>, which also represents (3, 0) . In fact, any scalar multiple <em>c</em><strong>M</strong> is equivalent: the numerator and denominator are both scaled by <em>c</em>, which does not change the result.</p>
</aside>
<p class="indent">There is a more elegant way of expressing the same idea, which avoids treating the <em>w</em>-coordinate specially. In this view, a 3D projective transformation is simply a 4D linear transformation, with the extra stipulation that all scalar multiples of a vector refer to the same point:</p>
<div class="disp-formula">
<m:math alttext=""><m:mrow><m:mtable><m:mtr><m:mtd><m:mtext>x</m:mtext><m:mtext> </m:mtext><m:mo>~</m:mo><m:mtext> </m:mtext><m:mi>α</m:mi><m:mtext>x</m:mtext></m:mtd><m:mtd><m:mtext>for all</m:mtext><m:mi>α</m:mi><m:mo>≠</m:mo><m:mn>0.</m:mn></m:mtd></m:mtr></m:mtable></m:mrow></m:math>
</div>
<p>The symbol ~ is read as “is equivalent to” and means that the two homogeneous vectors both describe the same point in space.</p>
<figure id="f8_10" tabindex="0">
<img alt="" src="../images/fig8_10.jpg"/>
<figcaption><p><span class="blue">Figure 8.10.</span> <a id="term-650"/><a id="term-959"/><span aria-label="167" epub:type="pagebreak" id="pg_167" role="doc-pagebreak"/>The point <em>x</em> = 1.5 is represented by any point on the line <em>x</em> =1.5<em>h</em>, such as points at the hollow circles. However, before we interpret <em>x</em> as a conventional Cartesian coordinate, we first divide by <em>h</em> to get (<em>x,h</em> ) = (1.5,1) as shown by the black point.</p></figcaption>
</figure>
<aside class="boxed-text-e" epub:type="sidebar">
<p class="noindent1"><span class="blue">Example 18</span> In 1D homogeneous coordinates, in which we use 2-vectors to represent points on the real line, we could represent the point (1.5) using the homogeneous vector [1.5 1]<sup>T</sup>, or any other point on the line <em>x</em> = 1.5<em>h</em> in homogeneous space. (See <a href="C13_chapter8.xhtml#f8_10">Figure 8.10</a>.)</p>
<p>In 2D homogeneous coordinates, in which we use 3-vectors to represent points in the plane, we could represent the point (<em>–</em>1, <em>–</em>0.5) using the homogeneous vector [<em>–</em>2; <em>–</em>1; 2]<sup>T</sup>, or any other point on the line <strong>x</strong> = α[<em>–</em>1 <em>–</em> 0.5 1]<sup>T</sup>. Any homogeneous vector on the line can be mapped to the line’s intersection with the plane <em>w</em> = 1 to obtain its Cartesian coordinates. (See <a href="C13_chapter8.xhtml#f8_11">Figure 8.11</a>.)</p>
</aside>
<p class="indentt">It’s fine to transform homogeneous vectors as many times as needed, without worrying about the value of the <em>w</em>-coordinate—in fact, it is fine if the <em>w-</em>coordinate is zero at some intermediate phase. It is only when we want the ordinary Cartesian coordinates of a point that we need to normalize to an equivalent point that has <em>w</em> = 1, which amounts to dividing all the coordinates by <em>w</em>. Once we’ve done this, we are allowed to read off the (<em>x, y, z</em>) -coordinates from the first three components of the homogeneous vector.</p>
<figure id="f8_11" tabindex="0">
<img alt="" src="../images/fig8_11.jpg"/>
<figcaption><p><span class="blue">Figure 8.11.</span> A point in homogeneous coordinates is equivalent to any other point on the line through it and the origin, and normalizing the point amounts to intersecting this line with the plane <em>w</em> =1.</p></figcaption>
</figure>
</section>
<section>
<h2 id="sec8_3"><a id="index_term840"/><a epub:type="backlink" href="C02a_toc.xhtml#rsec8_3" role="doc-backlink"><span class="green">8.3 Perspective Projection</span></a></h2>
<p>The mechanism of projective transformations makes it simple to implement the division by <em>z</em> required to implement perspective. In the 2D example shown in <a href="C13_chapter8.xhtml#f8_8">Figure 8.8</a>, we can implement the perspective projection with a matrix transformation</p>
<p class="noindent1"><span aria-label="168" epub:type="pagebreak" id="pg_168" role="doc-pagebreak"/>as follows:</p>
<div class="disp-formula">
<m:math alttext=""><m:mrow><m:mrow><m:mo>[</m:mo><m:mtable><m:mtr><m:mtd><m:msub><m:mrow><m:mi>y</m:mi></m:mrow><m:mrow><m:mi>s</m:mi></m:mrow></m:msub></m:mtd></m:mtr><m:mtr><m:mtd><m:mn>1</m:mn></m:mtd></m:mtr></m:mtable><m:mo>]</m:mo><m:mo>~</m:mo><m:mrow><m:mo>[</m:mo><m:mtable><m:mtr><m:mtd><m:mi>d</m:mi></m:mtd><m:mtd><m:mn>0</m:mn></m:mtd><m:mtd><m:mn>0</m:mn></m:mtd></m:mtr><m:mtr><m:mtd><m:mn>0</m:mn></m:mtd><m:mtd><m:mn>1</m:mn></m:mtd><m:mtd><m:mn>0</m:mn></m:mtd></m:mtr></m:mtable><m:mo>]</m:mo><m:mrow><m:mo>[</m:mo><m:mtable><m:mtr><m:mtd><m:mtable><m:mtr><m:mtd><m:mi>y</m:mi></m:mtd></m:mtr><m:mtr><m:mtd><m:mi>z</m:mi></m:mtd></m:mtr></m:mtable></m:mtd></m:mtr><m:mtr><m:mtd><m:mn>1</m:mn></m:mtd></m:mtr></m:mtable><m:mo>]</m:mo><m:mn>.</m:mn></m:mrow></m:mrow></m:mrow></m:mrow></m:math>
</div>
<p>This transforms the 2D homogeneous vector [<em>y</em>; <em>z</em>;1]<sup>T</sup> to the 1D homogeneous vector [<em>dy z</em>]<sup>T</sup>, which represents the 1D point (<em>dy/z</em>) (because it is equivalent to the 1D homogeneous vector [<em>dy/z</em> 1]<sup>T</sup>. This matches Equation (8.5).</p>
<p>For the “official” perspective projection matrix in 3D, we’ll adopt our usual convention of a camera at the origin facing in the <em>– z</em> direction, so the distance of the point (<em>x, y, z</em>) is <em>– z</em>. As with orthographic projection, we also adopt the notion of near and far planes that limit the range of distances to be seen. In this context, we will use the near plane as the projection plane, so the image plane distance is <em>– n</em>.</p>
<p>The desired mapping is then <em>y<sub>s</sub></em> = (<em>n/z</em>)<em>y</em>, and similarly for <em>x</em>. This transformation can be implemented by the <em>perspective matrix</em>:</p>
<aside class="boxed-text" epub:type="sidebar">
<p class="noindent">Remember, <em>n</em> <em>&lt;</em> 0.</p>
</aside>
<div class="disp-formula">
<m:math alttext=""><m:mrow><m:mtext>P</m:mtext><m:mo>=</m:mo><m:mrow><m:mo>[</m:mo><m:mtable><m:mtr><m:mtd><m:mi>n</m:mi></m:mtd><m:mtd><m:mn>0</m:mn></m:mtd><m:mtd><m:mn>0</m:mn></m:mtd><m:mtd><m:mn>0</m:mn></m:mtd></m:mtr><m:mtr><m:mtd><m:mn>0</m:mn></m:mtd><m:mtd><m:mi>n</m:mi></m:mtd><m:mtd><m:mn>0</m:mn></m:mtd><m:mtd><m:mn>0</m:mn></m:mtd></m:mtr><m:mtr><m:mtd><m:mn>0</m:mn></m:mtd><m:mtd><m:mn>0</m:mn></m:mtd><m:mtd><m:mi>n</m:mi><m:mo>+</m:mo><m:mi>f</m:mi></m:mtd><m:mtd><m:mo>−</m:mo><m:mi>f</m:mi><m:mi>n</m:mi></m:mtd></m:mtr><m:mtr><m:mtd><m:mn>0</m:mn></m:mtd><m:mtd><m:mn>0</m:mn></m:mtd><m:mtd><m:mn>1</m:mn></m:mtd><m:mtd><m:mn>0</m:mn></m:mtd></m:mtr></m:mtable><m:mo>]</m:mo><m:mn>.</m:mn></m:mrow></m:mrow></m:math>
</div>
<p>The first, second, and fourth rows simply implement the perspective equation. The third row, as in the orthographic and viewport matrices, is designed to bring the <em>z-</em>coordinate “along for the ride” so that we can use it later for hidden surface removal. In the perspective projection, though, the addition of a non-constant denominator prevents us from actually preserving the value of <em>z</em>—it’s actually impossible to keep <em>z</em> from changing while getting <em>x</em> and <em>y</em> to do what we need them to do. Instead, we’ve opted to keep <em>z</em> unchanged for points on the near or far planes.</p>
<aside class="boxed-text" epub:type="sidebar">
<p class="noindent">More on this later.</p>
</aside>
<p class="indent">There are many matrices that could function as perspective matrices, and all of them nonlinearly distort the <em>z</em>-coordinate. This specific matrix has the nice properties shown in <a href="C13_chapter8.xhtml#f8_12">Figures 8.12</a> and <a href="C13_chapter8.xhtml#f8_13">8.13</a>; it leaves points on the (<em>z</em> = <em>n</em>)-plane entirely alone, and it leaves points on the (<em>z</em> = <em>f</em> ) -plane while “squishing” them in <em>x</em> and <em>y</em> by the appropriate amount. The effect of the matrix on a point (<em>x, y, z</em>) is</p>
<div class="disp-formula">
<m:math alttext=""><m:mrow><m:mtext>P</m:mtext><m:mrow><m:mo>[</m:mo><m:mtable><m:mtr><m:mtd><m:mtable><m:mtr><m:mtd><m:mtable><m:mtr><m:mtd><m:mi>x</m:mi></m:mtd></m:mtr><m:mtr><m:mtd><m:mi>y</m:mi></m:mtd></m:mtr></m:mtable></m:mtd></m:mtr><m:mtr><m:mtd><m:mi>z</m:mi></m:mtd></m:mtr></m:mtable></m:mtd></m:mtr><m:mtr><m:mtd><m:mn>1</m:mn></m:mtd></m:mtr></m:mtable><m:mo>]</m:mo><m:mo>=</m:mo><m:mrow><m:mo>[</m:mo><m:mtable><m:mtr><m:mtd><m:mtable><m:mtr><m:mtd><m:mtable><m:mtr><m:mtd><m:mi>n</m:mi><m:mi>x</m:mi></m:mtd></m:mtr><m:mtr><m:mtd><m:mi>n</m:mi><m:mi>y</m:mi></m:mtd></m:mtr></m:mtable></m:mtd></m:mtr><m:mtr><m:mtd><m:mrow><m:mo>(</m:mo><m:mi>n</m:mi><m:mo>+</m:mo><m:mi>f</m:mi><m:mo>)</m:mo><m:mi>z</m:mi><m:mo>−</m:mo><m:mi>f</m:mi><m:mi>n</m:mi></m:mrow></m:mtd></m:mtr></m:mtable></m:mtd></m:mtr><m:mtr><m:mtd><m:mi>z</m:mi></m:mtd></m:mtr></m:mtable><m:mo>]</m:mo></m:mrow><m:mo>~</m:mo><m:mtext> </m:mtext><m:mrow><m:mo>[</m:mo><m:mtable><m:mtr><m:mtd><m:mtable><m:mtr><m:mtd><m:mtable><m:mtr><m:mtd><m:mtable><m:mtr><m:mtd><m:mfrac><m:mrow><m:mi>n</m:mi><m:mi>x</m:mi></m:mrow><m:mrow><m:mi>z</m:mi></m:mrow></m:mfrac></m:mtd></m:mtr><m:mtr><m:mtd><m:mfrac><m:mrow><m:mi>n</m:mi><m:mi>y</m:mi></m:mrow><m:mrow><m:mi>z</m:mi></m:mrow></m:mfrac></m:mtd></m:mtr></m:mtable></m:mtd></m:mtr><m:mtr><m:mtd><m:mi>n</m:mi><m:mo>+</m:mo><m:mi>f</m:mi><m:mo>−</m:mo><m:mfrac><m:mrow><m:mi>f</m:mi><m:mi>n</m:mi></m:mrow><m:mrow><m:mn>2</m:mn></m:mrow></m:mfrac></m:mtd></m:mtr></m:mtable></m:mtd></m:mtr><m:mtr><m:mtd><m:mn>1</m:mn></m:mtd></m:mtr></m:mtable></m:mtd></m:mtr><m:mtr><m:mtd/></m:mtr></m:mtable><m:mo>]</m:mo></m:mrow></m:mrow></m:mrow></m:math>
</div>
<figure id="f8_12" tabindex="0">
<img alt="" src="../images/fig8_12.jpg"/>
<figcaption><p><span class="blue">Figure 8.12.</span> <a id="term-599"/><span aria-label="169" epub:type="pagebreak" id="pg_169" role="doc-pagebreak"/>The perspective projection leaves points on the <em>z = n</em> plane unchanged and maps the large <em>z = f</em> rectangle at the back of the perspective volume to the small <em>z = f</em> rectangle at the back of the orthographic volume.</p></figcaption>
</figure>
<figure id="f8_13" tabindex="0">
<img alt="" src="../images/fig8_13.jpg"/>
<figcaption><p><span class="blue">Figure 8.13.</span> The perspective projection maps any line through the origin/eye to a line parallel to the <em>z</em>-axis and without moving the point on the line at <em>z =n</em>.</p></figcaption>
</figure>
<p class="noindent1">As you can see, <em>x</em> and <em>y</em> are scaled and, more importantly, divided by <em>z</em>. Because both <em>n</em> and <em>z</em> (inside the view volume) are negative, there are no “flips” in <em>x</em> and <em>y</em>. Although it is not obvious (see the exercise at the end of this chapter), the transform also preserves the relative order of <em>z</em> values between <em>z</em> = <em>n</em> and <em>z</em> = <em>f</em>, allowing us to do depth ordering after this matrix is applied. This will be important later when we do hidden surface elimination.</p>
<p>Sometimes, we will want to take the inverse of <strong>P</strong>, for example, to bring a screen coordinate plus <em>z</em> back to the original space, as we might want to do for <span aria-label="170" epub:type="pagebreak" id="pg_170" role="doc-pagebreak"/>picking. The inverse is</p>
<div class="disp-formula">
<m:math alttext=""><m:mrow><m:msup><m:mrow><m:mtext>P</m:mtext></m:mrow><m:mrow><m:mo>−</m:mo><m:mn>1</m:mn></m:mrow></m:msup><m:mo>=</m:mo><m:mrow><m:mo>[</m:mo><m:mtable><m:mtr><m:mtd><m:mfrac><m:mrow><m:mn>1</m:mn></m:mrow><m:mrow><m:mi>n</m:mi></m:mrow></m:mfrac></m:mtd><m:mtd><m:mn>0</m:mn></m:mtd><m:mtd><m:mn>0</m:mn></m:mtd><m:mtd><m:mn>0</m:mn></m:mtd></m:mtr><m:mtr><m:mtd><m:mn>0</m:mn></m:mtd><m:mtd><m:mfrac><m:mrow><m:mn>1</m:mn></m:mrow><m:mrow><m:mi>n</m:mi></m:mrow></m:mfrac></m:mtd><m:mtd><m:mn>0</m:mn></m:mtd><m:mtd><m:mn>0</m:mn></m:mtd></m:mtr><m:mtr><m:mtd><m:mn>0</m:mn></m:mtd><m:mtd><m:mn>0</m:mn></m:mtd><m:mtd><m:mn>0</m:mn></m:mtd><m:mtd><m:mn>1</m:mn></m:mtd></m:mtr><m:mtr><m:mtd><m:mn>0</m:mn></m:mtd><m:mtd><m:mn>0</m:mn></m:mtd><m:mtd><m:mo>−</m:mo><m:mfrac><m:mrow><m:mn>1</m:mn></m:mrow><m:mrow><m:mi>f</m:mi><m:mi>n</m:mi></m:mrow></m:mfrac></m:mtd><m:mtd><m:mfrac><m:mrow><m:mi>n</m:mi><m:mo>+</m:mo><m:mi>f</m:mi></m:mrow><m:mrow><m:mi>f</m:mi><m:mi>n</m:mi></m:mrow></m:mfrac></m:mtd></m:mtr></m:mtable><m:mn>.</m:mn><m:mo>]</m:mo></m:mrow></m:mrow></m:math>
</div>
<p>Since multiplying a homogeneous vector by a scalar does not change its meaning, the same is true of matrices that operate on homogeneous vectors. So we can write the inverse matrix in a prettier form by multiplying through by <em>nf</em> :</p>
<div class="disp-formula">
<m:math alttext=""><m:mrow><m:msup><m:mrow><m:mtext>P</m:mtext></m:mrow><m:mrow><m:mo>−</m:mo><m:mn>1</m:mn></m:mrow></m:msup><m:mo>=</m:mo><m:mrow><m:mo>[</m:mo><m:mtable><m:mtr><m:mtd><m:mi>f</m:mi></m:mtd><m:mtd><m:mn>0</m:mn></m:mtd><m:mtd><m:mn>0</m:mn></m:mtd><m:mtd><m:mn>0</m:mn></m:mtd></m:mtr><m:mtr><m:mtd><m:mn>0</m:mn></m:mtd><m:mtd><m:mi>f</m:mi></m:mtd><m:mtd><m:mn>0</m:mn></m:mtd><m:mtd><m:mn>0</m:mn></m:mtd></m:mtr><m:mtr><m:mtd><m:mn>0</m:mn></m:mtd><m:mtd><m:mn>0</m:mn></m:mtd><m:mtd><m:mn>0</m:mn></m:mtd><m:mtd><m:mi>f</m:mi><m:mi>n</m:mi></m:mtd></m:mtr><m:mtr><m:mtd><m:mn>0</m:mn></m:mtd><m:mtd><m:mn>0</m:mn></m:mtd><m:mtd><m:mo>−</m:mo><m:mn>1</m:mn></m:mtd><m:mtd><m:mi>n</m:mi><m:mo>+</m:mo><m:mi>f</m:mi></m:mtd></m:mtr></m:mtable><m:mn>.</m:mn><m:mo>]</m:mo></m:mrow></m:mrow></m:math>
</div>
<aside class="boxed-text" epub:type="sidebar">
<p class="noindent">This matrix is not literally the inverse of the matrix <strong>P</strong>, but the transformation it describes <em>is</em> the inverse of the transformation described by <strong>P</strong>.</p>
</aside>
<p>Taken in the context of the orthographic projection matrix <strong>M</strong><sub>orth</sub> in Equation (8.3), the perspective matrix simply maps the perspective view volume (which is shaped like a slice, or <em>frustum</em>, of a pyramid) to the orthographic view volume (which is an axis-aligned box). The beauty of the perspective matrix is that once we apply it, we can use an orthographic transform to get to the canonical view volume. Thus, all of the orthographic machinery applies, and all that we have added is one matrix and the division by <em>w</em>. It is also heartening that we are not “wasting” the bottom row of our four by four matrices!</p>
<p>Concatenating <strong>P</strong> with <strong>M</strong><sub>orth</sub> results in the <em>perspective projection matrix</em>,</p>
<div class="disp-formula">
<m:math alttext=""><m:mrow><m:msub><m:mrow><m:mtext>M</m:mtext></m:mrow><m:mrow><m:mtext>per</m:mtext></m:mrow></m:msub><m:mo>=</m:mo><m:msub><m:mrow><m:mtext>M</m:mtext></m:mrow><m:mrow><m:mtext>orth</m:mtext></m:mrow></m:msub><m:mtext>P.</m:mtext></m:mrow></m:math>
</div>
<p>One issue, however, is: How are <em>l,r,b,t</em> determined for perspective? They identify the “window” through which we look. Since the perspective matrix does not change the values of <em>x</em> and <em>y</em> on the (<em>z</em> = <em>n</em>) -plane, we can specify (<em>l, r, b, t</em>) on that plane.</p>
<p>To integrate the perspective matrix into our orthographic infrastructure, we simply replace <strong>M</strong><sub>orth</sub> with <strong>M</strong><sub>per</sub>, which inserts the perspective matrix <strong>P</strong> after the camera matrix <strong>M</strong><sub>cam</sub> has been applied but before the orthographic projection. So the full set of matrices for perspective viewing is</p>
<div class="disp-formula">
<m:math alttext=""><m:mrow><m:mtext>M</m:mtext><m:mo>=</m:mo><m:msub><m:mrow><m:mtext>M</m:mtext></m:mrow><m:mrow><m:mtext>vp</m:mtext></m:mrow></m:msub><m:msub><m:mrow><m:mtext>M</m:mtext></m:mrow><m:mrow><m:mtext>orth</m:mtext></m:mrow></m:msub><m:msub><m:mrow><m:mtext>PM</m:mtext></m:mrow><m:mrow><m:mtext>cam</m:mtext></m:mrow></m:msub></m:mrow></m:math>
</div>
<p>The resulting algorithm is</p>
<pre class="pre">compute <strong>M</strong><sub>vp</sub><br/>compute <strong>M</strong><sub>per</sub><br/>compute <strong>M</strong><sub>cam</sub><br/><a id="term-600"/><span aria-label="171" epub:type="pagebreak" id="pg_171" role="doc-pagebreak"/> <strong>M</strong> = <strong>M</strong><sub>vp</sub><strong>M</strong><sub>per</sub><strong>M</strong><sub>cam</sub><br/><strong>for</strong> each line segment (<strong>a</strong><em><sub>i</sub></em>, <strong>b</strong><em><sub>i</sub></em>) <strong>do</strong><br/>   <strong>p</strong> = <strong>Ma</strong><em><sub>i</sub></em><br/>   <strong>q</strong> = <strong>Mb</strong><em><sub>i</sub></em><br/>   drawline(<em>x<sub>p</sub> /w<sub>p</sub>, y<sub>p</sub> /w<sub>p</sub>, x<sub>q</sub> /w<sub>q</sub>, y<sub>q</sub> /w<sub>q</sub></em>)</pre>
<p class="noindent1">Note that the only change other than the additional matrix is the divide by the homogeneous coordinate <em>w</em>.</p>
<p>Multiplied out, the matrix <strong>M</strong><sub>per</sub> looks like this:</p>
<div class="disp-formula">
<m:math alttext=""><m:mrow><m:msub><m:mrow><m:mtext>M</m:mtext></m:mrow><m:mrow><m:mtext>per</m:mtext></m:mrow></m:msub><m:mo>=</m:mo><m:mrow><m:mo>[</m:mo><m:mtable><m:mtr><m:mtd><m:mfrac><m:mrow><m:mn>2</m:mn><m:mi>n</m:mi></m:mrow><m:mrow><m:mi>r</m:mi><m:mo>−</m:mo><m:mi>l</m:mi></m:mrow></m:mfrac></m:mtd><m:mtd><m:mn>0</m:mn></m:mtd><m:mtd><m:mfrac><m:mrow><m:mi>l</m:mi><m:mo>+</m:mo><m:mi>r</m:mi></m:mrow><m:mrow><m:mi>l</m:mi><m:mo>−</m:mo><m:mi>r</m:mi></m:mrow></m:mfrac></m:mtd><m:mtd><m:mn>0</m:mn></m:mtd></m:mtr><m:mtr><m:mtd><m:mn>0</m:mn></m:mtd><m:mtd><m:mfrac><m:mrow><m:mn>2</m:mn><m:mi>n</m:mi></m:mrow><m:mrow><m:mi>t</m:mi><m:mo>−</m:mo><m:mi>b</m:mi></m:mrow></m:mfrac></m:mtd><m:mtd><m:mfrac><m:mrow><m:mi>b</m:mi><m:mo>+</m:mo><m:mi>t</m:mi></m:mrow><m:mrow><m:mi>b</m:mi><m:mo>−</m:mo><m:mi>t</m:mi></m:mrow></m:mfrac></m:mtd><m:mtd><m:mn>0</m:mn></m:mtd></m:mtr><m:mtr><m:mtd><m:mn>0</m:mn></m:mtd><m:mtd><m:mn>0</m:mn></m:mtd><m:mtd><m:mfrac><m:mrow><m:mi>f</m:mi><m:mo>+</m:mo><m:mi>n</m:mi></m:mrow><m:mrow><m:mi>n</m:mi><m:mo>−</m:mo><m:mi>f</m:mi></m:mrow></m:mfrac></m:mtd><m:mtd><m:mfrac><m:mrow><m:mn>2</m:mn><m:mi>f</m:mi><m:mi>n</m:mi></m:mrow><m:mrow><m:mi>f</m:mi><m:mo>−</m:mo><m:mi>n</m:mi></m:mrow></m:mfrac></m:mtd></m:mtr><m:mtr><m:mtd><m:mn>0</m:mn></m:mtd><m:mtd><m:mn>0</m:mn></m:mtd><m:mtd><m:mn>1</m:mn></m:mtd><m:mtd><m:mn>0</m:mn></m:mtd></m:mtr></m:mtable><m:mo>]</m:mo><m:mn>.</m:mn></m:mrow></m:mrow></m:math>
</div>
<p>This or similar matrices often appear in documentation, and they are less mysterious when one realizes that they are usually the product of a few simple matrices.</p>
<aside class="boxed-text-e" epub:type="sidebar">
<p class="noindent1"><span class="blue">Example 19</span> Many APIs such as <em>OpenGL</em> (Shreiner, Neider, Woo, &amp; Davis, 2004) use the same canonical view volume as presented here. They also usually have the user specify the absolute values of <em>n</em> and <em>f</em> . The projection matrix for <em>OpenGL</em> is</p>
<div class="disp-formula">
<m:math alttext=""><m:mrow><m:msub><m:mrow><m:mtext>M</m:mtext></m:mrow><m:mrow><m:mtext>OpenGL</m:mtext></m:mrow></m:msub><m:mo>=</m:mo><m:mrow><m:mo>[</m:mo><m:mtable><m:mtr><m:mtd><m:mfrac><m:mrow><m:mn>2</m:mn><m:mrow><m:mo>|</m:mo><m:mi>n</m:mi><m:mo>|</m:mo></m:mrow></m:mrow><m:mrow><m:mi>r</m:mi><m:mo>−</m:mo><m:mi>l</m:mi></m:mrow></m:mfrac></m:mtd><m:mtd><m:mn>0</m:mn></m:mtd><m:mtd><m:mfrac><m:mrow><m:mi>r</m:mi><m:mo>+</m:mo><m:mi>l</m:mi></m:mrow><m:mrow><m:mi>r</m:mi><m:mo>−</m:mo><m:mi>l</m:mi></m:mrow></m:mfrac></m:mtd><m:mtd><m:mn>0</m:mn></m:mtd></m:mtr><m:mtr><m:mtd><m:mn>0</m:mn></m:mtd><m:mtd><m:mfrac><m:mrow><m:mn>2</m:mn><m:mrow><m:mo>|</m:mo><m:mi>n</m:mi><m:mo>|</m:mo></m:mrow></m:mrow><m:mrow><m:mi>t</m:mi><m:mo>−</m:mo><m:mi>b</m:mi></m:mrow></m:mfrac></m:mtd><m:mtd><m:mfrac><m:mrow><m:mi>t</m:mi><m:mo>+</m:mo><m:mi>b</m:mi></m:mrow><m:mrow><m:mi>t</m:mi><m:mo>−</m:mo><m:mi>b</m:mi></m:mrow></m:mfrac></m:mtd><m:mtd><m:mn>0</m:mn></m:mtd></m:mtr><m:mtr><m:mtd><m:mn>0</m:mn></m:mtd><m:mtd><m:mn>0</m:mn></m:mtd><m:mtd><m:mfrac><m:mrow><m:mrow><m:mo>|</m:mo><m:mi>n</m:mi><m:mo>|</m:mo><m:mo>+</m:mo><m:mrow><m:mo>|</m:mo><m:mi>f</m:mi><m:mo>|</m:mo></m:mrow></m:mrow></m:mrow><m:mrow><m:mrow><m:mo>|</m:mo><m:mi>n</m:mi><m:mo>|</m:mo><m:mo>−</m:mo><m:mrow><m:mo>|</m:mo><m:mi>f</m:mi><m:mo>|</m:mo></m:mrow></m:mrow></m:mrow></m:mfrac></m:mtd><m:mtd><m:mfrac><m:mrow><m:mn>2</m:mn><m:mrow><m:mo>|</m:mo><m:mi>f</m:mi><m:mo>|</m:mo><m:mrow><m:mo>|</m:mo><m:mi>n</m:mi><m:mo>|</m:mo></m:mrow></m:mrow></m:mrow><m:mrow><m:mrow><m:mo>|</m:mo><m:mi>n</m:mi><m:mo>|</m:mo><m:mo>−</m:mo><m:mrow><m:mo>|</m:mo><m:mi>f</m:mi><m:mo>|</m:mo></m:mrow></m:mrow></m:mrow></m:mfrac></m:mtd></m:mtr><m:mtr><m:mtd><m:mn>0</m:mn></m:mtd><m:mtd><m:mn>0</m:mn></m:mtd><m:mtd><m:mo>−</m:mo><m:mn>1</m:mn></m:mtd><m:mtd><m:mn>0</m:mn></m:mtd></m:mtr></m:mtable><m:mo>]</m:mo><m:mn>.</m:mn></m:mrow></m:mrow></m:math>
</div>
<p>Other APIs send <em>n</em> and <em>f</em> to 0 and 1, respectively. <a id="index_term92"/>Blinn (1996) recommends making the canonical view volume [0, 1]<sup>3</sup> for efficiency. All such decisions will change the projection matrix slightly.</p>
</aside>
</section>
<section>
<h2 id="sec8_4"><a id="index_term1262"/><a epub:type="backlink" href="C02a_toc.xhtml#rsec8_4" role="doc-backlink"><span class="green">8.4 Some Properties of the Perspective Transform</span></a></h2>
<p>An important property of the perspective transform is that it takes lines to lines and planes to planes. In addition, it takes line segments in the view volume to line <a id="term-955"/><span aria-label="172" epub:type="pagebreak" id="pg_172" role="doc-pagebreak"/>segments in the canonical volume. To see this, consider the line segment</p>
<div class="disp-formula">
<m:math alttext=""><m:mrow><m:mtext>q</m:mtext><m:mo>+</m:mo><m:mi>t</m:mi><m:mrow><m:mo>(</m:mo><m:mtext>Q</m:mtext><m:mo>−</m:mo><m:mtext>q</m:mtext><m:mo>)</m:mo><m:mn>.</m:mn></m:mrow></m:mrow></m:math>
</div>
<p>When transformed by a 4 × 4 matrix <strong>M</strong>, it is a point with possibly varying homogeneous coordinate:</p>
<div class="disp-formula">
<m:math alttext=""><m:mrow><m:mtext>Mq</m:mtext><m:mo>+</m:mo><m:mi>t</m:mi><m:mtext> </m:mtext><m:mrow><m:mo>(</m:mo><m:mtext>MQ</m:mtext><m:mo>−</m:mo><m:mtext>Mq</m:mtext><m:mo>)</m:mo><m:mo>≡</m:mo><m:mtext>r</m:mtext><m:mo>+</m:mo><m:mi>t</m:mi><m:mrow><m:mo>(</m:mo><m:mtext>R</m:mtext><m:mo>−</m:mo><m:mtext>r</m:mtext><m:mo>)</m:mo><m:mn>.</m:mn></m:mrow></m:mrow></m:mrow></m:math>
</div>
<p>The homogenized 3D line segment is</p>
<div class="disp-formula" id="equ8_6">
<m:math alttext=""><m:mrow><m:mfrac><m:mrow><m:mtext>r</m:mtext><m:mo>+</m:mo><m:mi>t</m:mi><m:mrow><m:mo>(</m:mo><m:mtext>R</m:mtext><m:mo>−</m:mo><m:mi>r</m:mi><m:mo>)</m:mo></m:mrow></m:mrow><m:mrow><m:msub><m:mrow><m:mi>w</m:mi></m:mrow><m:mrow><m:mi>r</m:mi></m:mrow></m:msub><m:mo>+</m:mo><m:mi>t</m:mi><m:mrow><m:mo>(</m:mo><m:msub><m:mrow><m:mi>w</m:mi></m:mrow><m:mrow><m:mi>R</m:mi></m:mrow></m:msub><m:mo>−</m:mo><m:msub><m:mrow><m:mi>w</m:mi></m:mrow><m:mrow><m:mi>r</m:mi></m:mrow></m:msub><m:mo>)</m:mo></m:mrow></m:mrow></m:mfrac><m:mn>.</m:mn></m:mrow><m:mspace width="3em"/><m:mo>(8.6)</m:mo></m:math>
</div>
<p>If Equation (8.6) can be rewritten in a form</p>
<div class="disp-formula" id="equ8_7">
<m:math alttext=""><m:mrow><m:mfrac><m:mrow><m:mtext>r</m:mtext></m:mrow><m:mrow><m:msub><m:mrow><m:mi>w</m:mi></m:mrow><m:mrow><m:mi>r</m:mi></m:mrow></m:msub></m:mrow></m:mfrac><m:mo>+</m:mo><m:mi>f</m:mi><m:mrow><m:mo>(</m:mo><m:mi>t</m:mi><m:mo>)</m:mo></m:mrow><m:mrow><m:mo>(</m:mo><m:mfrac><m:mrow><m:mtext>R</m:mtext></m:mrow><m:mrow><m:msub><m:mrow><m:mi>w</m:mi></m:mrow><m:mrow><m:mi>R</m:mi></m:mrow></m:msub></m:mrow></m:mfrac><m:mo>−</m:mo><m:mfrac><m:mrow><m:mtext>r</m:mtext></m:mrow><m:mrow><m:msub><m:mrow><m:mi>w</m:mi></m:mrow><m:mrow><m:mi>r</m:mi></m:mrow></m:msub></m:mrow></m:mfrac><m:mo>)</m:mo><m:mo>,</m:mo></m:mrow></m:mrow><m:mspace width="3em"/><m:mo>(8.7)</m:mo></m:math>
</div>
<p>then all the homogenized points lie on a 3D line. Brute force manipulation of Equation (8.6) yields such a form with</p>
<div class="disp-formula" id="equ8_8">
<m:math alttext=""><m:mrow><m:mi>f</m:mi><m:mrow><m:mrow><m:mo>(</m:mo><m:mi>t</m:mi><m:mo>)</m:mo></m:mrow><m:mo>=</m:mo><m:mfrac><m:mrow><m:msub><m:mrow><m:mi>w</m:mi></m:mrow><m:mrow><m:mi>R</m:mi></m:mrow></m:msub><m:mi>t</m:mi></m:mrow><m:mrow><m:msub><m:mrow><m:mi>w</m:mi></m:mrow><m:mrow><m:mi>r</m:mi></m:mrow></m:msub><m:mo>+</m:mo><m:mi>t</m:mi><m:mrow><m:mo>(</m:mo><m:msub><m:mrow><m:mi>w</m:mi></m:mrow><m:mrow><m:mi>R</m:mi></m:mrow></m:msub><m:mo>−</m:mo><m:msub><m:mrow><m:mi>w</m:mi></m:mrow><m:mrow><m:mi>r</m:mi></m:mrow></m:msub><m:mo>)</m:mo></m:mrow></m:mrow></m:mfrac></m:mrow><m:mn>.</m:mn></m:mrow><m:mspace width="3em"/><m:mo>(8.8)</m:mo></m:math>
</div>
<p>It also turns out that the line segments do map to line segments preserving the ordering of the points (Exercise 8); i.e., they do not get reordered or “torn.”</p>
<p>A byproduct of the transform taking line segments to line segments is that it takes the edges and vertices of a triangle to the edges and vertices of another triangle. Thus, it takes triangles to triangles and planes to planes.</p>
</section>
<section>
<h2 id="sec8_5"><a id="index_term1261"/><a epub:type="backlink" href="C02a_toc.xhtml#rsec8_5" role="doc-backlink"><span class="green">8.5 Field-of-View</span></a></h2>
<p>While we can specify any window using the (<em>l, r, b, t</em>) and <em>n</em> values, sometimes we would like to have a simpler system where we look through the center of the window. This implies the constraint that</p>
<div class="disp-formula">
<m:math alttext=""><m:mrow><m:mtable><m:mtr><m:mtd><m:mi>l</m:mi><m:mo>=</m:mo><m:mo>−</m:mo><m:mi>r</m:mi><m:mo>,</m:mo></m:mtd></m:mtr><m:mtr><m:mtd><m:mi>b</m:mi><m:mo>=</m:mo><m:mo>−</m:mo><m:mi>t</m:mi><m:mn>.</m:mn></m:mtd></m:mtr></m:mtable></m:mrow></m:math>
</div>
<p>If we also add the constraint that the pixels are square, i.e., there is no distortion of shape in the image, then the ratio of <em>r</em> to <em>t</em> must be the same as the ratio of the number of horizontal pixels to the number of vertical pixels:</p>
<div class="disp-formula">
<m:math alttext=""><m:mrow><m:mfrac><m:mrow><m:msub><m:mrow><m:mi>n</m:mi></m:mrow><m:mrow><m:mi>x</m:mi></m:mrow></m:msub></m:mrow><m:mrow><m:msub><m:mrow><m:mi>n</m:mi></m:mrow><m:mrow><m:mi>y</m:mi></m:mrow></m:msub></m:mrow></m:mfrac><m:mo>=</m:mo><m:mfrac><m:mrow><m:mi>r</m:mi></m:mrow><m:mrow><m:mi>t</m:mi></m:mrow></m:mfrac><m:mn>.</m:mn></m:mrow></m:math>
</div>
<figure id="f8_14" tabindex="0">
<img alt="" src="../images/fig8_14.jpg"/>
<figcaption><p><span class="blue">Figure 8.14.</span> <a id="term-280"/><a id="term-956"/><span aria-label="173" epub:type="pagebreak" id="pg_173" role="doc-pagebreak"/>The field-of-view θ is the angle from the bottom of the screen to the top of the screen as measured from the eye.</p></figcaption>
</figure>
<p class="noindent1">Once <em>n<sub>x</sub></em> and <em>n<sub>y</sub></em> are specified, this leaves only one degree of freedom. That is often set using the <em>field-of-view</em> shown as <em>θ</em> in <a href="C13_chapter8.xhtml#f8_14">Figure 8.14</a>. This is sometimes called the vertical field-of-view to distinguish it from the angle between left and right sides or from the angle between diagonal corners. From the figure, we can see that</p>
<div class="disp-formula">
<m:math alttext=""><m:mrow><m:mtext>tan</m:mtext><m:mfrac><m:mrow><m:mi>θ</m:mi></m:mrow><m:mrow><m:mn>2</m:mn></m:mrow></m:mfrac><m:mo>=</m:mo><m:mfrac><m:mrow><m:mi>t</m:mi></m:mrow><m:mrow><m:mrow><m:mo>|</m:mo><m:mi>n</m:mi><m:mo>|</m:mo></m:mrow></m:mrow></m:mfrac><m:mn>.</m:mn></m:mrow></m:math>
</div>
<p>If <em>n</em> and <em>θ</em> are specified, then we can derive <em>t</em> and use code for the more general viewing system. In some systems, the value of <em>n</em> is hard-coded to some reasonable value, and thus, we have one fewer degree of freedom.</p>
</section>
<section>
<h2 id="sec33"><span class="green">Frequently Asked Questions</span></h2>
<ul class="list-bullet">
<li>
<p class="list"><span class="green">Is orthographic projection ever useful in practice?</span></p>
<p class="noindent1b">It is useful in applications where relative length judgments are important. It can also yield simplifications where perspective would be too expensive as occurs in some medical visualization applications.</p>
</li>
<li>
<p class="list"><span class="green">The tessellated spheres I draw in perspective look like ovals. Is this a bug?</span></p>
<p class="noindent1b">No. It is correct behavior. If you place your eye in the same relative position to the screen as the virtual viewer has with respect to the viewport, then these ovals will look like circles because they themselves are viewed at an angle.</p>
</li>
<li>
<p class="list"><span class="green"><span aria-label="174" epub:type="pagebreak" id="pg_174" role="doc-pagebreak"/>Does the perspective matrix take negative <em>z</em> values to positive <em>z</em> values with a reversed ordering? Doesn’t that cause trouble?</span></p>
<p class="noindent1b">Yes. The equation for transformed <em>z</em> is</p>
<div class="disp-formula">
<m:math alttext=""><m:mrow><m:mi>z</m:mi><m:mo>′</m:mo><m:mo>=</m:mo><m:mi>n</m:mi><m:mo>+</m:mo><m:mi>f</m:mi><m:mo>−</m:mo><m:mfrac><m:mrow><m:mi>f</m:mi><m:mi>n</m:mi></m:mrow><m:mrow><m:mi>z</m:mi></m:mrow></m:mfrac><m:mn>.</m:mn></m:mrow></m:math>
</div>
<p>So <em>z</em> = + <em/> is transformed to <em>z<sup/></em> = –∞ and <em>z</em> = <em>–</em> is transformed to <em>z</em> = ∞. So any line segments that span <em>z</em> = 0 will be “torn” although all points will be projected to an appropriate screen location. This tearing is not relevant when all objects are contained in the viewing volume. This is usually assured by <em>clipping</em> to the view volume. However, clipping itself is made more complicated by the tearing phenomenon as is discussed in <a href="C14_chapter9.xhtml#c9">Chapter 9</a>.</p>
</li>
<li>
<p class="list"><span class="green">The perspective matrix changes the value of the homogeneous coordinate. Doesn’t that make the move and scale transformations no longer work properly?</span></p>
<p class="noindent1b">Applying a translation to a homogeneous point, we have</p>
<div class="disp-formula">
<m:math alttext=""><m:mrow><m:mrow><m:mo>[</m:mo><m:mtable><m:mtr><m:mtd><m:mn>1</m:mn></m:mtd><m:mtd><m:mn>0</m:mn></m:mtd><m:mtd><m:mn>0</m:mn></m:mtd><m:mtd><m:msub><m:mrow><m:mi>t</m:mi></m:mrow><m:mrow><m:mi>x</m:mi></m:mrow></m:msub></m:mtd></m:mtr><m:mtr><m:mtd><m:mn>0</m:mn></m:mtd><m:mtd><m:mn>1</m:mn></m:mtd><m:mtd><m:mn>0</m:mn></m:mtd><m:mtd><m:msub><m:mrow><m:mi>t</m:mi></m:mrow><m:mrow><m:mi>y</m:mi></m:mrow></m:msub></m:mtd></m:mtr><m:mtr><m:mtd><m:mn>0</m:mn></m:mtd><m:mtd><m:mn>0</m:mn></m:mtd><m:mtd><m:mn>1</m:mn></m:mtd><m:mtd><m:msub><m:mrow><m:mi>t</m:mi></m:mrow><m:mrow><m:mi>z</m:mi></m:mrow></m:msub></m:mtd></m:mtr><m:mtr><m:mtd><m:mn>0</m:mn></m:mtd><m:mtd><m:mn>0</m:mn></m:mtd><m:mtd><m:mn>0</m:mn></m:mtd><m:mtd><m:mn>1</m:mn></m:mtd></m:mtr></m:mtable><m:mo>]</m:mo><m:mrow><m:mo>[</m:mo><m:mtable><m:mtr><m:mtd><m:mtable><m:mtr><m:mtd><m:mtable><m:mtr><m:mtd><m:msub><m:mrow><m:mi>h</m:mi></m:mrow><m:mrow><m:mi>x</m:mi></m:mrow></m:msub></m:mtd></m:mtr><m:mtr><m:mtd><m:msub><m:mrow><m:mi>h</m:mi></m:mrow><m:mrow><m:mi>y</m:mi></m:mrow></m:msub></m:mtd></m:mtr></m:mtable></m:mtd></m:mtr><m:mtr><m:mtd><m:msub><m:mrow><m:mi>h</m:mi></m:mrow><m:mrow><m:mi>z</m:mi></m:mrow></m:msub></m:mtd></m:mtr></m:mtable></m:mtd></m:mtr><m:mtr><m:mtd><m:mi>h</m:mi></m:mtd></m:mtr></m:mtable><m:mo>]</m:mo><m:mo>=</m:mo><m:mrow><m:mo>[</m:mo><m:mtable><m:mtr><m:mtd><m:mtable><m:mtr><m:mtd><m:mtable><m:mtr><m:mtd><m:mi>h</m:mi><m:mi>x</m:mi><m:mo>+</m:mo><m:msub><m:mrow><m:mi>h</m:mi><m:mi>t</m:mi></m:mrow><m:mrow><m:mi>x</m:mi></m:mrow></m:msub></m:mtd></m:mtr><m:mtr><m:mtd><m:mi>h</m:mi><m:mi>y</m:mi><m:mo>+</m:mo><m:msub><m:mrow><m:mi>h</m:mi><m:mi>t</m:mi></m:mrow><m:mrow><m:mi>y</m:mi></m:mrow></m:msub></m:mtd></m:mtr></m:mtable></m:mtd></m:mtr><m:mtr><m:mtd><m:mi>h</m:mi><m:mi>z</m:mi><m:mo>+</m:mo><m:msub><m:mrow><m:mi>h</m:mi><m:mi>t</m:mi></m:mrow><m:mrow><m:mi>z</m:mi></m:mrow></m:msub></m:mtd></m:mtr></m:mtable></m:mtd></m:mtr><m:mtr><m:mtd><m:mi>h</m:mi></m:mtd></m:mtr></m:mtable><m:mo>]</m:mo></m:mrow></m:mrow></m:mrow><m:mover><m:mrow><m:mo>→</m:mo></m:mrow><m:mrow><m:mtext>homogenize</m:mtext></m:mrow></m:mover><m:mrow><m:mo>[</m:mo><m:mtable><m:mtr><m:mtd><m:mi>x</m:mi><m:mo>+</m:mo><m:msub><m:mrow><m:mi>t</m:mi></m:mrow><m:mrow><m:mi>x</m:mi></m:mrow></m:msub></m:mtd></m:mtr><m:mtr><m:mtd><m:mi>y</m:mi><m:mo>+</m:mo><m:msub><m:mrow><m:mi>t</m:mi></m:mrow><m:mrow><m:mi>y</m:mi></m:mrow></m:msub></m:mtd></m:mtr><m:mtr><m:mtd><m:mi>z</m:mi><m:mo>+</m:mo><m:msub><m:mrow><m:mi>t</m:mi></m:mrow><m:mrow><m:mi>z</m:mi></m:mrow></m:msub></m:mtd></m:mtr><m:mtr><m:mtd><m:mn>1</m:mn></m:mtd></m:mtr></m:mtable><m:mo>]</m:mo><m:mn>.</m:mn></m:mrow></m:mrow></m:math>
</div>
<p class="noindent">Similar effects are true for other transforms (see Exercise 5).</p>
</li>
</ul>
</section>
<section>
<h2 id="sec34"><span class="green">Notes</span></h2>
<p>Most of the discussion of viewing matrices is based on information in <em>Real-Time Rendering</em> (Akenine-Möller, Haines, &amp; Hoffman, 2008), the <em>OpenGL Programming Guide</em> (Shreiner et al., 2004), <em>Computer Graphics</em> (Hearn &amp; Baker, 1986), and <em>3D Game Engine Design</em> (Eberly, 2000).</p>
</section>
<section>
<h2 id="sec35"><span class="green">Exercises</span></h2>
<p class="qpara"><span class="green">1.</span> Construct the viewport matrix required for a system in which pixel coordinates count down from the top of the image, rather than up from the bottom.</p>
<p class="qpara"><span class="green">2.</span> Multiply the viewport and orthographic projection matrices, and show that the result can also be obtained by a single application of Equation (7.7).</p>
<p class="qpara"><span class="green">3.</span> <span aria-label="175" epub:type="pagebreak" id="pg_175" role="doc-pagebreak"/>Derive the third row of Equation (8.3) from the constraint that <em>z</em> is preserved for points on the near and far planes.</p>
<p class="qpara"><span class="green">4.</span> Show algebraically that the perspective matrix preserves order of <em>z</em> values within the view volume.</p>
<p class="qpara"><span class="green">5.</span> For a 4×4 matrix whose top three rows are arbitrary and whose bottom row is (0, 0, 0, 1), show that the points (<em>x, y, z,</em> 1) and (<em>hx, hy, hz, h</em>) transform to the same point after homogenization.</p>
<p class="qpara"><span class="green">6.</span> Verify that the form of <strong>M</strong><sup>–</sup>1 <em>p</em> given in the text is correct.</p>
<p class="qpara"><span class="green">7.</span> Verify that the full perspective to canonical matrix <strong>M</strong><sub>per</sub> takes (<em>r, t, n</em>) to (1, 1, 1) .</p>
<p class="qpara"><span class="green">8.</span> Write down a perspective matrix for <em>n</em> = 1, <em>f</em> = 2.</p>
<p class="qpara"><span class="green">9.</span> For the point <strong>p</strong> = (<em>x, y, z,</em> 1), what are the homogenized and unhomogenized results for that point transformed by the perspective matrix in Exercise 6?</p>
<p class="qpara1"><span class="green">10.</span> For the eye position <strong>e</strong> = (0, 1, 0), a gaze vector <strong>g</strong> = (0, <em>–</em>1, 0), andaviewup vector <strong>t</strong> = (1, 1, 0), what is the resulting orthonormal <strong>uvw</strong> basis used for coordinate rotations?</p>
<p class="qpara1"><span class="green">11.</span> Show, that for a perspective transform, line segments that start in the view volume do map to line segments in the canonical volume after homogenization. Furthermore, show that the relative ordering of points on the two segments is the same. <em>Hint</em>: Show that the <em>f</em> (<em>t</em>) in Equation (8.8) has the properties <em>f</em> (0) = 0, <em>f</em> (1) = 1, the derivative of <em>f</em> is positive for all <em>t</em> ∈ [0, 1], and the homogeneous coordinate does not change sign.</p>
</section>
</section>
</body>
</html>